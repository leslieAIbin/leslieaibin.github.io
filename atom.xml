<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Ai</title>
  
  <subtitle>春暖花开去见你</subtitle>
  <link href="https://leslieaibin.github.io/atom.xml" rel="self"/>
  
  <link href="https://leslieaibin.github.io/"/>
  <updated>2022-05-14T08:57:50.493Z</updated>
  <id>https://leslieaibin.github.io/</id>
  
  <author>
    <name>Leslie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01.IO多路复用基础</title>
    <link href="https://leslieaibin.github.io/2022/05/14/Netty/01.%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
    <id>https://leslieaibin.github.io/2022/05/14/Netty/01.%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-14T01:15:42.000Z</published>
    <updated>2022-05-14T08:57:50.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-O-五种IO模型"><a href="#I-O-五种IO模型" class="headerlink" title="I/O 五种IO模型"></a>I/O 五种IO模型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了加深对 <strong>I/O多路复用机制</strong> 的理解，以及了解到多路复用也有局限性，在这里我们先回顾下 <strong>Unix网络编程中的五种IO模型</strong>。</p><ul><li><p>  <strong>Blocking IO - 阻塞IO</strong></p></li><li><p>  <strong>NoneBlocking IO - 非阻塞IO</strong></p></li><li><p>  <strong>IO multiplexing - IO多路复用</strong></p></li><li><p>  <strong>signal driven IO - 信号驱动IO</strong></p></li><li><p>  <strong>asynchronous IO - 异步IO</strong></p></li></ul><h2 id="Unix网络编程中的五种IO模型"><a href="#Unix网络编程中的五种IO模型" class="headerlink" title="Unix网络编程中的五种IO模型"></a>Unix网络编程中的五种IO模型</h2><h3 id="阻塞IO-Blocking-IO"><a href="#阻塞IO-Blocking-IO" class="headerlink" title="阻塞IO - Blocking IO"></a>阻塞IO - Blocking IO</h3><p>最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。</p><p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/filters:no_upscale()"></p><blockquote><p>也许有人会说，可以采用多线程+ 阻塞IO 来解决效率问题，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</p></blockquote><h3 id="非阻塞IO-NoneBlocking-IO"><a href="#非阻塞IO-NoneBlocking-IO" class="headerlink" title="非阻塞IO - NoneBlocking IO"></a>非阻塞IO - NoneBlocking IO</h3><p>当用户线程发起一个 IO 操作后，并不需要等待，而是马上就得到一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 IO 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p><p>在非阻塞IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p><blockquote><p>对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514163555308.png" alt="image-20220514163555308"></p><ul><li><p>  非阻塞式主要体现在用户进程发起recvfrom系统调用的时候,这个时候系统内核还没有接收到数据报,直接返回错误给用户进程,告诉“当前还没有数据报可达,晚点再来”</p></li><li><p>  用户进程接收到信息,但是用户进程不知道什么时候数据报可达,于是就开始不断轮询(polling)向系统内核发起recvfrom的系统调用“询问数据来了没”,如果没有则继续返回错误</p></li><li><p>  用户进程轮询发起recvfrom系统调用直至数据报可达,这个时候需要等待系统内核复制数据报到用户进程的缓冲区,复制完成之后将返回成功提示</p></li></ul><h3 id="IO多路复用-IO-multiplexing"><a href="#IO多路复用-IO-multiplexing" class="headerlink" title="IO多路复用 - IO multiplexing"></a>IO多路复用 - IO multiplexing</h3><p>所谓 I/O 多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要 <code>select</code> 、 <code>poll</code> 、 <code>epoll</code> 来配合。</p><p>在多路复用IO模型中，会有一个内核线程不断地去轮询多个 socket 的状态，只有当真正读写事件发送时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有真正有读写事件进行时，才会使用IO资源，所以它大大减少来资源占用。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514163854576.png" alt="image-20220514163854576"></p><ul><li><p>  IO复用模式是使用select或者poll函数向系统内核发起调用，阻塞在这两个系统函数调用，而不是真正阻塞于实际的IO操作(recvfrom调用才是实际阻塞IO操作的系统调用)</p></li><li><p>  阻塞于select函数的调用,等待数据报套接字变为可读状态</p></li><li><p>  当select套接字返回可读状态的时候,就可以发起recvfrom调用把数据报复制到用户空间的缓冲区</p></li></ul><h3 id="信号驱动IO-signal-driven-IO"><a href="#信号驱动IO-signal-driven-IO" class="headerlink" title="信号驱动IO - signal driven IO"></a>信号驱动IO - signal driven IO</h3><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。这个一般用于UDP中，对TCP套接字几乎没用，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么请求。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514164305315.png" alt="image-20220514164305315"></p><p>用户进程可以使用信号方式，当系统内核描述符就绪时将会发送SIGNO给到用户空间，这个时候再发起recvfrom的系统调用等待返回成功提示，流程如下：</p><ul><li><p>  先开启套接字的信号IO启动功能，并通过一个内置安装信号处理函数的signaction系统调用，当发起调用之后会直接返回；</p></li><li><p>  其次，等待内核从网络中接收数据报之后，向用户空间发送当前数据可达的信号给信号处理函数；</p></li><li><p>  信号处理函数接收到信息就发起recvfrom系统调用等待内核数据复制数据报到用户空间的缓冲区；</p></li><li><p>  接收到复制完成的返回成功提示之后，应用进程就可以开始从网络中读取数据。</p></li></ul><h3 id="异步IO-asynchronous-IO"><a href="#异步IO-asynchronous-IO" class="headerlink" title="异步IO - asynchronous IO"></a>异步IO - asynchronous IO</h3><p>前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514164743871.png" alt="image-20220514164743871"></p><ul><li><p>  由POSIX规范定义，告知系统内核启动某个操作，并让内核在整个操作包含数据等待以及数据复制过程的完成之后通知用户进程数据已经准备完成，可以进行读取数据；</p></li><li><p>  与上述的信号IO模型区分在于异步是通知我们何时IO操作完成,而信号IO是通知我们何时可以启动一个IO操作</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现代计算机服务器操作系统大部分都是基于linxu实现,为处理高并发而采取NIO的模型,对于支持异步IO模型的系统持有不确定因素。</p><h4 id="同步与异步的定义"><a href="#同步与异步的定义" class="headerlink" title="同步与异步的定义"></a>同步与异步的定义</h4><ul><li><p>  同步:发起一个fn的调用,需要等待调用结果返回,该调用结果要么是期望的结果要么是异常抛出的结果,可以说是原子性操作(要么成功要么失败返回)</p></li><li><p>  异步: 发起一个fn调用,无需等待结果就直接返回,只有当被调用者执行处理程序之后通过“唤醒”手段通知调用方获取结果(唤醒的方式有回调,事件通知等)</p></li><li><p>  <strong>小结: 同步和异步关注的是程序之间的通信</strong></p></li></ul><h4 id="阻塞与非阻塞的定义"><a href="#阻塞与非阻塞的定义" class="headerlink" title="阻塞与非阻塞的定义"></a>阻塞与非阻塞的定义</h4><ul><li><p>  阻塞: 类比线程阻塞来说明,在并发多线程争抢资源的竞态条件下,如果有一个线程已持有锁,那么当前线程将无法获取锁而被挂起,处于等待状态</p></li><li><p>  非阻塞: 一旦线程释放锁,其他线程将会进入就绪状态,具备争抢锁的资格</p></li><li><p>  <strong>小结: 阻塞与非阻塞更关注是程序等待结果的状态</strong></p></li><li><p>  由此可知,同步异步与阻塞非阻塞之间不存在关联,关注的目标是不一样的</p></li></ul><h4 id="同步IO与异步IO-基于POSIX规范"><a href="#同步IO与异步IO-基于POSIX规范" class="headerlink" title="同步IO与异步IO(基于POSIX规范)"></a>同步IO与异步IO(基于POSIX规范)</h4><ul><li><p>  同步IO: 表示应用进程发起真实的IO操作请求(recvfrom)导致进程一直处于等待状态,这时候进程被阻塞,直到IO操作完成返回成功提示</p></li><li><p>  异步IO: 表示应用进程发起真实的IO操作请求(recvfrom)导致进程将直接返回一个错误信息,<strong>“相当于告诉进程还没有处理好,好了会通知你”</strong></p></li><li><p>  阻塞IO: 主要是体现发起IO操作请求通知内核并且内核接收到信号之后如果让进程等待,那么就是阻塞</p></li><li><p>  非阻塞IO: 发起IO操作请求的时候不论结果直接告诉进程“<strong>不用等待,晚点再来</strong>”,那就是非阻塞</p></li></ul><h4 id="IO模型对比"><a href="#IO模型对比" class="headerlink" title="IO模型对比"></a>IO模型对比</h4><p><strong><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://mmbiz.qpic.cn/mmbiz_png/x0aJCHEALOVINn8dZh1a2Ytw6UHicKK4giaXf9TBYJ7Kes5jnGHAkULmDUria9Dx7gSE7kxMsU0eI072s2lEIbhxQ/640?wx_fmt=png"></strong></p><ul><li><p>  根基上述的同步与异步IO定义并结合上述的模型可知,只有异步IO模型符合POSIX规范的异步IO,其他IO模型都存在recvfrom系统调用被内核阻塞,属于同步IO操作</p></li><li><p>  由此可知,阻塞IO与非阻塞IO可总结如下:</p></li><li><p>  也就是说,要么称为同步与异步IO,要么称为上述5种模型的IO说法,注意上述的同步与异步的概念</p></li><li><p>  大部分操作系统都是基于同步IO的方式实现,对于支持异步IO模型的操作系统还不确定,在实际工作我们经常会说Blocking-IO(阻塞IO)和Non-Blocking-IO(非阻塞IO),极少称同步IO与异步IO</p></li><li><p>  <strong>小结: 同步与异步针对通信机制,阻塞与非阻塞针对程序调用等待结果的状态</strong></p></li></ul><p><strong>一句话总结</strong>：</p><ul><li>  阻塞IO与非阻塞IO</li></ul><blockquote><p>这是最简单的模型，一般配合多线程来实现。</p></blockquote><ul><li>  多路复用(select/poll/epoll)</li></ul><blockquote><p>一个线程解决多连接的问题</p></blockquote><ul><li>  信号驱动IO模型</li></ul><blockquote><p>一种同步IO，更加灵活</p></blockquote><ul><li>  异步IO模型</li></ul><blockquote><p>高效主流的模型，效率很高。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;I-O-五种IO模型&quot;&gt;&lt;a href=&quot;#I-O-五种IO模型&quot; class=&quot;headerlink&quot; title=&quot;I/O 五种IO模型&quot;&gt;&lt;/a&gt;I/O 五种IO模型&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>02.RocketMQ部署</title>
    <link href="https://leslieaibin.github.io/2022/03/17/RocketMq/02.RocketMq%E9%83%A8%E7%BD%B2/"/>
    <id>https://leslieaibin.github.io/2022/03/17/RocketMq/02.RocketMq%E9%83%A8%E7%BD%B2/</id>
    <published>2022-03-17T11:15:42.000Z</published>
    <updated>2022-05-14T08:56:43.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h1><p>部署条件：</p><ul><li><strong>JDK 1.8.0_322</strong></li><li><strong>Maven Apache Maven 3.5.4</strong></li></ul><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>打开 <a href="http://rocketmq.apache.org/release_notes/">RocketMQ release_notes</a> 页面，我们可以看到 RocketMQ 所有的发布版本。这里，我们选择最新的 <a href="http://rocketmq.apache.org/release_notes/release-notes-4.6.0/">RocketMQ 4.6.0</a> 版本。点击进入该版本的发布页面后，我们可以看到两种发布版本：</p><ul><li>Source: <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.6.0/rocketmq-all-4.6.0-source-release.zip">rocketmq-all-4.6.0-source-release.zip</a></li><li>Binary: <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.6.0/rocketmq-all-4.6.0-bin-release.zip">rocketmq-all-4.6.0-bin-release.zip</a></li></ul><p>一般情况下，我们可以直接使用 Binary 版本，它是 RocketMQ 已经编译好，可以直接使用的 RocketMQ 软件包。</p><p>这里，我们想带着胖友们编译一次 RocketMQ 源码，所以使用 Source 版本。下面，我们开始下载 RocketMQ 4.6.0 Source 源码。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget wget http://mirror.bit.edu.cn/apache/rocketmq/4.9.3/rocketmq-all-4.9.3-source-release.zip</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> unzip rocketmq-all-4.9.3-source-release.zip</span></span><br></pre></td></tr></table></figure><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><p>使用 Maven 编译 RocketMQ 源码。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 RocketMQ 源码目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> rocketmq-all-4.9.3-source-release</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Maven 编译 RocketMQ ，并跳过测试。耐心等待...</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mvn -Prelease-all -DskipTests clean install -U</span></span><br></pre></td></tr></table></figure><p>编译完成，在我们进入 distribution 目录下，就可以看到 RocketMQ 的发布包了。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 distribution 目录下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> distribution/target/rocketmq-4.9.3/rocketmq-4.9.3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">40 -rwxr-xr-x   1 yunai  staff  17336 Nov 19 20:59 LICENSE</span><br><span class="line"> 8 -rwxr-xr-x   1 yunai  staff   1338 Nov 19 20:59 NOTICE</span><br><span class="line">16 -rwxr-xr-x   1 yunai  staff   4225 Nov 19 20:59 README.md</span><br><span class="line"> 0 drwxr-xr-x   6 yunai  staff    192 Dec  3 12:48 benchmark # 性能基准测试</span><br><span class="line"> 0 drwxr-xr-x  30 yunai  staff    960 Nov 19 20:59 bin # 执行脚本</span><br><span class="line"> 0 drwxr-xr-x  12 yunai  staff    384 Nov 19 20:59 conf # 配置文件</span><br><span class="line"> 0 drwxr-xr-x  36 yunai  staff   1152 Dec  3 12:48 lib # RocketMQ jar 包</span><br></pre></td></tr></table></figure><h2 id="启动Namesrv"><a href="#启动Namesrv" class="headerlink" title="启动Namesrv"></a>启动Namesrv</h2><p>启动一个 RocketMQ Namesrv 服务。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure><p>启动完成后，查看日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 Namesrv 日志。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tail -f ~/logs/rocketmqlogs/namesrv.log</span></span><br><span class="line"></span><br><span class="line">2019-12-03 12:58:04 INFO main - The Name Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure><ul><li>默认情况下，Namesrv 日志文件所在地址为 <code>~/logs/rocketmqlogs/namesrv.log</code> 。如果想要自定义，可以通过 <code>conf/logback_namesrv.xml</code> 配置文件来进行修改。</li></ul><p>本人是Mac m1 芯片可能会出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动RocketMQ报错：Please set the JAVA_HOME variable in your environment, We need java <span class="number">64</span></span><br></pre></td></tr></table></figure><p>解决方法：</p><p><a href="https://blog.csdn.net/suiyu_eran/article/details/104432164">https://blog.csdn.net/suiyu_eran/article/details/104432164</a></p><h2 id="启动-Broker"><a href="#启动-Broker" class="headerlink" title="启动 Broker"></a>启动 Broker</h2><p>在 <code>conf</code> 目录下，RocketMQ 提供了多种 Broker 的配置文件：</p><ul><li><code>broker.conf</code> ：单主，异步刷盘。</li><li><code>2m/</code> ：双主，异步刷盘。</li><li><code>2m-2s-async/</code> ：两主两从，异步复制，异步刷盘。</li><li><code>2m-2s-sync/</code> ：两主两从，同步复制，异步刷盘。</li><li><code>dledger/</code> ：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/dledger/deploy_guide.md">Dledger 集群</a>，至少三节点。</li></ul><p>这里，我们只启动一个 RocketMQ Broker 服务，所以使用 <code>broker.conf</code> 配置文件。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -c conf/broker.conf  -n 127.0.0.1:9876 &amp;</span><br></pre></td></tr></table></figure><ul><li><p>通过 <code>-c</code> 参数，配置读取的主 Broker 配置。</p></li><li><p>通过 <code>-n</code> 参数，设置 RocketMQ Namesrv 地址。</p></li><li><p>如果胖友的服务器的存相对小，可以修改下 <code>bin/runbroker.sh</code> 脚本，将 Broker JVM 内存调小。如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g&quot;</span><br></pre></td></tr></table></figure></li></ul><p>启动完成后，查看日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br><span class="line"></span><br><span class="line">2019-12-03 14:27:07 INFO main - The broker[broker-a, 192.168.3.44:10911] boot success. serializeType=JSON and name server is 127.0.0.1:9876</span><br></pre></td></tr></table></figure><ul><li>默认情况下，Broker 日志文件所在地址为 <code>~/logs/rocketmqlogs/broker.log</code> 。如果想要自定义，可以通过 <code>conf/logback_broker.xml</code> 配置文件来进行修改。</li></ul><h2 id="测试发送消息"><a href="#测试发送消息" class="headerlink" title="测试发送消息"></a>测试发送消息</h2><p>通过使用 <code>bin/tools.sh</code> 工具类，实现测试发送消息。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//查看broker配置</span><br><span class="line">sh ./bin/mqbroker -m</span><br><span class="line"></span><br><span class="line">//关闭broker</span><br><span class="line">sh bin/mqshutdown broker</span><br><span class="line"></span><br><span class="line">//将本机远程ip写入配置文件中</span><br><span class="line">echo &#x27;brokerIP1=111.231.XX.XX&#x27; &gt; conf/broker.properties </span><br><span class="line"></span><br><span class="line">//重新启动broker  最好用这个命令</span><br><span class="line">nohup sh bin/mqbroker -n 111.231.XX.XX:9876 -c conf/broker.conf autoCreateTopicEnable=true &amp;</span><br></pre></td></tr></table></figure><p>如果发送成功，我们会看到大量成功的发送日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SendResult [sendStatus=SEND_OK, msgId=FE800000000000004F2B5386138462F500000D7163610D67E7F100F4, offsetMsgId=C0A8032C00002A9F000000000000D7EE, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=0], queueOffset=61]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=FE800000000000004F2B5386138462F500000D7163610D67E7F200F5, offsetMsgId=C0A8032C00002A9F000000000000D8D1, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=1], queueOffset=61]</span><br></pre></td></tr></table></figure><ul><li>通过发送结果为 <code>sendStatus=SEND_OK</code> 状态，说明消息都发送成功了。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 发送的启动地址</span></span><br><span class="line">/Users/leslie/rocketmq-all-4.9.3/distribution/target/rocketmq-4.9.3/rocketmq-4.9.3</span><br></pre></td></tr></table></figure><h2 id="测试消费消息"><a href="#测试消费消息" class="headerlink" title="测试消费消息"></a>测试消费消息</h2><p>通过使用 <code>bin/tools.sh</code> 工具类，实现测试消费消息。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置 Namesrv 服务器的地址</span></span><br><span class="line">export NAMESRV_ADDR=127.0.0.1:9876</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行消费者 Consumer 消费测试消息</span></span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure><p>如果消费成功，我们会看到大量成功的消费日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConsumeMessageThread_4 Receive New Messages: [MessageExt [queueId=2, storeSize=227, queueOffset=131, sysFlag=0, bornTimestamp=1575354513732, bornHost=/192.168.3.44:55510, storeTimestamp=1575354513733, storeHost=/192.168.3.44:10911, msgId=C0A8032C00002A9F000000000001D1FC, commitLogOffset=119292, bodyCRC=1549304357, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=&#x27;TopicTest&#x27;, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=145, CONSUME_START_TIME=1575354867104, UNIQ_KEY=FE800000000000004F2B5386138462F500000D7163610D67E944020E, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 53, 50, 54], transactionId=&#x27;null&#x27;&#125;]]</span><br><span class="line">ConsumeMessageThread_3 Receive New Messages: [MessageExt [queueId=2, storeSize=227, queueOffset=130, sysFlag=0, bornTimestamp=1575354513729, bornHost=/192.168.3.44:55510, storeTimestamp=1575354513729, storeHost=/192.168.3.44:10911, msgId=C0A8032C00002A9F000000000001CE70, commitLogOffset=118384, bodyCRC=1530218044, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=&#x27;TopicTest&#x27;, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=145, CONSUME_START_TIME=1575354867103, UNIQ_KEY=FE800000000000004F2B5386138462F500000D7163610D67E941020A, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 53, 50, 50], transactionId=&#x27;null&#x27;&#125;]]</span><br></pre></td></tr></table></figure><ul><li>通过 <code>ConsumeMessageThread_4</code> 和 <code>ConsumeMessageThread_3</code> 线程名，我们可以看出，目前是进行并发消费消息。</li></ul><h1 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h1><h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建 DefaultMQProduer 对象</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;Please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 设置RocketMQ Namesrv的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 启动producer 生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 4. 创建 Message消息</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                        <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                        (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 5. 同步message发送消息</span></span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">                <span class="comment">// 6. 打印发送的结果</span></span><br><span class="line">                System.out.println(sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7. 关闭 producer 生产者</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化一个 Producer 生产者。</p><ul><li>1处，创建 DefaultMQProducer 对象，这里设置的生产者分组是 <code>&quot;please_rename_unique_group_name&quot;</code> 。</li><li>2处，设置 设置 <code>producer</code> 的 RocketMQ Namesrv 地址。这里，是艿艿额外添加的代码。</li><li>3处，启动 <code>producer</code> 生产者。</li></ul><p>使用 Producer 发送 1000 条消息。</p><ul><li><p>4处，创建 Message 消息。这里设置了其 Topic 为 <code>&quot;TopicTest&quot;</code>，Tag 为 <code>TagA</code>、消息体 Body 为 <code>&quot;Hello RocketMQ&quot;</code> 的二进制数组。</p></li><li><p>5 处，调用生产者的 <code>#send(Message msg)</code> 方法，<strong>同步</strong>发送消息，等待发送结果。RocketMQ Producer 一共有三种发送消息的方式，除了我们这里看到的同步发送消息之外，还有<strong>异步</strong>发送消息(可见 <a href="https://github.com/apache/rocketmq/blob/master/example/src/main/java/org/apache/rocketmq/example/simple/AsyncProducer.java">AsyncProducer</a> 示例)，和 <strong>Oneway</strong> 发送消息。</p></li><li><p>6处，打印发送结果。</p></li><li><p>7处，关闭 <code>producer</code> 生产者。</p></li></ul><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建DefaultMQPushConsumer 对象</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;Please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 设置RocketMQ Namesrv 地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 设置消费进度， 从Topic最初位置开始</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// 4. 订阅TopicTest主题</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 添加消息监听器</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="comment">// 返回成功</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//6. 启动producer 消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 打印 Consumer 启动完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>1 处，创建 DefaultMQPushConsumer 对象，这里设置的消费者分组是 <code>&quot;please_rename_unique_group_name&quot;</code> 。注意，消费者分组的概念：</p><blockquote><p>FROM <a href="https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md">概念(Concept)</a></p><p>同一类 Consumer 的集合，这类 Consumer 通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。</p><p>要注意的是，消费者组的消费者实例必须订阅完全相同的 Topic 。</p><p>RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p><ul><li>在集群消费下，同一条消息<strong>只</strong>会被<strong>相同</strong>消费者分组的<strong>一个</strong>消费者所消费。</li><li>在广播消费下，同一条消息会被<strong>相同</strong>消费者分组的<strong>所有</strong>消费者所消费。</li><li>在当前示例里，我们采用的是 DefaultMQPushConsumer 的默认消费方式，集群消费。</li></ul></blockquote></li><li><p>2处，设置 <code>consumer</code> 的 RocketMQ Namesrv 地址。这里，是艿艿额外添加的代码。</p></li><li><p>3处，设置一个新的消费集群，初始的消费进度。目前有三个选项：</p><ul><li><code>CONSUME_FROM_FIRST_OFFSET</code> ：每个 Topic 队列的第一条消息。</li><li><code>CONSUME_FROM_LAST_OFFSET</code> ：每个 Topic 队列的最后一条消息。</li><li><code>CONSUME_FROM_TIMESTAMP</code> ：每个 Topic 队列的指定时间开始的消息。</li><li>注意，只针对<strong>新的</strong>消费集群。如果一个集群每个 Topic 已经有消费进度，则继续使用该消费进度。仔细理解一下哈~</li></ul></li><li><p>4处，设置订阅 <code>&quot;TopicTest&quot;</code> 主题的消息。有一定一定要注意！！！<strong>消费者组的消费者实例必须订阅完全相同的 Topic + Tag</strong> 。</p></li><li><p>5处，添加消息监听器。这里我们采用的是 <a href="https://github.com/apache/rocketmq/blob/master/client/src/main/java/org/apache/rocketmq/client/consumer/listener/MessageListenerConcurrently.java">MessageListenerConcurrently</a> <strong>并发</strong>消费消息的监听器。如果胖友需要实现<strong>顺序</strong>消费消息，需要使用 <a href="https://github.com/apache/rocketmq/blob/master/client/src/main/java/org/apache/rocketmq/client/consumer/listener/MessageListenerOrderly.java">MessageListenerOrderly</a> <strong>顺序</strong>消费的监听器。</p></li><li><p>6处，启动 <code>consumer</code> 消费者。此时，Consumer 就开始正式的消费消息啦。。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单机部署&quot;&gt;&lt;a href=&quot;#单机部署&quot; class=&quot;headerlink&quot; title=&quot;单机部署&quot;&gt;&lt;/a&gt;单机部署&lt;/h1&gt;&lt;p&gt;部署条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JDK 1.8.0_322&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;st</summary>
      
    
    
    
    <category term="RocketMQ" scheme="https://leslieaibin.github.io/categories/RocketMQ/"/>
    
    
    <category term="RocketMQ" scheme="https://leslieaibin.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>01.RocketMQ概述</title>
    <link href="https://leslieaibin.github.io/2022/03/17/RocketMq/01.RocketMq%E5%85%A5%E9%97%A8/"/>
    <id>https://leslieaibin.github.io/2022/03/17/RocketMq/01.RocketMq%E5%85%A5%E9%97%A8/</id>
    <published>2022-03-17T01:15:42.000Z</published>
    <updated>2022-05-14T08:56:38.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>阿里巴巴消息中间件起源于 2001 年的五彩石项目， Notify 在这期间应运而生，用于交易核心消息的流转 。</p><ul><li><p>2010 年， B2B 开始大规模使用 ActiveMQ 作为消息内核，随着阿里业务的快速发展，急需一款支持顺序消息，拥有海量消息堆积能力的消息中间件， MetaQ 1.0 在 2011年诞生 。</p></li><li><p>2012年， MetaQ已经发展到了3.0版本，并抽象出了通用的消息引擎 RocketMQ。 随后，对 RocketMQ 进行了开源 ，阿里的消息中间件正式走人了 公众视野 。</p></li><li><p>2015年， RocketMQ已经经历了多年双十一的洗礼，在可用性、 可靠性以 及稳定性等方面都有出色的表现。与此同时 ，云计算大行其道， 阿里消息中间 件基于 RocketMQ推出了 Aliware MQ 1.0，开始为阿里云上成千上万家企业提 供消息服务 。</p></li><li><p>2016 年， MetaQ 在双十一期间承载了万亿级消息的流转，跨越了一个新的里程碑 ，同时 RocketMQ 进入Apache 孵化 。</p></li><li><p>2016年11月，阿里巴巴正式将RocketMQ捐献给Apache基金会，</p></li><li><p>2017年9月从Apache社区正式毕业，成为Apache的顶级开源项目。毕业之后RocketMQ受到了更为广泛的关注，除中国之外、日本、新加坡、泰国、俄罗斯、德国、美国、加拿大等国家也在关注RocketMQ。</p></li><li><p>2017年10月，我们提出OpenMessaging，OpenMessaging是一个消息标准，最初阿里有许多消息中间件，中间存在几个问题：</p><ul><li>面对不同的消息中间件，用户学习成本较高。</li><li>迁移成本非常高，且结果不统一。</li></ul></li><li><p>2018年我们提出RocketMQ 5.0，可能会做一些架构计算分离，包括协议可插拔，支持IoT的一些场景，目前我们正在演进该版本。</p></li></ul><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220317145623986.png" alt="image-20220317145623986"></p><p><strong>产生原因：</strong></p><p>淘宝内部的交易系统使用了淘宝自主研发的 Notify 消息中间件，使用 MySQL 作为消息存储媒介，可完全水平扩容。</p><p>为了进一步降低成本，我们认为存储部分可以进一步优化。2011 年初，Linkin 开源了 Kafka 这个优秀的消息中间件，淘宝中间件团队在对 Kafka 做过充分 Review 之后， Kafka 无限消息堆积，高效的持久化速度吸引了我们。</p><p>但是，同时发现这个消息系统主要定位于日志传输，对于使用在淘宝交易、订单、充值等场景下还有诸多特性不满足，为此我们重新用 Java 语言编写了 RocketMQ ，定位于非日志的可靠消息传输（日志场景也 OK）。</p><p>目前 RocketMQ 在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理， binglog 分发等场景。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="消息模型（Message-Model）"><a href="#消息模型（Message-Model）" class="headerlink" title="消息模型（Message Model）"></a>消息模型（Message Model）</h2><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p><h2 id="消息生产者（Producer）"><a href="#消息生产者（Producer）" class="headerlink" title="消息生产者（Producer）"></a>消息生产者（Producer）</h2><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p><h2 id="消息消费者（Consumer）"><a href="#消息消费者（Consumer）" class="headerlink" title="消息消费者（Consumer）"></a>消息消费者（Consumer）</h2><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p><h2 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）"></a>主题（Topic）</h2><p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p><h2 id="代理服务器（Broker-Server）"><a href="#代理服务器（Broker-Server）" class="headerlink" title="代理服务器（Broker Server）"></a>代理服务器（Broker Server）</h2><p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p><h2 id="名字服务（Name-Server）"><a href="#名字服务（Name-Server）" class="headerlink" title="名字服务（Name Server）"></a>名字服务（Name Server）</h2><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p><h2 id="拉取式消费（Pull-Consumer）"><a href="#拉取式消费（Pull-Consumer）" class="headerlink" title="拉取式消费（Pull Consumer）"></a>拉取式消费（Pull Consumer）</h2><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p><h2 id="推动式消费（Push-Consumer）"><a href="#推动式消费（Push-Consumer）" class="headerlink" title="推动式消费（Push Consumer）"></a>推动式消费（Push Consumer）</h2><p>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p><h2 id="生产者组（Producer-Group）"><a href="#生产者组（Producer-Group）" class="headerlink" title="生产者组（Producer Group）"></a>生产者组（Producer Group）</h2><p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p><h2 id="消费者组（Consumer-Group）"><a href="#消费者组（Consumer-Group）" class="headerlink" title="消费者组（Consumer Group）"></a>消费者组（Consumer Group）</h2><p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p><h2 id="集群消费（Clustering）"><a href="#集群消费（Clustering）" class="headerlink" title="集群消费（Clustering）"></a>集群消费（Clustering）</h2><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p><h2 id="广播消费（Broadcasting）"><a href="#广播消费（Broadcasting）" class="headerlink" title="广播消费（Broadcasting）"></a>广播消费（Broadcasting）</h2><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p><h2 id="普通顺序消息（Normal-Ordered-Message）"><a href="#普通顺序消息（Normal-Ordered-Message）" class="headerlink" title="普通顺序消息（Normal Ordered Message）"></a>普通顺序消息（Normal Ordered Message）</h2><p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p><h2 id="严格顺序消息（Strictly-Ordered-Message）"><a href="#严格顺序消息（Strictly-Ordered-Message）" class="headerlink" title="严格顺序消息（Strictly Ordered Message）"></a>严格顺序消息（Strictly Ordered Message）</h2><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p><h2 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）"></a>消息（Message）</h2><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p><h2 id="标签（Tag）"><a href="#标签（Tag）" class="headerlink" title="标签（Tag）"></a>标签（Tag）</h2><p>为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p><h1 id="相关特性"><a href="#相关特性" class="headerlink" title="相关特性"></a>相关特性</h1><h2 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h2><p>消息的发布是指某个生产者向某个topic发送消息；消息的订阅是指某个消费者关注了某个topic中带有某些tag的消息，进而从该topic消费数据。</p><h2 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h2><p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ可以严格的保证消息有序。</p><p>顺序消息分为全局顺序消息与分区顺序消息，全局顺序是指某个Topic下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</p><ul><li>全局顺序 对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。 适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</li><li>分区顺序 对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。 Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。 适用场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</li></ul><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>RocketMQ的消费者可以根据Tag进行消息过滤，也支持自定义属性过滤。消息过滤目前是在Broker端实现的，优点是减少了对于Consumer无用消息的网络传输，缺点是增加了Broker的负担、而且实现相对复杂。</p><h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><p>RocketMQ支持消息的高可靠，影响消息可靠性的几种情况：</p><ol><li>Broker非正常关闭</li><li>Broker异常Crash</li><li>OS Crash</li><li>机器掉电，但是能立即恢复供电情况</li><li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</li><li>磁盘设备损坏</li></ol><p>1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p><p>5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。</p><h2 id="至少一次"><a href="#至少一次" class="headerlink" title="至少一次"></a>至少一次</h2><p>至少一次(At least Once)指每个消息必须投递一次。Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。</p><h2 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h2><p>回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ支持按照时间回溯消费，时间维度精确到毫秒。</p><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>RocketMQ事务消息（Transactional Message）是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ的事务消息提供类似 X/Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致。</p><h2 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h2><p>定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。 broker有配置项messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。可以配置自定义messageDelayLevel。注意，messageDelayLevel是broker的属性，不属于某个topic。发消息时，设置delayLevel等级即可：msg.setDelayLevel(level)。level有以下三种情况：</p><ul><li>level == 0，消息为非延迟消息</li><li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1s</li><li>level &gt; maxLevel，则level== maxLevel，例如level==20，延迟2h</li></ul><p>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p><p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p><h2 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h2><p>Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p><ul><li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。</li><li>由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</li></ul><p>RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p><h2 id="消息重投"><a href="#消息重投" class="headerlink" title="消息重投"></a>消息重投</h2><p>生产者在发送消息时，同步消息失败会重投，异步消息有重试，oneway没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在RocketMQ中是无法避免的问题。消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer负载变化也会导致重复消息。如下方法可以设置消息重试策略：</p><ul><li>retryTimesWhenSendFailed:同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed + 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。</li><li>retryTimesWhenSendAsyncFailed:异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</li><li>retryAnotherBrokerWhenNotStoreOK:消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。十分重要消息可以开启。</li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>生产者流控，因为broker处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</p><p>生产者流控：</p><ul><li>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认为1000ms，返回流控。</li><li>如果开启transientStorePoolEnable == true，且broker为异步刷盘的主机，且transientStorePool中资源不足，拒绝当前send请求，返回流控。</li><li>broker每隔10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsInSendQueue，默认200ms，拒绝当前send请求，返回流控。</li><li>broker通过拒绝send 请求方式实现流量控制。</li></ul><p>注意，生产者流控，不会尝试消息重投。</p><p>消费者流控：</p><ul><li>消费者本地缓存消息数超过pullThresholdForQueue时，默认1000。</li><li>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB。</li><li>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认2000。</li></ul><p>消费者流控的结果是降低拉取频率。</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p><p>RocketMQ将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。在RocketMQ中，可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p> <img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220317152620545.png" alt="image-20220317152620545"></p><ul><li>生产者（Producer）：负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。</li><li>消费者（Consumer）：负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。</li><li>消息服务器（Broker）：是消息存储中心，主要作用是接收来自 Producer 的消息并存储， Consumer 从这里取得消息。</li><li>名称服务器（NameServer）：用来保存 Broker 相关 Topic 等元信息并给 Producer ，提供 Consumer 查找 Broker 信息。</li></ul><h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220317152958574.png" alt="image-20220317152958574"></p><p>1、启动 <strong>Namesrver</strong>，Namesrver起来后监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心。</p><p>2、<strong>Broker</strong> 启动，跟所有的 Namesrver 保持长连接，定时发送心跳包。</p><blockquote><p>心跳包中，包含当前 Broker 信息(IP+端口等)以及存储所有 Topic 信息。 注册成功后，Namesrver 集群中就有 Topic 跟 Broker 的映射关系。</p></blockquote><p>3、收发消息前，先创建 Topic 。创建 Topic 时，需要指定该 Topic 要存储在哪些 Broker上。也可以在发送消息时自动创建Topic。</p><p>4、<strong>Producer</strong> 发送消息。</p><blockquote><p>启动时，先跟 Namesrver 集群中的其中一台建立长连接，并从Namesrver 中获取当前发送的 Topic 存在哪些 Broker 上，然后跟对应的 Broker 建立长连接，直接向 Broker 发消息。</p></blockquote><p>5、<strong>Consumer</strong> 消费消息。</p><blockquote><p>Consumer 跟 Producer 类似。跟其中一台 Namesrv 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始消费消息。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>目前 RocketMQ 4 的中文文档很少，所以英文不太好的胖友，后续推荐看看如下资料：</p><ul><li><a href="http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408164726/RocketMQ_userguide.pdf">《RocketMQ 用户指南》</a> 基于 RocketMQ 3 的版本。</li><li><a href="http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408165024/RocketMQ_design.pdf">《RocketMQ 原理简介》</a> 基于 RocketMQ 3 的版本。</li><li><a href="http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408164929/RocketMQ_experience.pdf">《RocketMQ 最佳实践》</a> 基于 RocketMQ 3 的版本。</li><li><a href="https://github.com/apache/rocketmq/tree/master/docs/cn">《RocketMQ 开发者指南》</a> 基于 RocketMQ 4 的版本。</li><li><a href="https://help.aliyun.com/product/29530.html?spm=a2c4g.11186623.6.540.68cc5b3aZYDU2Y">《阿里云 —— 消息队列 MQ》</a> 阿里云的消息队列，就是 RocketMQ 的云服务。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;阿里巴巴消息中间件起源于 2001 年的五彩石项目， Notify 在这期间应运而生，用于交易核心消息的流转 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="RocketMQ" scheme="https://leslieaibin.github.io/categories/RocketMQ/"/>
    
    
    <category term="RocketMQ" scheme="https://leslieaibin.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>8.select poll epoll 区别</title>
    <link href="https://leslieaibin.github.io/2022/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.select%20poll%20%E5%92%8C%20epoll%E5%8C%BA%E5%88%AB/"/>
    <id>https://leslieaibin.github.io/2022/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.select%20poll%20%E5%92%8C%20epoll%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-10T16:15:42.000Z</published>
    <updated>2022-05-14T09:03:08.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="select、poll和epoll区别"><a href="#select、poll和epoll区别" class="headerlink" title="select、poll和epoll区别"></a>select、poll和epoll区别</h1><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic2.zhimg.com/v2-3c486898d786b26259c6abd6854794f5_b.jpg"></p><p>select单个进程可监视的fd数量受到限制，epoll和select都可实现同时监听多个I/O事件的状态。</p><ul><li>  select 基于轮训机制</li><li>  epoll基于操作系统支持的I/O通知机制 epoll支持水平触发和边沿触发两种模式。</li></ul><h2 id="1-select"><a href="#1-select" class="headerlink" title="1 select"></a>1 select</h2><p>select本质上是通过设置或检查存放fd标志位的数据结构进行下一步处理。 这带来缺点：</p><ul><li>  单个进程可监视的fd数量被限制，即能监听端口的数量有限 单个进程所能打开的最大连接数有<code>FD_SETSIZE</code>宏定义，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上FD_SETSIZE为3264），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试 一般该数和系统内存关系很大，具体数目可以<code>cat /proc/sys/fs/file-max</code>察看。32位机默认1024个，64位默认2048。</li></ul><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-62bedee13b5fa6c4022ade31c942316c_b.png"></p><ul><li>  对socket是线性扫描，即轮询，效率较低： 仅知道有I/O事件发生，却不知是哪几个流，只会无差异轮询所有流，找出能读数据或写数据的流进行操作。同时处理的流越多，无差别轮询时间越长 - O(n)。</li></ul><p>当socket较多时，每次select都要通过遍历<code>FD_SETSIZE</code>个socket，不管是否活跃，这会浪费很多CPU时间。如果能给 socket 注册某个回调函数，当他们活跃时，自动完成相关操作，即可避免轮询，这就是<strong>epoll</strong>与<strong>kqueue</strong>。</p><h2 id="1-1-调用过程"><a href="#1-1-调用过程" class="headerlink" title="1.1 调用过程"></a>1.1 调用过程</h2><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-7a9905f316445b3d7f7287d80a6fe460_b.jpg"></p><pre><code>asmlinkage long sys_poll(struct pollfd * ufds, unsigned int nfds, long timeout)&#123;    int i, j, fdcount, err;    struct pollfd **fds;    struct poll_wqueues table, *wait;    int nchunks, nleft;    /* Do a sanity check on nfds ... */    if (nfds &gt; NR_OPEN)        return -EINVAL;    if (timeout) &#123;        /* Careful about overflow in the intermediate values */        if ((unsigned long) timeout &lt; MAX_SCHEDULE_TIMEOUT / HZ)            timeout = (unsigned long)(timeout*HZ+999)/1000+1;        else /* Negative or overflow */            timeout = MAX_SCHEDULE_TIMEOUT;    &#125;    // 2. 注册回调函数__pollwait    poll_initwait(&amp;table);    wait = &amp;table;    if (!timeout)        wait = NULL;    err = -ENOMEM;    fds = NULL;    if (nfds != 0) &#123;        fds = (struct pollfd **)kmalloc(            (1 + (nfds - 1) / POLLFD_PER_PAGE) * sizeof(struct pollfd *),            GFP_KERNEL);        if (fds == NULL)            goto out;    &#125;    nchunks = 0;    nleft = nfds;    while (nleft &gt; POLLFD_PER_PAGE) &#123; /* allocate complete PAGE_SIZE chunks */        fds[nchunks] = (struct pollfd *)__get_free_page(GFP_KERNEL);        if (fds[nchunks] == NULL)            goto out_fds;        nchunks++;        nleft -= POLLFD_PER_PAGE;    &#125;    if (nleft) &#123; /* allocate last PAGE_SIZE chunk, only nleft elements used */        fds[nchunks] = (struct pollfd *)__get_free_page(GFP_KERNEL);        if (fds[nchunks] == NULL)            goto out_fds;    &#125;    err = -EFAULT;    for (i=0; i &lt; nchunks; i++)        //         if (copy_from_user(fds[i], ufds + i*POLLFD_PER_PAGE, PAGE_SIZE))            goto out_fds1;    if (nleft) &#123;        if (copy_from_user(fds[nchunks], ufds + nchunks*POLLFD_PER_PAGE,                 nleft * sizeof(struct pollfd)))            goto out_fds1;    &#125;    fdcount = do_poll(nfds, nchunks, nleft, fds, wait, timeout);    /* OK, now copy the revents fields back to user space. */    for(i=0; i &lt; nchunks; i++)        for (j=0; j &lt; POLLFD_PER_PAGE; j++, ufds++)            __put_user((fds[i] + j)-&gt;revents, &amp;ufds-&gt;revents);    if (nleft)        for (j=0; j &lt; nleft; j++, ufds++)            __put_user((fds[nchunks] + j)-&gt;revents, &amp;ufds-&gt;revents);    err = fdcount;    if (!fdcount &amp;&amp; signal_pending(current))        err = -EINTR;out_fds1:    if (nleft)        free_page((unsigned long)(fds[nchunks]));out_fds:    for (i=0; i &lt; nchunks; i++)        free_page((unsigned long)(fds[i]));    if (nfds != 0)        kfree(fds);out:    poll_freewait(&amp;table);    return err;&#125;static int do_poll(unsigned int nfds, unsigned int nchunks, unsigned int nleft,     struct pollfd *fds[], struct poll_wqueues *wait, long timeout)&#123;    int count;    poll_table* pt = &amp;wait-&gt;pt;    for (;;) &#123;        unsigned int i;        set_current_state(TASK_INTERRUPTIBLE);        count = 0;        for (i=0; i &lt; nchunks; i++)            do_pollfd(POLLFD_PER_PAGE, fds[i], &amp;pt, &amp;count);        if (nleft)            do_pollfd(nleft, fds[nchunks], &amp;pt, &amp;count);        pt = NULL;        if (count || !timeout || signal_pending(current))            break;        count = wait-&gt;error;        if (count)            break;        timeout = schedule_timeout(timeout);    &#125;    current-&gt;state = TASK_RUNNING;    return count;&#125;</code></pre><ol><li> 使用copy_from_user从用户空间拷贝fd_set到内核空间</li><li> 注册回调函数<code>__pollwait</code></li></ol><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-d4a98237f706b112ab6c6a6a94b6539c_b.jpg"></p><ol><li><p> 遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll，udp_poll或datagram_poll）</p></li><li><p> 以tcp_poll为例，核心实现就是<code>__pollwait</code>，即上面注册的回调函数</p></li><li><p> <code>__pollwait</code>，就是把current（当前进程）挂到设备的等待队列，不同设备有不同等待队列，如tcp_poll的等待队列是sk-&gt;sk_sleep（把进程挂到等待队列中并不代表进程已睡眠）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒。</p></li><li><p> poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值</p></li><li><p> 若遍历完所有fd，还没返回一个可读写的mask掩码，则调schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。若超过一定超时时间（schedule_timeout指定），还没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有无就绪的fd</p></li><li><p> 把fd_set从内核空间拷贝到用户空间</p></li></ol><h2 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 缺点</h2><p>内核需要将消息传递到用户空间，都需要内核拷贝动作。需要维护一个用来存放大量fd的数据结构，使得用户空间和内核空间在传递该结构时复制开销大。</p><ul><li>  每次调用select，都需把fd集合从用户态拷贝到内核态，fd很多时开销就很大</li><li>  同时每次调用select都需在内核遍历传递进来的所有fd，fd很多时开销就很大</li><li>  select支持的文件描述符数量太小了，默认最大支持1024个</li><li>  主动轮询效率很低</li></ul><h2 id="2-poll"><a href="#2-poll" class="headerlink" title="2 poll"></a>2 poll</h2><p>和select类似，只是描述fd集合的方式不同，poll使用<code>pollfd</code>结构而非select的<code>fd_set</code>结构。 管理多个描述符也是进行轮询，根据描述符的状态进行处理，但<strong>poll没有最大文件描述符数量的限制</strong>。</p><p>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><ul><li><p>  它将用户传入的数组拷贝到内核空间</p></li><li><p>  然后查询每个fd对应的设备状态：</p></li><li><p>  如果设备就绪 在设备等待队列中加入一项继续遍历</p></li><li><p>  若遍历完所有fd后，都没发现就绪的设备 挂起当前进程，直到设备就绪或主动超时，被唤醒后它又再次遍历fd。这个过程经历多次无意义的遍历。</p></li></ul><p>没有最大连接数限制，因其基于链表存储，其缺点：</p><ul><li>  大量fd数组被整体复制于用户态和内核地址空间间，而不管是否有意义</li><li>  如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd</li></ul><p>所以又有了epoll模型。</p><h2 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3 epoll"></a>3 epoll</h2><p>epoll模型修改主动轮询为被动通知，当有事件发生时，被动接收通知。所以epoll模型注册套接字后，主程序可做其他事情，当事件发生时，接收到通知后再去处理。</p><p>可理解为<strong>event poll</strong>，epoll会把哪个流发生哪种I/O事件通知我们。所以epoll是事件驱动（每个事件关联fd），此时我们对这些流的操作都是有意义的。复杂度也降到O(1)。</p><pre><code>asmlinkage int sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)&#123;    int error;    struct file *file, *tfile;    struct eventpoll *ep;    struct epitem *epi;    struct epoll_event epds;    error = -EFAULT;    if (copy_from_user(&amp;epds, event, sizeof(struct epoll_event)))        goto eexit_1;    /* Get the &quot;struct file *&quot; for the eventpoll file */    error = -EBADF;    file = fget(epfd);    if (!file)        goto eexit_1;    /* Get the &quot;struct file *&quot; for the target file */    tfile = fget(fd);    if (!tfile)        goto eexit_2;    /* The target file descriptor must support poll */    error = -EPERM;    if (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)        goto eexit_3;    /*     * We have to check that the file structure underneath the file descriptor     * the user passed to us _is_ an eventpoll file. And also we do not permit     * adding an epoll file descriptor inside itself.     */    error = -EINVAL;    if (file == tfile || !IS_FILE_EPOLL(file))        goto eexit_3;    /*     * At this point it is safe to assume that the &quot;private_data&quot; contains     * our own data structure.     */    ep = file-&gt;private_data;    /*     * Try to lookup the file inside our hash table. When an item is found     * ep_find() increases the usage count of the item so that it won&#39;t     * desappear underneath us. The only thing that might happen, if someone     * tries very hard, is a double insertion of the same file descriptor.     * This does not rapresent a problem though and we don&#39;t really want     * to put an extra syncronization object to deal with this harmless condition.     */    epi = ep_find(ep, tfile);    error = -EINVAL;    switch (op) &#123;    case EPOLL_CTL_ADD:        if (!epi) &#123;            epds.events |= POLLERR | POLLHUP;            error = ep_insert(ep, &amp;epds, tfile);        &#125; else            error = -EEXIST;        break;    case EPOLL_CTL_DEL:        if (epi)            error = ep_remove(ep, epi);        else            error = -ENOENT;        break;    case EPOLL_CTL_MOD:        if (epi) &#123;            epds.events |= POLLERR | POLLHUP;            error = ep_modify(ep, epi, &amp;epds);        &#125; else            error = -ENOENT;        break;    &#125;    /*     * The function ep_find() increments the usage count of the structure     * so, if this is not NULL, we need to release it.     */    if (epi)        ep_release_epitem(epi);eexit_3:    fput(tfile);eexit_2:    fput(file);eexit_1:    DNPRINTK(3, (KERN_INFO &quot;[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %u) = %d\n&quot;,             current, epfd, op, fd, event-&gt;events, error));    return error;&#125;</code></pre><p>​    </p><h2 id="3-1-触发模式"><a href="#3-1-触发模式" class="headerlink" title="3.1 触发模式"></a>3.1 触发模式</h2><p><strong>EPOLLLT</strong>和<strong>EPOLLET</strong>两种：</p><ul><li>  LT，默认的模式（水平触发） 只要该fd还有数据可读，每次 <code>epoll_wait</code> 都会返回它的事件，提醒用户程序去操作，</li><li>  ET是“高速”模式（边缘触发）</li></ul><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic2.zhimg.com/v2-310cc7857eabd42e324c109b5ca85b1d_b.png"></p><p>只会提示一次，直到下次再有数据流入之前都不会再提示，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读完，即读到read返回值小于请求值或遇到EAGAIN错误</p><p>epoll使用“事件”的就绪通知方式，通过<code>epoll_ctl</code>注册fd，一旦该fd就绪，内核就会采用类似回调机制激活该fd，<code>epoll_wait</code>便可收到通知。</p><h3 id="EPOLLET触发模式的意义"><a href="#EPOLLET触发模式的意义" class="headerlink" title="EPOLLET触发模式的意义"></a>EPOLLET触发模式的意义</h3><p>若用<code>EPOLLLT</code>，系统中一旦有大量无需读写的就绪文件描述符，它们每次调用<code>epoll_wait</code>都会返回，这大大降低处理程序检索自己关心的就绪文件描述符的效率。 而采用<code>EPOLLET</code>，当被监控的文件描述符上有可读写事件发生时，<code>epoll_wait</code>会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用<code>epoll_wait</code>时，它不会通知你，即只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。这比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。</p><h2 id="3-2-优点"><a href="#3-2-优点" class="headerlink" title="3.2 优点"></a>3.2 优点</h2><ul><li>  没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</li><li>  效率提升，不是轮询，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数 即Epoll最大的优点就在于它只关心“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll</li><li>  内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li><li>  epoll通过内核和用户空间共享一块内存来实现的</li></ul><p>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现。</p><p>select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p><ul><li>  对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</li><li>  对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。</li><li>  对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>select，poll，epoll都是IO多路复用机制，即可以监视多个描述符，一旦某个描述符就绪（读或写就绪），能够通知程序进行相应读写操作。 但select，poll，epoll本质上都是<strong>同步I/O</strong>，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><ul><li>  select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</li><li>  select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;select、poll和epoll区别&quot;&gt;&lt;a href=&quot;#select、poll和epoll区别&quot; class=&quot;headerlink&quot; title=&quot;select、poll和epoll区别&quot;&gt;&lt;/a&gt;select、poll和epoll区别&lt;/h1&gt;&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Ping的原理</title>
    <link href="https://leslieaibin.github.io/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.Ping%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.Ping%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2022-03-08T01:15:42.000Z</published>
    <updated>2022-03-08T02:37:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ping-的工作原理"><a href="#ping-的工作原理" class="headerlink" title="ping 的工作原理"></a>ping 的工作原理</h1><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="IP协议的助手-——-ICMP-协议"><a href="#IP协议的助手-——-ICMP-协议" class="headerlink" title="IP协议的助手 —— ICMP 协议"></a>IP协议的助手 —— ICMP 协议</h3><p>ping 是基于 <code>ICMP</code> 协议工作的，所以要明白 ping 的工作，首先我们先来熟悉 <strong>ICMP 协议</strong>。</p><blockquote><p>ICMP 是什么？</p></blockquote><p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。</p><p>里面有个关键词 —— <strong>控制</strong>，如何控制的呢？</p><p>网络包在复杂的网络传输环境里，常常会遇到各种问题。当遇到问题的时候，总不能死的不明不白，没头没脑的作风不是计算机网络的风格。所以需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。</p><blockquote><p>ICMP 功能都有啥？</p></blockquote><p><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/4.jpg" title="ICMP 目标不可达消息"></p><p>ICMP 目标不可达消息</p><p>如上图例子，主机 <code>A</code> 向主机 <code>B</code> 发送了数据包，由于某种原因，途中的路由器 <code>2</code> 未能发现主机 <code>B</code> 的存在，这时，路由器 <code>2</code> 就会向主机 <code>A</code> 发送一个 <code>ICMP</code> 目标不可达数据包，说明发往主机 <code>B</code> 的包未能成功。</p><p>ICMP 的这种通知消息会使用 <code>IP</code> 进行发送 。</p><p>因此，从路由器 <code>2</code> 返回的 ICMP 包会按照往常的路由控制先经过路由器 <code>1</code> 再转发给主机 <code>A</code> 。收到该 ICMP 包的主机 <code>A</code> 则分解 ICMP 的首部和数据域以后得知具体发生问题的原因。</p><blockquote><p>ICMP 包头格式</p></blockquote><p>ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/5.jpg" title="ICMP 报文">ICMP 报文</p><p>ICMP 包头的<strong>类型</strong>字段，大致可以分为两大类：</p><ul><li>  一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>  另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/6.jpg" title="常见的 ICMP 类型">常见的 ICMP 类型</p><h3 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h3><blockquote><p>回送消息 —— 类型 <code>0</code> 和 <code>8</code></p></blockquote><p><strong>回送消息</strong>用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，<code>ping</code> 命令就是利用这个消息实现的。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/7.jpg" title="ICMP 回送消息">ICMP 回送消息</p><p>可以向对端主机发送<strong>回送请求</strong>的消息（<code>ICMP Echo Request Message</code>，类型 <code>8</code>），也可以接收对端主机发回来的<strong>回送应答</strong>消息（<code>ICMP Echo Reply Message</code>，类型 <code>0</code>）。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/8.jpg" title="ICMP 回送请求和回送应答报文">ICMP 回送请求和回送应答报文</p><p>相比原生的 ICMP，这里多了两个字段：</p><ul><li>  <strong>标识符</strong>：用以区分是哪个应用程序发 ICMP 包，比如用进程 <code>PID</code> 作为标识符；</li><li>  <strong>序号</strong>：序列号从 <code>0</code> 开始，每发送一次新的回送请求就会加 <code>1</code>， 可以用来确认网络包是否有丢失。</li></ul><p>在<strong>选项数据</strong>中，<code>ping</code> 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。</p><h3 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h3><p>接下来，说明几个常用的 ICMP 差错报文的例子：</p><ul><li>  目标不可达消息 —— 类型 为 <code>3</code></li><li>  原点抑制消息 —— 类型 <code>4</code></li><li>  重定向消息 —— 类型 <code>5</code></li><li>  超时消息 —— 类型 <code>11</code></li></ul><blockquote><p>目标不可达消息（Destination Unreachable Message） —— 类型为 <code>3</code></p></blockquote><p>IP 路由器无法将 IP 数据包发送给目标地址时，会给发送端主机返回一个<strong>目标不可达</strong>的 ICMP 消息，并在这个消息中显示不可达的具体原因，原因记录在 ICMP 包头的<strong>代码</strong>字段。</p><p>由此，根据 ICMP 不可达的具体消息，发送端主机也就可以了解此次发送<strong>不可达的具体原因</strong>。</p><p>举例 6 种常见的目标不可达类型的<strong>代码</strong>：</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/9.jpg" title="目标不可达类型的常见代码号">目标不可达类型的常见代码号</p><ul><li>  网络不可达代码为 <code>0</code></li><li>  主机不可达代码为 <code>1</code></li><li>  协议不可达代码为 <code>2</code></li><li>  端口不可达代码为 <code>3</code></li><li>  需要进行分片但设置了不分片位代码为 <code>4</code></li></ul><p>为了给大家说清楚上面的目标不可达的原因，<strong>小林牺牲自己给大家送 5 次外卖。</strong></p><p>为什么要送外卖？别问，问就是为 <code>35</code> 岁的老林做准备 …</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/10.jpg" title="外卖员 —— 小林">外卖员 —— 小林</p><h6 id="a-网络不可达代码为-0"><a href="#a-网络不可达代码为-0" class="headerlink" title="a. 网络不可达代码为 0"></a>a. 网络不可达代码为 0</h6><p><em>外卖版本：</em></p><p>小林第一次送外卖时，小区里只有 A 和 B 区两栋楼，但送餐地址写的是 C 区楼，小林表示头上很多问号，压根就没这个地方。</p><p><em>正常版本：</em></p><p>IP 地址是分为网络号和主机号的，所以当路由器中的路由器表匹配不到接收方 IP 的网络号，就通过 ICMP 协议以<strong>网络不可达</strong>（<code>Network Unreachable</code>）的原因告知主机。</p><p>自从不再有网络分类以后，网络不可达也渐渐不再使用了。</p><h6 id="b-主机不可达代码为-1"><a href="#b-主机不可达代码为-1" class="headerlink" title="b. 主机不可达代码为 1"></a>b. 主机不可达代码为 1</h6><p><em>外卖版本：</em></p><p>小林第二次送外卖时，这次小区有 5 层楼高的 C 区楼了，找到地方了，但送餐地址写的是 C 区楼 601 号房 ，说明找不到这个房间。</p><p><em>正常版本：</em></p><p>当路由表中没有该主机的信息，或者该主机没有连接到网络，那么会通过 ICMP 协议以<strong>主机不可达</strong>（<code>Host Unreachable</code>）的原因告知主机。</p><h6 id="c-协议不可达代码为-2"><a href="#c-协议不可达代码为-2" class="headerlink" title="c. 协议不可达代码为 2"></a>c. 协议不可达代码为 2</h6><p><em>外卖版本：</em></p><p>小林第三次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，但是一开门人家是外国人说的是英语，我说的是中文！语言不通，外卖送达失败~</p><p><em>正常版本：</em></p><p>当主机使用 TCP 协议访问对端主机时，能找到对端的主机了，可是对端主机的防火墙已经禁止 TCP 协议访问，那么会通过 ICMP 协议以<strong>协议不可达</strong>的原因告知主机。</p><h6 id="d-端口不可达代码为-3"><a href="#d-端口不可达代码为-3" class="headerlink" title="d. 端口不可达代码为 3"></a>d. 端口不可达代码为 3</h6><p><em>外卖版本：</em></p><p>小林第四次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，房间里的人也是说中文的人了，但是人家说他要的不是外卖，而是快递。。。</p><p><em>正常版本：</em></p><p>当主机访问对端主机 8080 端口时，这次能找到对端主机了，防火墙也没有限制，可是发现对端主机没有进程监听 8080 端口，那么会通过 ICMP 协议以<strong>端口不可达</strong>的原因告知主机。</p><h6 id="e-需要进行分片但设置了不分片位代码为-4"><a href="#e-需要进行分片但设置了不分片位代码为-4" class="headerlink" title="e. 需要进行分片但设置了不分片位代码为 4"></a>e. 需要进行分片但设置了不分片位代码为 4</h6><p><em>外卖版本：</em></p><p>小林第五次送外卖时，这次是个吃播博主点了 100 份外卖，但是吃播博主要求一次性要把全部外卖送达，小林的一台电动车装不下呀，这样就没办法送达了。</p><p><em>正常版本：</em></p><p>发送端主机发送 IP 数据报时，将 IP 首部的<strong>分片禁止标志位</strong>设置为<code>1</code>。根据这个标志位，途中的路由器遇到超过 MTU 大小的数据包时，不会进行分片，而是直接抛弃。</p><p>随后，通过一个 ICMP 的不可达消息类型，<strong>代码为 4</strong> 的报文，告知发送端主机。</p><blockquote><p>原点抑制消息（ICMP Source Quench Message） —— 类型 <code>4</code></p></blockquote><p>在使用低速广域线路的情况下，连接 WAN 的路由器可能会遇到网络拥堵的问题。</p><p><code>ICMP</code> 原点抑制消息的目的就是<strong>为了缓和这种拥堵情况</strong>。</p><p>当路由器向低速线路发送数据时，其发送队列的缓存变为零而无法发送出去时，可以向 IP 包的源地址发送一个 ICMP <strong>原点抑制消息</strong>。</p><p>收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况，从而增大 IP 包的传输间隔，减少网络拥堵的情况。</p><p>然而，由于这种 ICMP 可能会引起不公平的网络通信，一般不被使用。</p><blockquote><p>重定向消息（ICMP Redirect Message） —— 类型 <code>5</code></p></blockquote><p>如果路由器发现发送端主机使用了「不是最优」的路径发送数据，那么它会返回一个 ICMP <strong>重定向消息</strong>给这个主机。</p><p>在这个消息中包含了<strong>最合适的路由信息和源数据</strong>。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息告知发送端，让它下次发给另外一个路由器。</p><p>好比，小林本可以过条马路就能到的地方，但小林不知道，所以绕了一圈才到，后面小林知道后，下次小林就不会那么<strong>傻</strong>再绕一圈了。</p><blockquote><p>超时消息（ICMP Time Exceeded Message） —— 类型 <code>11</code></p></blockquote><p>IP 包中有一个字段叫做 <code>TTL</code> （<code>Time To Live</code>，生存周期），它的<strong>值随着每经过一次路由器就会减 1，直到减到 0 时该 IP 包会被丢弃。</strong></p><p>此时，路由器将会发送一个 ICMP <strong>超时消息</strong>给发送端主机，并通知该包已被丢弃。</p><p>设置 IP 包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免 IP 包无休止地在网络上被转发。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/11.jpg" title="ICMP 时间超过消息">ICMP 时间超过消息</p><p>此外，有时可以用 TTL 控制包的到达范围，例如设置一个<strong>较小的 TTL 值</strong>。</p><hr><h3 id="ping-——-查询报文类型的使用"><a href="#ping-——-查询报文类型的使用" class="headerlink" title="ping —— 查询报文类型的使用"></a>ping —— 查询报文类型的使用</h3><p>接下来，我们重点来看 <code>ping</code> 的<strong>发送和接收过程</strong>。</p><p>同个子网下的主机 A 和 主机 B，主机 A 执行<code>ping</code> 主机 B 后，我们来看看其间发送了什么？</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/12.jpg" title="主机 A ping 主机 B">主机 A ping 主机 B</p><p>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包。</p><p>ICMP 数据包内包含多个字段，最重要的是两个：</p><ul><li>  第一个是<strong>类型</strong>，对于回送请求消息而言该字段为 <code>8</code>；</li><li>  另外一个是<strong>序号</strong>，主要用于区分连续 ping 的时候发出的多个数据包。</li></ul><p>每发出一个请求数据包，序号会自动加 <code>1</code>。为了能够计算往返时间 <code>RTT</code>，它会在报文的数据部分插入发送时间。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/13.jpg" title="主机 A 的 ICMP 回送请求报文">主机 A 的 ICMP 回送请求报文</p><p>然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为<strong>目的地址</strong>，本机 IP 地址作为<strong>源地址</strong>，<strong>协议</strong>字段设置为 <code>1</code> 表示是 <code>ICMP</code> 协议，再加上一些其他控制信息，构建一个 <code>IP</code> 数据包。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/14.jpg" title="主机 A 的 IP 层数据包">主机 A 的 IP 层数据包</p><p>接下来，需要加入 <code>MAC</code> 头。如果在本地 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 <code>ARP</code> 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/15.jpg" title="主机 A 的 MAC 层数据包">主机 A 的 MAC 层数据包</p><p>主机 <code>B</code> 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。</p><p>接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p><p>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去给主机 A。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/16.jpg" title="主机 B 的 ICMP 回送响应报文">主机 B 的 ICMP 回送响应报文</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</p><p>此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p>针对上面发送的事情，总结成了如下图：</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/17.png" title="主机 A ping 主机 B 期间发送的事情">主机 A ping 主机 B 期间发送的事情</p><p>当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。</p><p>但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据目标 IP 地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址。</p><p>说了这么多，可以看出 ping 这个程序是<strong>使用了 ICMP 里面的 ECHO REQUEST（类型为 8 ） 和 ECHO REPLY （类型为 0）</strong>。</p><h3 id="traceroute-——-差错报文类型的使用"><a href="#traceroute-——-差错报文类型的使用" class="headerlink" title="traceroute —— 差错报文类型的使用"></a>traceroute —— 差错报文类型的使用</h3><p>有一款充分利用 ICMP <strong>差错报文类型</strong>的应用叫做 <code>traceroute</code>（在UNIX、MacOS中是这个命令，而在Windows中对等的命令叫做 tracert ）。</p><p><em>1. traceroute 作用一</em></p><p>traceroute 的第一个作用就是<strong>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</strong></p><p>traceroute 的参数指向某个<strong>目的 IP 地址</strong>：</p><pre><code>traceroute 192.168.1.100</code></pre><blockquote><p>这个作用是如何工作的呢？</p></blockquote><p>它的原理就是利用 IP 包的<strong>生存期限</strong> 从 <code>1</code> 开始按照顺序递增的同时发送 <strong>UDP 包</strong>，强制接收 <strong>ICMP 超时消息</strong>的一种方法。</p><p>比如，将 TTL 设置 为 <code>1</code>，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是<strong>时间超时</strong>。</p><p>接下来将 TTL 设置为 <code>2</code>，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。</p><p>这样的过程，traceroute 就可以拿到了所有的路由器 IP。</p><p>当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。</p><blockquote><p>发送方如何知道发出的 UDP 包是否到达了目的主机呢？</p></blockquote><p>traceroute 在发送 <code>UDP</code> 包时，会填入一个<strong>不可能的端口号</strong>值作为 UDP 目标端口号（大于 <code>3000</code> ）。当目的主机，收到 UDP 包后，会返回 ICMP 差错报文消息，但这个差错报文消息的类型是「<strong>端口不可达</strong>」。</p><p>所以，<strong>当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。</strong></p><p><em>2. traceroute 作用二</em></p><p>traceroute 还有一个作用是<strong>故意设置不分片，从而确定路径的 MTU</strong>。</p><blockquote><p>这么做是为了什么？</p></blockquote><p>这样做的目的是为了<strong>路径MTU发现</strong>。</p><p>因为有的时候我们并不知道路由器的 <code>MTU</code> 大小，以太网的数据链路上的 <code>MTU</code> 通常是 <code>1500</code> 字节，但是非以外网的 <code>MTU</code> 值就不一样了，所以我们要知道 <code>MTU</code> 的大小，从而控制发送的包大小。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/18.jpg" title="MTU 路径发现（UDP的情况下）">MTU 路径发现（UDP的情况下）</p><p>它的工作原理如下：</p><p>首先在发送端主机发送 <code>IP</code> 数据报时，将 <code>IP</code> 包首部的<strong>分片禁止标志位设置为 1</strong>。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。</p><p>随后，通过一个 ICMP 的不可达消息将<strong>数据链路上 MTU 的值</strong>一起给发送主机，不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」。</p><p>发送主机端每次收到 ICMP 差错报文时就<strong>减少</strong>包的大小，以此来定位一个合适的 <code>MTU</code> 值，以便能到达目标主机。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ping-的工作原理&quot;&gt;&lt;a href=&quot;#ping-的工作原理&quot; class=&quot;headerlink&quot; title=&quot;ping 的工作原理&quot;&gt;&lt;/a&gt;ping 的工作原理&lt;/h1&gt;&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP/IP" scheme="https://leslieaibin.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://leslieaibin.github.io/2021/12/23/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://leslieaibin.github.io/2021/12/23/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-12-22T16:15:42.000Z</published>
    <updated>2022-02-18T08:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p><p>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p>如何解决：将这些算法封装成一个一个的类，任意地替换。</p><p>关键代码：实现同一个接口。</p><p>应用实例： </p><ul><li><p>诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 </p></li><li><p>旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 </p></li><li><p>JAVA AWT 中的 LayoutManager。</p><p>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p></li></ul><p>使用场景： </p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </li><li>一个系统需要动态地在几种算法中选择一种。 </li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li></ul><p>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><p>实现：</p><p>首先创建一个接口用于运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运算接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有4个实现类分别是加减乘除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationDivision</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 / num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我需要一个类来封装这个接口以及具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());</span><br><span class="line">System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());</span><br><span class="line">System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());</span><br><span class="line">System.out.println(<span class="string">&quot;10 * 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationDivision());</span><br><span class="line">System.out.println(<span class="string">&quot;10 / 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><p>1、知道OO基础，并不足以让你设计出良好的））系统。</p><p>2、良好的OO设计必须具备可复用、可扩充、可维护三个特性。</p><p>3、模式可以让我们建造出具有良好OO设计质量的系统。</p><p>4、模式被认为是历经验证的OO设计经验。</p><p>5、模式不是代码，而是针对设计问题的通用解决方案。你可把它们应该到特定的应用中！</p><p>6、模式不是被发明、而是被发现。</p><p>7、大多数的模式和原则，都着眼于软件变化的主题。</p><p>8、大多数的模式都允许系统局部改变独立于其他部分。</p><p>9、我们常把系统中会变化的部分抽出来封装。</p><p>10、模式让开发人员之间有共享的语言，能够最大化沟通的价值。</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式定义了对象之间的一对多依赖，这样一来当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p><p>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p>何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p><p>如何解决：使用面向对象技术，可以将这种依赖关系弱化。</p><p>关键代码：在抽象类里有一个 ArrayList 存放观察者们。</p><p>应用实例： </p><ul><li><p>拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 </p></li><li><p>西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p><p>优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p><p>缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p></li></ul><p>使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p><p>注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p><p>实现：</p><p>首先创建观察者接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 观察者，所有的观察者都需要实现update方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzf</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer left,Integer right)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">   主题模式接口：</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 主题接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzf</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 用于注册观察者</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 删除观察者</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 当状态更新时这个方法会被调用通知所有观察者</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">      &#125;</span><br><span class="line">      主题实现类，里面存放了一个维护Observer(观察者)的列表：</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 主题的实现类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzf</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationData</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ArrayList&lt;Observer&gt; observersList=<span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">   <span class="keyword">private</span> Integer left;</span><br><span class="line">   <span class="keyword">private</span> Integer right;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   observersList.add(o);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   <span class="keyword">int</span> i=observersList.indexOf(o);</span><br><span class="line">   <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">   observersList.remove(i);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   <span class="keyword">for</span>(Observer o:observersList)</span><br><span class="line">   o.update(left, right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 当状态改变时调用notifyObserver，执行观察者方法</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Changed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      notifyObserver();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">(Integer left,Integer right)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.left=left;</span><br><span class="line">   <span class="keyword">this</span>.right=right;</span><br><span class="line">   Changed();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面实现三个Observer的实现类分别实现加减乘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 观察者实现类并将自身注册入Subject</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @author zzf </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @date 2018年10月17日 上午8:57:05 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer left;</span><br><span class="line">  <span class="keyword">private</span> Integer right;</span><br><span class="line">  <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AddDisplay</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subject=subject;</span><br><span class="line">  subject.registerObserver(<span class="keyword">this</span>);<span class="comment">//将自身注册入主题</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer left, Integer right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">this</span>.left=left;</span><br><span class="line">  <span class="keyword">this</span>.right=right;</span><br><span class="line">  display();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Add:&quot;</span>+(left+right));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @author zzf </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @date 2018年10月17日 上午9:04:19 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubstractDisplay</span>  <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer left;</span><br><span class="line">  <span class="keyword">private</span> Integer right;</span><br><span class="line">  <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubstractDisplay</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subject=subject;</span><br><span class="line">  subject.registerObserver(<span class="keyword">this</span>);<span class="comment">//将自身注册入主题</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer left, Integer right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">this</span>.left=left;</span><br><span class="line">  <span class="keyword">this</span>.right=right;</span><br><span class="line">  display();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Substract:&quot;</span>+(left-right));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *观察者的实现类（乘法）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @author zzf </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @date 2018年10月17日 上午9:11:32 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiplyDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer left;</span><br><span class="line">  <span class="keyword">private</span> Integer right;</span><br><span class="line">  <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MultiplyDisplay</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subject=subject;</span><br><span class="line">  subject.registerObserver(<span class="keyword">this</span>);<span class="comment">//将自身注册入主题</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer left, Integer right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">this</span>.left=left;</span><br><span class="line">  <span class="keyword">this</span>.right=right;</span><br><span class="line">  display();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Multiply:&quot;</span>+(left*right));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面创建一个测试类，将三个观察者的实现类注册入主题模式：</p><ul><li><pre><code class="java">/* * @author zzf * @date 2018年10月17日 上午9:05:48   */  public class Operation &#123;  public static void main(String[] args) &#123;      //创建主题      OperationData operationData=new OperationData();</code></pre></li></ul><pre><code>//将观察者的实现类注册入主题AddDisplay addDisplay=new AddDisplay(operationData);SubstractDisplay substractDisplay=new SubstractDisplay(operationData);MultiplyDisplay multiplyDisplay=new MultiplyDisplay(operationData);operationData.setChanged(5,5);operationData.setChanged(10, 3);&#125;&#125;</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.通过Java API里面的java.util包内自带的Observer接口和Observable类实现观察者模式（详细请阅读源码实现原理很简单）</span><br><span class="line"></span><br><span class="line">首先通过继承java.util.Observable来实现主题的实现类</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">import java.util.Observable;</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line"></span><br><span class="line">* @author zzf </span><br><span class="line"></span><br><span class="line">* @date 2018年10月17日 下午2:26:34 </span><br><span class="line">  *&#x2F;</span><br><span class="line">  public class OperationData extends Observable&#123;</span><br><span class="line"></span><br><span class="line">  private Integer left;</span><br><span class="line">  private Integer right;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line"></span><br><span class="line">   * 当状态改变时调用notifyObserver，执行观察者方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">     public void Changed() &#123;</span><br><span class="line">     setChanged();&#x2F;&#x2F;将changed设置为true</span><br><span class="line">     notifyObservers();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  public void setChanged(Integer left,Integer right) &#123;</span><br><span class="line">  this.left&#x3D;left;</span><br><span class="line">  this.right&#x3D;right;</span><br><span class="line">  Changed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Integer getLeft() &#123;</span><br><span class="line">  return left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setLeft(Integer left) &#123;</span><br><span class="line">  this.left &#x3D; left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Integer getRight() &#123;</span><br><span class="line">  return right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setRight(Integer right) &#123;</span><br><span class="line">  this.right &#x3D; right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过实现java.util.Observer来实现观察类：</p><pre><code>private Integer left;private Integer right;private Observable observable;public MultiplyDisplay(Observable observable) &#123;    this.observable=observable;    observable.addObserver(this);//将自身注册入主题&#125;@Overridepublic void update(Observable o, Object arg) &#123;    // TODO Auto-generated method stub    if(o instanceof OperationData) &#123;        OperationData operationData = (OperationData)o;        this.left=operationData.getLeft();        this.right=operationData.getRight();        display();    &#125;&#125;public void display() &#123;    System.out.println(&quot;Multiply:&quot;+(left*right));&#125;</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @author zzf </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @date 2018年10月17日 下午2:31:37 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer left;</span><br><span class="line">  <span class="keyword">private</span> Integer right;</span><br><span class="line">  <span class="keyword">private</span> Observable observable;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AddDisplay</span><span class="params">(Observable observable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.observable=observable;</span><br><span class="line">  observable.addObserver(<span class="keyword">this</span>);<span class="comment">//将自身注册入主题</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">if</span>(o <span class="keyword">instanceof</span> OperationData) &#123;</span><br><span class="line">  OperationData operationData = (OperationData)o;</span><br><span class="line">  <span class="keyword">this</span>.left=operationData.getLeft();</span><br><span class="line">  <span class="keyword">this</span>.right=operationData.getRight();</span><br><span class="line">  display();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Add:&quot;</span>+(left+right));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><p>1、观察者模式定义了对象之间一对多的关系。</p><p>2、主题（可观察者）用一个共同的接口来更新观察者。</p><p>3、观察者和可观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</p><p>4、使用哦此模式时，你可从被观察者处推或拉数据。</p><p>5、有多个观察者模式时，不可以依赖特定的通知次序。</p><p>6、要注意java.util.Observable实现上带来的一些问题（是一个类非接口，违反了针对接口编程）。</p><p>7、如果有必要，可以实现自己的Observable。</p><p>8、Swing中运用了大量观察者模式，许多GUI框架也是如此。</p><p>参考：<a href="https://www.w3cschool.cn/shejimoshi/strategy-pattern.html">https://www.w3cschool.cn/shejimoshi/strategy-pattern.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h1&gt;&lt;p&gt;策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。&lt;/p&gt;
&lt;p&gt;意图：定</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>海量数据处理</title>
    <link href="https://leslieaibin.github.io/2021/12/19/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2021/12/19/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2021-12-18T16:15:42.000Z</published>
    <updated>2022-02-13T08:08:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="海量数据处理的问题总结"><a href="#海量数据处理的问题总结" class="headerlink" title="海量数据处理的问题总结"></a>海量数据处理的问题总结</h1><p>所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。</p><p>解决办法呢？针对时间，需要采用巧妙的算法配合合适的数据结构，如<code>Bloom filter</code>/<code>Hash</code>/<code>bit-map</code>/<code>堆</code>/<code>数据库</code>或<code>倒排索引</code>/<code>trie</code>树。针对空间，大而化小，分而治之（<code>hash</code>映射可以做到）。</p><p>至于所谓的单机及集群问题，单机就是处理装载数据的机器有限(只要考虑CPU、内存、硬盘间的数据交互)。而集群，机器有多台，适合分布式处理、并行计算(更多考虑节点和节点间的数据交互)。</p><h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p><h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。</p><pre><code>5,000,000,000 * 64B ≈ 5GB * 64 = 320GB</code></pre><p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用分治策略，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p>思路如下：</p><p>首先遍历文件 a，对遍历到的 URL 求<code>hash(URL) % 1000</code>，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p><p>接着遍历<code>ai (i∈[0,999])</code>，把 URL 存储到一个<code>HashSet</code>集合中。然后遍历 bi 中每个 URL，看在<code>HashSet</code>集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p><p>方法总结</p><ul><li>  分而治之，进行哈希取余；</li><li>  对每个子文件进行<code>HashSet</code>统计。</li></ul><h1 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p><h2 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h2><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用分治策略，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p><p>思路如下：</p><p>首先遍历大文件，对遍历到的每个词x，执行<code>hash(x) % 5000</code>，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p><p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用<code>HashMap</code>来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 map.put(x, 1)；若存在，则执行<code>map.put(x, map.get(x) + 1)</code>，将该词频数加 1。</p><p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个小顶堆来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个小顶堆，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为小顶堆，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p><h2 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h2><ul><li>  分而治之，进行哈希取余；</li><li>  使用<code>HashMap</code>统计频数；</li><li>  求解最大的<code>TopN</code>个，用小顶堆；求解最小的<code>TopN</code>个，用大顶堆。</li></ul><h1 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。</p><h2 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h2><p>这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用<code>HashMap</code>统计重复 IP 的次数，最后计算出重复次数最多的 IP。</p><p>注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。</p><h2 id="方法总结-1"><a href="#方法总结-1" class="headerlink" title="方法总结"></a>方法总结</h2><ul><li>  分而治之，进行哈希取余；</li><li>  使用<code>HashMap</code>统计频数；</li><li>  求解最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。</li></ul><h1 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p><h2 id="解答思路-3"><a href="#解答思路-3" class="headerlink" title="解答思路"></a>解答思路</h2><h3 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h3><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用<code>HashSet</code>/<code>HashMap</code>找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p><h3 id="方法二：位图法"><a href="#方法二：位图法" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h3><p>位图，就是用一个或多个<code>bit</code>来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p><p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p><p>假设我们要对 [0,7] 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p><pre><code>0 0 0 0 0 0 0 0</code></pre><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p><pre><code>0 0 0 0 1 0 1 0</code></pre><p>依次遍历，结束后，位数组是这样的：</p><pre><code>0 1 1 0 1 1 1 0</code></pre><p>每个为 1 的位，它的下标都表示了一个数：</p><pre><code>for i in range(8):    if bits[i] == 1:        print(i)</code></pre><p>这样我们其实就已经实现了排序。</p><p>对于整数相关的算法的求解，位图法是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 2^32。</p><p>那么对于这道题，我们用 2 个 bit 来表示各个数字的状态：</p><ul><li>  00 表示这个数字没出现过；</li><li>  01 表示这个数字出现过一次（即为题目所找的不重复整数）；</li><li>  10 表示这个数字出现了多次。</li></ul><p>那么这 2^32 个整数，总共所需内存为 2^32*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p><p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p><h2 id="方法总结-2"><a href="#方法总结-2" class="headerlink" title="方法总结"></a>方法总结</h2><p>判断数字是否重复的问题，位图法是一种非常高效的方法。</p><h1 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 40 亿个不重复的没排过序的<code>unsigned int</code>型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？</p><h2 id="解答思路-4"><a href="#解答思路-4" class="headerlink" title="解答思路"></a>解答思路</h2><h3 id="方法一：分治法-1"><a href="#方法一：分治法-1" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h3><p>依然可以用分治法解决，方法与前面类似，就不再次赘述了。</p><h3 id="方法二：位图法-1"><a href="#方法二：位图法-1" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h3><p>40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b ≈ 512M。</p><p>我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。</p><h2 id="方法总结-3"><a href="#方法总结-3" class="headerlink" title="方法总结"></a>方法总结</h2><p>判断数字是否存在、判断数字是否重复的问题，位图法是一种非常高效的方法。</p><h1 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询床的长度不超过 255 字节。</p><p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p><h2 id="解答思路-5"><a href="#解答思路-5" class="headerlink" title="解答思路"></a>解答思路</h2><p>每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。</p><h3 id="方法一：分治法-2"><a href="#方法一：分治法-2" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h3><p>分治法依然是一个非常实用的方法。</p><p>划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。</p><p>方法可行，但不是最好，下面介绍其他方法。</p><h3 id="方法二：HashMap-法"><a href="#方法二：HashMap-法" class="headerlink" title="方法二：HashMap 法"></a>方法二：HashMap 法</h3><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个<code>HashMap</code>中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。</p><p>思路如下：</p><p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 O(N)。</p><p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p><p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 O(Nlog10)。</p><h3 id="方法三：前缀树法"><a href="#方法三：前缀树法" class="headerlink" title="方法三：前缀树法"></a>方法三：前缀树法</h3><p>方法二使用了<code>HashMap</code>来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p><p>思路如下：</p><p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p><p>最后依然使用小顶堆来对字符串的出现次数进行排序。</p><h2 id="方法总结-4"><a href="#方法总结-4" class="headerlink" title="方法总结"></a>方法总结</h2><p>前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。</p><h1 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。</p><h2 id="解答思路-6"><a href="#解答思路-6" class="headerlink" title="解答思路"></a>解答思路</h2><p>这道题本质还是求解数据重复的问题，对于这类问题，一般首先考虑位图法。</p><p>对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。</p><p>思路如下：</p><p>申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。</p><h2 id="方法总结-5"><a href="#方法总结-5" class="headerlink" title="方法总结"></a>方法总结</h2><p>求解数据重复问题，记得考虑位图法。</p><h1 id="题目8"><a href="#题目8" class="headerlink" title="题目8"></a>题目8</h1><p>题目描述 从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 (N+1)/2 个数；当样本数为偶数时，中位数为 第 N/2 个数与第 1+N/2 个数的均值。</p><h2 id="解答思路-7"><a href="#解答思路-7" class="headerlink" title="解答思路"></a>解答思路</h2><p>如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 O(NlogN)。这里使用其他方法。</p><h3 id="方法一：双堆法"><a href="#方法一：双堆法" class="headerlink" title="方法一：双堆法"></a>方法一：双堆法</h3><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。</p><p>若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。</p><p>以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法适用于数据量较小的情况。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。</p><h3 id="方法二：分治法"><a href="#方法二：分治法" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h3><p>分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。</p><p>对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。</p><p>划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。</p><p>提示，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。 对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。</p><p>注意，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。</p><h2 id="方法总结-6"><a href="#方法总结-6" class="headerlink" title="方法总结"></a>方法总结</h2><p>分治法，真香！</p><h1 id="题目9"><a href="#题目9" class="headerlink" title="题目9"></a>题目9</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。</p><h2 id="解答思路-8"><a href="#解答思路-8" class="headerlink" title="解答思路"></a>解答思路</h2><p>如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。</p><h3 id="方法一：HashMap法"><a href="#方法一：HashMap法" class="headerlink" title="方法一：HashMap法"></a>方法一：<code>HashMap</code>法</h3><p>如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的<code>HashMap</code>中。接着就可以按照 query 出现的次数进行排序。</p><h3 id="方法二：分治法-1"><a href="#方法二：分治法-1" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h3><p>分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 hash(query) % 10 把这些 query 划分到 10 个小文件中。之后对每个小文件使用<code>HashMap</code>统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。</p><p>接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。</p><h2 id="方法总结-7"><a href="#方法总结-7" class="headerlink" title="方法总结"></a>方法总结</h2><ul><li>  内存若够，直接读入进行排序；</li><li>  内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。</li></ul><h1 id="题目10"><a href="#题目10" class="headerlink" title="题目10"></a>题目10</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？</p><h2 id="解答思路-9"><a href="#解答思路-9" class="headerlink" title="解答思路"></a>解答思路</h2><p>对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：</p><p>首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。</p><p>接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。</p><p>重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。</p><p>为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。</p><h2 id="方法总结-8"><a href="#方法总结-8" class="headerlink" title="方法总结"></a>方法总结</h2><p>求 TopK，不妨考虑一下堆排序？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;海量数据处理的问题总结&quot;&gt;&lt;a href=&quot;#海量数据处理的问题总结&quot; class=&quot;headerlink&quot; title=&quot;海量数据处理的问题总结&quot;&gt;&lt;/a&gt;海量数据处理的问题总结&lt;/h1&gt;&lt;p&gt;所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>定位问题</title>
    <link href="https://leslieaibin.github.io/2021/12/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://leslieaibin.github.io/2021/12/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-17T16:15:42.000Z</published>
    <updated>2022-02-13T08:24:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定位问题的先决条件"><a href="#定位问题的先决条件" class="headerlink" title="定位问题的先决条件"></a>定位问题的先决条件</h3><p>需要有详细的日志记录，提前告警的监控平台，事发现场保留</p><blockquote><p>日志 ：业务日志，中间件日志<br>监控 ：CPU、内存、磁盘、网络，类加载、GC、线程等<br>快照 ：-XX:+HeapDumpOnOutOfMemoryError 和 -XX:HeapDumpPath</p></blockquote><h3 id="分析问题，解决问题的思路"><a href="#分析问题，解决问题的思路" class="headerlink" title="分析问题，解决问题的思路"></a>分析问题，解决问题的思路</h3><blockquote><p>经验+直觉，快速定位 &gt; 逐一排查，传输链路 &gt; 寻找规律 不要轻易怀疑监控。考虑资源。优先保证系统能正常运行。保留现场，事后排查定位问题。</p></blockquote><blockquote><p>逐一排查，传输链路，通过日志或工具逐一排查</p><ol><li>内部原因，是否是客户端或者前端问题，程序发布后的Bug，回滚后可以立即解决</li><li>外部原因，比如服务，第三方服务，主机、组件的问题。<ol><li>服务：错误日志邮件提醒或elk快速定位问题，查看gc日志</li><li>第三方服务：单独调用测试，联系第三方加急解决</li><li>主机： CPU相关问题，可以使用 top、vmstat、pidstat、ps 等工具排查； 内存相关问题，可以使用 free、top、ps、vmstat、cachestat、sar 等工具排查；IO 相关问题，可以使用 lsof、iostat、pidstat、sar、iotop、df、du 等工具排查；网络相关问题，可以使用 ifconfig、ip、nslookup、dig、ping、tcpdump、iptables等工具排查。</li><li>组件：查看日志输出，使用命令查看运行情况</li></ol></li><li>因为系统资源不够造成系统假死的问题，通常需要先通过重启和扩容解决问题，之后再进行分析，系统资源不够，一般体现在 CPU 使用高、 内存泄漏或OOM 的问题、IO问题、网络相关问题这四个方面</li></ol></blockquote><h3 id="分析问题的方法"><a href="#分析问题的方法" class="headerlink" title="分析问题的方法"></a>分析问题的方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jps -v 查看java进程</span><br><span class="line">jinfo -flags pid 查看运行参数</span><br><span class="line">jstat -gc 8544 5000 100，将每隔5s采样一次pid为8544的gc，输出100次</span><br><span class="line"></span><br><span class="line">jmap -dump:live,format=b,file=dump.hprof 29170 </span><br><span class="line"><span class="meta">#</span><span class="bash">生成虚拟机的内存转储快照 注意线上可能会触发线上gc</span></span><br><span class="line">jmap -heap 29170</span><br><span class="line">jmap -histo:live 29170 | more</span><br><span class="line">jmap -permstat 29170</span><br><span class="line"></span><br><span class="line">jstack -l 29170 |more 显示虚拟机的线程快照</span><br><span class="line"></span><br><span class="line">df -h # 磁盘 </span><br><span class="line">free -m / -h # 内存</span><br><span class="line">top cpu  # cpu          </span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="线上cpu100-报警（找出最耗时CPU进程-线程-堆栈-代码）"><a href="#线上cpu100-报警（找出最耗时CPU进程-线程-堆栈-代码）" class="headerlink" title="线上cpu100%报警（找出最耗时CPU进程-线程-堆栈-代码）"></a>线上cpu100%报警（找出最耗时CPU进程-线程-堆栈-代码）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">方法1：原生工具，慢</span><br><span class="line">top -c #显示完整信息  P：cpu使用排序 M：内存使用排序</span><br><span class="line">top -Hp 10765 ，#显示一个进程的线程运行信息列表  -H 显示线程信息，-p指定pid &amp; P</span><br><span class="line">printf &quot;%x\n&quot; 10804    转16进制   2f71</span><br><span class="line">jstack 12084 | grep &#x27;0x2f71&#x27; -C5 --color 查看堆栈，找到线程在干嘛</span><br><span class="line"></span><br><span class="line">方法2：</span><br><span class="line">使用提前准备好的sh脚本，可以一条命名查看当前出事的线程代码，快，推荐</span><br><span class="line">sh show-busy-java-threads.sh &gt; a.txt #查询java耗时线程前5个</span><br><span class="line">sh show-busy-java-threads.sh -p &gt; a.txt #查询指定进程</span><br><span class="line"></span><br><span class="line">方法3：</span><br><span class="line">使用arthas，工具内置很多功能，比如可以查看源码，判断是否发布成功，可以用来排查疑难问题</span><br><span class="line">curl -O https://alibaba.github.io/arthas/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br><span class="line">dashboard</span><br><span class="line">thread -8</span><br><span class="line">jad com.xx.xx.xx.xxximp 查看线上类代码</span><br><span class="line">watch com.xx.xx.xx.xxximp doTask &#x27;&#123;params&#125;&#x27; &#x27;#cost&gt;100&#x27; -x 2 </span><br><span class="line"><span class="meta">#</span><span class="bash">观察会慢在什么入参上，监控耗时超过100毫秒的 doTask方法的入参，并且输出入参，展开2层入参参数</span></span><br><span class="line">ognl #查询某静态字段的值</span><br><span class="line"></span><br><span class="line">定位到堆栈就可以定位到出问题代码的行号，然后找对应的发布分支代码该行号即可</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="线上内存OOM"><a href="#线上内存OOM" class="headerlink" title="线上内存OOM"></a>线上内存OOM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">某Java服务（假设PID&#x3D;12084）出现了OOM，最常见的原因为：</span><br><span class="line">1. 有可能是内存分配确实过小，而正常业务使用了大量内存</span><br><span class="line">2. 某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽未调用close()，dispose()释放资源，例如：文件io，网络io</span><br><span class="line">3. 某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程（没有用线程池），不断发起网络连接等</span><br><span class="line">总结：本身资源不够，申请资源太多，资源耗尽</span><br><span class="line"></span><br><span class="line">分析工具：</span><br><span class="line">jvisualvm（直方图），MAT（优先，直方图，跟踪内存使用的引用关系），JProfiler</span><br><span class="line"></span><br><span class="line">线下分析：</span><br><span class="line">服务挂掉之后有保留文件：直接下载dump文件导入mat分析</span><br><span class="line">java -jar -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;</span><br><span class="line"></span><br><span class="line">线上分析：</span><br><span class="line">1. 确认是不是内存本身就分配过小</span><br><span class="line">jmap -heap 12084</span><br><span class="line"></span><br><span class="line">2. 找到最耗内存的对象</span><br><span class="line">jmap -histo:live 12084 | head -n 10  #该命令会强制执行一次fgc</span><br><span class="line"></span><br><span class="line">jmap -dump:format&#x3D;b,file&#x3D;&#x2F;opt&#x2F;dump.hprof &#123;pid&#125; #以二进制输出档当前内存的堆情况，</span><br><span class="line">然后可以导入MAT等工具进行</span><br><span class="line">tar –czf dump.tar.gz dump.hprof</span><br><span class="line"></span><br><span class="line">3. 确认进程创建的线程数，以及网络连接数，如果资源耗尽，也可能出现OOM</span><br><span class="line">ll &#x2F;proc&#x2F;17306&#x2F;fd | wc -l</span><br><span class="line">ll &#x2F;proc&#x2F;17306&#x2F;task | wc -l</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="如何防止线上问题发生"><a href="#如何防止线上问题发生" class="headerlink" title="如何防止线上问题发生"></a>如何防止线上问题发生</h3><blockquote><p>数据库：上线一个定时监控和杀掉慢SQL的脚本。这个脚本每分钟执行一次，检测上一分钟内，有没有执行时间超过一分钟（这个阈值可以根据实际情况调整）的慢SQL，如果有大事务自己觉得该阈值的合理性，如果发现，直接杀掉这个会话</p></blockquote><blockquote><p>cpu或者内存的使用率上做报警，大于90%的时候可以dump和jstack一次，甚至jstat也可以做，然后95%的时候也同样执行一次，甚至98或者99的时候也可以做一次，这样不仅可以保留现场，同时还可以对比</p></blockquote><blockquote><p>完善的服务报错日志监控，可选elfk+日志监控或sentry</p></blockquote><blockquote><p>完善的流程机制。完善的主机，中间件监控报警机制</p></blockquote><h3 id="遇到过的线上问题以及解决思路"><a href="#遇到过的线上问题以及解决思路" class="headerlink" title="遇到过的线上问题以及解决思路"></a>遇到过的线上问题以及解决思路</h3><blockquote><p><a href="https://link.juejin.cn/?target=https://chenyongjun.vip/articles/76">Zuul 网关不响应任何请求，zuul假死</a></p></blockquote><blockquote><p>App打不开，请求超时，访问数据库超时，数据库cpu飙升有规律，在某个时间点才飙升，去调度中心找该时间断的的定时任务，排查是异步转账开多了线程导致的</p></blockquote><h3 id="工具汇总"><a href="#工具汇总" class="headerlink" title="工具汇总"></a>工具汇总</h3><ul><li>去哪儿bistour</li><li>mat 分析堆快照</li><li>arthas <a href="https://link.juejin.cn/?target=https://arthas.aliyun.com/doc/quick-start.html">arthas.aliyun.com/doc/quick-s…</a></li><li><a href="https://link.juejin.cn/?target=https://gceasy.io">gceasy.io</a> #在线gc日志，dump文件分析</li><li><a href="https://link.juejin.cn/?target=https://fastthread.io">fastthread.io</a> #在线gc日志，dump文件分析</li><li><a href="https://link.juejin.cn/?target=https://console.perfma.com">console.perfma.com</a> #在线生成jvm参数</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://link.juejin.cn/?target=https://www.bbsmax.com/A/6pdD7b2X5w/">www.bbsmax.com/A/6pdD7b2X5…</a></li><li><a href="https://link.juejin.cn/?target=https://cloud.tencent.com/developer/article/1600345">cloud.tencent.com/developer/a…</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定位问题的先决条件&quot;&gt;&lt;a href=&quot;#定位问题的先决条件&quot; class=&quot;headerlink&quot; title=&quot;定位问题的先决条件&quot;&gt;&lt;/a&gt;定位问题的先决条件&lt;/h3&gt;&lt;p&gt;需要有详细的日志记录，提前告警的监控平台，事发现场保留&lt;/p&gt;
&lt;blockquot</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>bitMap讲解</title>
    <link href="https://leslieaibin.github.io/2021/12/14/java%E5%9F%BA%E7%A1%80/bitMap%E8%AE%B2%E8%A7%A3/"/>
    <id>https://leslieaibin.github.io/2021/12/14/java%E5%9F%BA%E7%A1%80/bitMap%E8%AE%B2%E8%A7%A3/</id>
    <published>2021-12-14T01:15:42.000Z</published>
    <updated>2021-12-14T14:59:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><ol><li>在实际项目中，我们经常需要聚合统计，比如统计一个年龄在20-30，喜欢看技术书籍，喜欢听音乐，喜欢宅在家的程序员等等一系列标签的用户。 如果使用mysql求并集，首先语句随着标签变长而变长，其次聚合，分组，去重严重影响语句性能。这种情况如何解决？</li><li>比如现在比较火的面试题，在10亿整数中找出100个重复的数，或者任意给定一个整数，判断是否在这个10亿数中。</li></ol><h3 id="bitMap原理"><a href="#bitMap原理" class="headerlink" title="bitMap原理"></a>bitMap原理</h3><p>bitMap就是使用bit位来标记元素，key为该元素，value一般为0或者1，大大节省存储空间.</p><p>现在有(2, 3, 4, 5，7)5个数，任意给定一个在0-7范围内的数字，判断是否在此集合中：</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20211214225035132.png" alt="image-20211214225035132"></p><ul><li><p>创建一个范围为(0-7)的Byte类型数组，将集合数字对应数组的bit位置置1；</p></li><li><p>然后遍历该Byte数组，如果Byte数组位置为1即代表该数存在。</p></li><li><p>同理对于10亿整数也可以这样处理，一个int型数字4个字节，32bit，如果使用bit标记正整数，就可以节省32倍的内存空间。</p></li><li><p>10亿数字，40亿字节，320亿bit，需要大约4g内存，使用bitMap标记，只需要125M内存空间即可存储，大大节省内存空间。</p></li></ul><p>以上和桶排序排序的思想非常相似。</p><h3 id="bitMap实际运用"><a href="#bitMap实际运用" class="headerlink" title="bitMap实际运用"></a>bitMap实际运用</h3><p>对于1千万数据，判断任意给定的数是否在其中？<br> 分治思想<br> 使用int数组作为bitMap。<br> 将数组分成32组，每组内有(0-31)个位置，如果给定数组在指定数组中的bit是0，则不存在。</p><ol><li>求十进制数在对应数组a中的下标<br> a[i] = a[N/32]</li><li>求int[]中bit位置<br> index = a[i] % 32</li></ol><p>上述两个运算可以改成位运算，因为位运算的效率非常高，占用cpu的时钟周期非常少。<br> 结论：对于2的倍数，%2^n = &amp;(2^n-1),模运算等于与预算，例：a % 16 = a &amp; 15,这里的15做与运算时需要化成16进制，即0x0F.</p><p>在10000000个范围为[1-100000]数中，给定指定一个数，判断是否在这个集合中</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMapActual</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1千万数据集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bitmap数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[N/<span class="number">32</span> + <span class="number">1</span>]; <span class="comment">//int 等于32个bit 所以数据长度为(N/32+1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为集合数据加标记</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addValue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定位数组编号 相当于n/32</span></span><br><span class="line">        <span class="keyword">int</span> row = n &gt;&gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定位数组内slot位置 相当于n%32</span></span><br><span class="line">        <span class="keyword">int</span> offset = n &amp; <span class="number">0x1F</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组slot置1</span></span><br><span class="line">        a[row] |= <span class="number">1</span> &lt;&lt; offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断给定数字是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定位数组编号</span></span><br><span class="line">        <span class="keyword">int</span> row = n &gt;&gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定位数组内slot位置</span></span><br><span class="line">        <span class="keyword">int</span> offset = n &amp; <span class="number">0x1F</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 &lt;&lt; position 将a[i]中左移position求与,slot位置有值返回true</span></span><br><span class="line">        <span class="keyword">return</span> (a[row] &amp; ( <span class="number">1</span> &lt;&lt; offset)) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一个长度为N的数组</span></span><br><span class="line">        <span class="keyword">int</span> num[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//随机数范围是(0-100000)</span></span><br><span class="line">            <span class="keyword">int</span> item = random.nextInt(<span class="number">100000</span>);</span><br><span class="line">            num[i] = item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BitMapActual map = <span class="keyword">new</span> BitMapActual();</span><br><span class="line">        <span class="comment">//置1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            map.addValue(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.exits(temp))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;temp:&quot;</span> + temp + <span class="string">&quot;has already exists&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;temp:&quot;</span> + temp + <span class="string">&quot;has no exists&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;小知识&quot;&gt;&lt;a href=&quot;#小知识&quot; class=&quot;headerlink&quot; title=&quot;小知识&quot;&gt;&lt;/a&gt;小知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在实际项目中，我们经常需要聚合统计，比如统计一个年龄在20-30，喜欢看技术书籍，喜欢听音乐，喜欢宅在家的程序员等等一系</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>反射机制</title>
    <link href="https://leslieaibin.github.io/2021/12/12/java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/"/>
    <id>https://leslieaibin.github.io/2021/12/12/java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/</id>
    <published>2021-12-12T01:15:42.000Z</published>
    <updated>2022-02-14T08:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC框架手撕之路—java反射以及动态代理机制"><a href="#RPC框架手撕之路—java反射以及动态代理机制" class="headerlink" title="RPC框架手撕之路—java反射以及动态代理机制"></a>RPC框架手撕之路—java反射以及动态代理机制</h1><p>在上一篇文章中，我们提到了，RPC框架所需要的java基础，第一点就是java的动态代理机制，动态代理机制的基础是反射，无论是在实际编程或者是面试时，都是java知识的重中之重。</p><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>在运行状态中，对于任意一个类，都能够知道这一个类的所有属性和方法，对于任意一个对象都能够通过反射机制调用一个类的任意方法，这种动态获取类信息以及动态调用类方法的功能称为java的反射机制。</p><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>1、动态的创建类的实例，将类绑定到现有对象中，或从现有对象中获取类型。 2、应用程序需要在运行时从某个特定的程序集中载入一个特定的类。</p><p>个人理解的反射机制就是，某些类在程序运行的一开始并没有加载，但是随着程序的运行，我们发现这些类也需要用到，此时就可以通过反射机制，来获取到类的属性和方法。</p><h2 id="代理模式："><a href="#代理模式：" class="headerlink" title="代理模式："></a>代理模式：</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>委托模式，是为某个对象提供一个代理对象，并且由代理对象控制对原对象的访问。代理模式通俗来讲就是我们生活中常见的中介。代理模式可以提供非常好的访问控制，应用比较广泛。</p><p>而其中的代理模式中的动态代理不仅在rpc远程访问中有重要的应用，同样在Spring AOP和其他应用中也起到了很重要的作用。</p><p>代理模式的通用类图：</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-hello-world.oss-cn-beijing.aliyuncs.com/imgs/173d2f9e1a2f5a8f6d0010cb64a7677c.png"></p><p><strong>Subject：</strong> 抽象主题角色：可以是抽象类，也可以是接口。抽象主题是一个普通的业务类型，无特殊要求。</p><p><strong>RealSubject：</strong> 具体主题角色：也叫做被委托角色或被代理角色，是业务逻辑的具体执行者。</p><p><strong>Proxy：</strong> 代理主题角色：也叫做委托类或代理类。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后处理工作。</p><p>按照代理创建的时期来进行分类，可以分为动态代理和静态代理。</p><h3 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h3><p>一个代理类只能实现一种抽象主题角色，在程序运行之前，代理类.class文件就已经被创建，代理类和委托类的关系在运行前就确定。</p><h3 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h3><p>一个代理类通过反射机制，可以实现多种不类型的抽象主题角色。动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。以下为动态代理概括图： <img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-hello-world.oss-cn-beijing.aliyuncs.com/imgs/cb919ba78df42f8a74cbc96a317ed2d1.png"></p><p>实现代码块如下：</p><p><strong>抽象角色类实现</strong>(动态代理的抽象决策类只能使用接口)：</p><pre><code>public interface Subject &#123;    /**     * 接口方法，抽象主题类     */    public void request();&#125;</code></pre><p><strong>具体决策类实现：</strong></p><pre><code>public class ConcreteSubject implements Subject&#123;    /**     * 具体业务实现逻辑     */    @Override    public void request() &#123;        //业务处理逻辑        System.out.println(&quot;逻辑执行&quot;);    &#125;&#125;</code></pre><p><strong>动态创建代理对象的类</strong>(代理类，使用反射机制):</p><pre><code>import lombok.extern.slf4j.Slf4j;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;</code></pre><p>​<br>    public class ProxyHandler implements InvocationHandler {<br>        /**<br>         *<br>         * @param proxy<br>         * @param method<br>         * @param args<br>         * @return<br>         * @throws Throwable<br>         */</p><pre><code>    /**     *目标对象     */    private Object target;    /**     */    public Object newProxyInstance(Object target)&#123;       this.target = target;       Object result = Proxy.newProxyInstance(target.getClass().getClassLoader(),               target.getClass().getInterfaces(),this);       return result;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        //TODO原对象方法调用添加的预处理逻辑        Object ret = null;        try&#123;            //调用目标方法            ret = method.invoke(target, args);        &#125;catch (Exception e)&#123;            //log(&quot;调用&#123;&#125;.&#123;&#125;发生异常&quot;, target.getClass().getName(), method.getName(), e);            throw e;        &#125;        return ret;    &#125;&#125;</code></pre><p><strong>客户端类</strong>：</p><pre><code>import lombok.extern.slf4j.Slf4j;import java.util.logging.Logger;</code></pre><p>​<br>    public class Client {<br>        public static void main(String[] args){<br>            System.out.println(“开始”);<br>            ProxyHandler handler = new ProxyHandler();<br>            Subject subject = (Subject) handler.newProxyInstance(new ConcreteSubject());<br>            subject.request();<br>            System.out.println(“结束”);<br>        }<br>    }</p><p>运行结果： <img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-hello-world.oss-cn-beijing.aliyuncs.com/imgs/943b059667471fd616a3c403f1f574b0.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RPC框架手撕之路—java反射以及动态代理机制&quot;&gt;&lt;a href=&quot;#RPC框架手撕之路—java反射以及动态代理机制&quot; class=&quot;headerlink&quot; title=&quot;RPC框架手撕之路—java反射以及动态代理机制&quot;&gt;&lt;/a&gt;RPC框架手撕之路—java</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis缓存与数据库一致性问题</title>
    <link href="https://leslieaibin.github.io/2021/11/30/Redis/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%20Redis%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/"/>
    <id>https://leslieaibin.github.io/2021/11/30/Redis/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%20Redis%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/</id>
    <published>2021-11-30T01:15:42.000Z</published>
    <updated>2021-12-08T15:17:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做系统优化时，想到了将数据进行分级存储的思路。因为在系统中会存在一些数据，有些数据的实时性要求不高，比如一些配置信息。</p><p>基本上配置了很久才会变一次。而有一些数据实时性要求非常高，比如订单和流水的数据。所以这里根据数据要求实时性不同将数据分为三级。</p><ul><li>第1级：订单数据和支付流水数据；这两块数据对实时性和精确性要求很高，所以不添加任何缓存，读写操作将直接操作数据库。</li><li>第2级：用户相关数据；这些数据和用户相关，具有读多写少的特征，所以我们使用redis进行缓存。</li><li>第3级：支付配置信息；这些数据和用户无关，具有数据量小，频繁读，几乎不修改的特征，所以我们使用本地内存进行缓存。</li></ul><p>但是只要使用到缓存，无论是本地内存做缓存还是使用 redis 做缓存，那么就会存在数据同步的问题，因为配置信息缓存在内存中，而内存时无法感知到数据在数据库的修改。这样就会造成数据库中的数据与缓存中数据不一致的问题。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>那么我们这里列出来所有策略，并且讨论他们优劣性。</p><ul><li><p>先更新数据库，后更新缓存</p></li><li><p>先更新数据库，后删除缓存</p></li><li><p>先更新缓存，后更新数据库</p></li><li><p>先删除缓存，后更新数据库</p></li></ul><h4 id="先更新数据库，后更新缓存"><a href="#先更新数据库，后更新缓存" class="headerlink" title="先更新数据库，后更新缓存"></a>先更新数据库，后更新缓存</h4><p>这种场景一般是没有人使用的，主要原因是在更新缓存那一步，为什么呢？因为有的业务需求缓存中存在的值并不是直接从数据库中查出来的，有的是需要经过一系列计算来的缓存值，那么这时候后你要更新缓存的话其实代价是很高的。如果此时有大量的对数据库进行写数据的请求，但是读请求并不多，那么此时如果每次写请求都更新一下缓存，那么性能损耗是非常大的。</p><p>举个例子比如在数据库中有一个值为 1 的值，此时我们有 10 个请求对其每次加一的操作，但是这期间并没有读操作进来，如果用了先更新数据库的办法，那么此时就会有十个请求对缓存进行更新，会有大量的冷数据产生，如果我们不更新缓存而是删除缓存，那么在有读请求来的时候那么就会只更新缓存一次。</p><h4 id="先更新缓存，后更新数据库"><a href="#先更新缓存，后更新数据库" class="headerlink" title="先更新缓存，后更新数据库"></a>先更新缓存，后更新数据库</h4><p>这一种情况应该不需要我们考虑了吧，和第一种情况是一样的。</p><h4 id="先删除缓存，后更新数据库"><a href="#先删除缓存，后更新数据库" class="headerlink" title="先删除缓存，后更新数据库"></a>先删除缓存，后更新数据库</h4><p>该方案也会出问题，具体出现的原因如下。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078252.png" alt="先删除缓存，后更新数据库"></p><p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p><ol><li>请求 A 会先删除 Redis 中的数据，然后去数据库进行更新操作</li><li>此时请求 B 看到 Redis 中的数据时空的，会去数据库中查询该值，补录到 Redis 中</li><li>但是此时请求 A 并没有更新成功，或者事务还未提交</li></ol><p>那么这时候就会产生数据库和 Redis 数据不一致的问题。如何解决呢？其实最简单的解决办法就是延时双删的策略。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078256.png" alt="延时双删"></p><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。具体步骤是：</p><ul><li>先删除缓存</li><li>再写数据库</li><li>休眠500毫秒（根据具体的业务时间来定）</li><li>再次删除缓存。</li></ul><p>但是上述的保证事务提交完以后再进行删除缓存还有一个问题，就是如果你使用的是 Mysql 的读写分离的架构的话，那么其实主从同步之间也会有时间差。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078251.png" alt="主从同步时间差"></p><p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p><ol><li>请求 A 更新操作，删除了 Redis</li><li>请求主库进行更新操作，主库与从库进行同步数据的操作</li><li>请 B 查询操作，发现 Redis 中没有数据</li><li>去从库中拿去数据</li><li>此时同步数据还未完成，拿到的数据是旧数据</li></ol><p>此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078255.png" alt="从主库中拿数据"></p><h4 id="先更新数据库，后删除缓存"><a href="#先更新数据库，后删除缓存" class="headerlink" title="先更新数据库，后删除缓存"></a>先更新数据库，后删除缓存</h4><p>问题：这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078254.png" alt="先更新数据库，后删除缓存"></p><p>此时解决方案就是利用消息队列进行删除的补偿。具体的业务逻辑用语言描述如下：</p><ol><li>请求 A 先对数据库进行更新操作</li><li>在对 Redis 进行删除操作的时候发现报错，删除失败</li><li>此时将Redis 的 key 作为消息体发送到消息队列中</li><li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</li></ol><p>但是这个方案会有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078253.png" alt="利用订阅 binlog 删除缓存"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每种方案各有利弊，比如在第三种先删除缓存，后更新数据库这个方案我们最后讨论了要更新 Redis 的时候强制走主库查询就能解决问题，那么这样的操作会对业务代码进行大量的侵入，但是不需要增加的系统，不需要增加整体的服务的复杂度。</p><p>最后一种方案我们最后讨论了利用订阅 binlog 日志进行搭建独立系统操作 Redis，这样的缺点其实就是增加了系统复杂度。其实每一次的选择都需要我们对于我们的业务进行评估来选择，没有一种技术是对于所有业务都通用的。没有最好的，只有最适合我们的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在做系统优化时，想到了将数据进行分级存储的思路。因为在系统中会存在一些数据，有些数据的实时性要求不高，比如一些配置信息。&lt;/p&gt;
&lt;p&gt;基本上配置了很久才会变一次。而有一些数据实时性要求非常高，比如订单和流水的数据。所以这里根据数据要求实时性不同将数据分为三级。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>超卖问题</title>
    <link href="https://leslieaibin.github.io/2021/11/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E8%B6%85%E5%8D%96%E8%AE%A8%E8%AE%BA/"/>
    <id>https://leslieaibin.github.io/2021/11/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E8%B6%85%E5%8D%96%E8%AE%A8%E8%AE%BA/</id>
    <published>2021-11-17T16:15:42.000Z</published>
    <updated>2022-02-12T12:29:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见写法安全性及效率分析"><a href="#常见写法安全性及效率分析" class="headerlink" title="常见写法安全性及效率分析"></a>常见写法安全性及效率分析</h1><p>假设我们的商品表的schema是下面这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`goods`</span> (<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span><span class="string">``</span><span class="string">` `</span><span class="string">&#x27;自增id&#x27;</span><span class="string">``</span>,<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span><span class="string">``</span><span class="string">` `</span><span class="string">&#x27;&#x27;</span><span class="string">` `</span><span class="keyword">COMMENT</span><span class="string">` `</span><span class="string">&#x27;商品名称&#x27;</span><span class="string">``</span>,<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="string">`available`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span><span class="string">``</span><span class="string">` `</span><span class="string">&#x27;0&#x27;</span><span class="string">` `</span><span class="keyword">COMMENT</span><span class="string">` `</span><span class="string">&#x27;库存剩余量&#x27;</span><span class="string">``</span>,<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="string">`stock`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span><span class="string">``</span><span class="string">` `</span><span class="string">&#x27;0&#x27;</span><span class="string">` `</span><span class="keyword">COMMENT</span><span class="string">` `</span><span class="string">&#x27;总库存量&#x27;</span><span class="string">``</span>,<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">``</span><span class="string">&#x27;商品表&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="设置为字段无符号解决"><a href="#设置为字段无符号解决" class="headerlink" title="设置为字段无符号解决"></a>设置为字段无符号解决</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="keyword">select</span> available <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line">if(num &gt; 0)&#123;</span><br><span class="line">   affectRows = udpate goods <span class="keyword">set</span> available = available - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line">   if(affectRows == 1)&#123;</span><br><span class="line">       return ok ;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       return fatal ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这种做法大家的想法是我们将库存字段设置成无符号类型，这样当库存字段在sql执行时候被置为负数的时候mysql就会报错，那么affectRow就会是0或者可以捕获到这个异常，从而实现并发下的数据安全。</strong></p><h4 id="解法释义"><a href="#解法释义" class="headerlink" title="解法释义"></a>解法释义</h4><p>实际上这段代码是危险的，因为在不同版本的mysql和配置下，这段代码的表现完全不同。具体的情况会出现3种不同的结果：</p><ul><li>  代码正常运行，执行update的时候报错</li><li>  代码最终执行结果出现了 -1</li><li>  最终update操作之后，available变成了一个很大的数目</li></ul><p>为什么会出现这三种情况呢？</p><p>我想在学习开始学习计算机的时候都讲过计算机的加减法计算方法。</p><p><code>思考一下，无符号2 减去 无符号3 在计算机中的运算是什么样的？</code></p><p><code>2 - 3 = 2 + (-3)</code></p><p><code>假设我们的计算机是4位的,2的补码表示:0010,-3的补码表示为1011</code></p><p><code>那么加和的结果是</code></p><p><code>0010</code></p><p><code>1011 +</code></p><p><code>------</code></p><p><code>1111 =</code></p><p><code>1111解释为有符号数是多少呢？ -1</code></p><p><code>1111解释为无符号数是多少呢？ 15</code></p><p>所以呢？如果mysql不做任何处理的话，你的无符号数减法的结果不会报错，最终你算出来的库存还是一个非常大的值(可怕)。<br>但是幸运的是mysql 后来的版本帮你做了这件事情(具体哪个版本我也不清楚)，所以如果是mysql做了无符号检测的话，如果减出的结果是负值，会报错，这是大多数人期待的结果。-1这种情况是需要你设置一下sqlmode的，这也是会出现的情况。</p><h4 id="解法总结"><a href="#解法总结" class="headerlink" title="解法总结"></a>解法总结</h4><ul><li>  这个办法很多人用的时候没问题，那只能说明可能是机缘巧合，但是对于业务代码而言，不能靠碰运气，需要消除不确定性、缩小迁移成本。</li><li>  如果你想采用这种办法，辛苦你把你们msyql相应的版本及配置搞清楚，确定无符号在你所在的版本会出现什么结果。</li></ul><h2 id="select-for-update（感觉并不能保证原子性）"><a href="#select-for-update（感觉并不能保证原子性）" class="headerlink" title="select for update（感觉并不能保证原子性）"></a>select for update（感觉并不能保证原子性）</h2><h4 id="解法释义-1"><a href="#解法释义-1" class="headerlink" title="解法释义"></a>解法释义</h4><p>读取时候就开始加排他锁也是网上常见的办法之一，具体实现如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran ;</span><br><span class="line">num = <span class="keyword">select</span> avaliable <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xxx <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">if (num &gt;= 0)&#123;</span><br><span class="line">   affectNum = udpate goods <span class="keyword">set</span> available = available - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line">   <span class="keyword">commit</span> ;</span><br><span class="line"> return affectNum ;</span><br><span class="line">&#125;else&#123;</span><br><span class="line"> <span class="keyword">rollback</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该解法在用户读取的时候对相应的数据加排他锁，保证自己在更新的时候该行的数据不会被别的进程更改.所有写请求及排他锁加锁都会被阻塞。</p><p>想想这样的情况，A进程执行过程中，出现死机的情况导致commit/rollback请求没有被发送到mysqlserver，那么所有请求都会锁等待。</p><h4 id="解法总结-1"><a href="#解法总结-1" class="headerlink" title="解法总结"></a>解法总结</h4><ul><li><p>  低流量可以采用这种办法来保证数据的安全性</p></li><li><p>性能低下，平均需要发送4次mysql请求，同时会造成所有同类请求锁等待。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3></li><li><p>  select for udpate 需要在显式的指定在事务代码块执行，不然不会起作用。很多网友都理所当然的人为select for update直接就可以加排他锁</p></li><li><p>  排他锁的释放是在rollback/commit 动作完成才会释放，不是在update操作之后。mysql innodb执行两段锁协议，加锁阶段只加锁，解锁阶段只解锁。</p></li></ul><h2 id="采用事务，先查后写再查，确保没问题"><a href="#采用事务，先查后写再查，确保没问题" class="headerlink" title="采用事务，先查后写再查，确保没问题"></a>采用事务，先查后写再查，确保没问题</h2><h4 id="解法释义-2"><a href="#解法释义-2" class="headerlink" title="解法释义"></a>解法释义</h4><p>这时候的available设置为有符号类型，解决方案一的问题</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran ;</span><br><span class="line"></span><br><span class="line">num = <span class="keyword">select</span> available <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line"></span><br><span class="line">if(num &gt; 0)&#123;</span><br><span class="line">   //实际需要关心这里的返回值，这里不考虑</span><br><span class="line"></span><br><span class="line">   udpate goods <span class="keyword">set</span> available = available - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line"></span><br><span class="line">   num_afterupdate = <span class="keyword">select</span> available <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line"></span><br><span class="line">   if(num_afterupdate &lt; 0 )&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">rollback</span> ;</span><br><span class="line"></span><br><span class="line">   &#125;else&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">commit</span> ;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解法区分于第一种的办法在于，加了事务、available类型更改、采用了更新后确认的形式，尝试解决问题。</p><p>我们都知道数据库的事务隔离级别有4种：<br><strong>RU，RC，RR，Serializable。</strong><br>我们常见的innodb中RR模式是可以保证可重复读，意思是在同一个事务内部，多次读取的结果是一致的。那么最后一次的读取对于RR隔离级别实际上是无效的。<br>RC模式下，这个代码是可用的，每次请求可以确保自己的进程不会超发。</p><h4 id="解法总结-2"><a href="#解法总结-2" class="headerlink" title="解法总结"></a>解法总结</h4><ul><li>  RR、RC模式下结果不一致.RR下不可保证安全、RC可以。</li><li>  性能不高，一次业务请求到mysql的转化为 1 : 5。</li><li>  这种解法就像老奶奶锁门，总是不放心自己到底锁了没有，走了几步再回来看看，实际上有些时候是徒劳。</li></ul><h2 id="update语句增加available查询条件"><a href="#update语句增加available查询条件" class="headerlink" title="update语句增加available查询条件"></a>update语句增加available查询条件</h2><h4 id="解法释义-3"><a href="#解法释义-3" class="headerlink" title="解法释义"></a>解法释义</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udpate goods <span class="keyword">set</span> available = available - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = xx<span class="string">` `</span><span class="keyword">and</span><span class="string">` `</span>available - <span class="number">1</span> &gt;= <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p>大家有的另一个误区是单条语句不是事务，实际上单条sql也是一个事务。-<br>问题的关键就集中在怎么证明这句的安全性的。-<br>我们都知道update操作对于id为主键索引的情况下，是会对数据加行锁。-<br>其实update操作在mysql内部也是一个先查后改的过程，这个过程如果是原子的，那么可以保证update语句是串行的，那我们就来看一下update语句在mysql内部的执行过程。-</p><p>那么对于上面这个语句，一样遵循两段锁协议。-<br>update执行的过程，会去查询满足条件的行并加锁，这个加锁是innodb做的，那么就可以保证别的事务必须等到该事务执行完了之后才能获得锁，此时拿到最新数据。</p><h4 id="解法总结-3"><a href="#解法总结-3" class="headerlink" title="解法总结"></a>解法总结</h4><ul><li>  语句安全、效率最优（我的认知里）</li></ul><h2 id="采用设置库存而不是扣减库存"><a href="#采用设置库存而不是扣减库存" class="headerlink" title="采用设置库存而不是扣减库存"></a>采用设置库存而不是扣减库存</h2><p>这几天我把类似的文章几乎翻了一遍，唯一看到批评我的上一条做法的是我的那个做法是不具备幂等性的。</p><blockquote><ul><li>  所谓幂等性就是，同一个用户对同一连接的访问不会产生副作用。比如上一条的方案，如果记录用户的操作和扣减库存不是原子操作的话，就有可能出现的问题是，库存扣减成功了，但是用户记录失败了，那么用户重复请求，就会出现多次减库存的问题。</li></ul></blockquote><p>那么他们的解法是这样的，采用设置而不是扣减，代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num_old = <span class="keyword">select</span> available <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xx<span class="string">` `</span><span class="keyword">and</span><span class="string">` `</span>available &gt;= <span class="number">1</span> ;</span><br><span class="line">num_new = num_old - 1 ;</span><br><span class="line"><span class="keyword">update</span> goods <span class="keyword">set</span> <span class="keyword">num</span>=num_new <span class="keyword">where</span> <span class="keyword">id</span>=xx<span class="string">` `</span><span class="keyword">and</span><span class="string">` `</span><span class="keyword">num</span>=num_old ;</span><br></pre></td></tr></table></figure><p>这段代码也是安全的，采用的是乐观锁的理念来完成的操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>  上面的做法，最后两个是相对安全的，但是你的库存字段还是要设置为无符号，关于是否幂等，要看结合请求看，不是单个扣减块代码。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>  <a href="http://hedengcheng.com/?p=771">何登成的技术博客</a>mysql udpate流程学习</li><li>  <a href="http://www.10tiao.com/html/249/201706/2651960197/1.html">幂等性做法来源</a>使用设置库存代替库存扣减</li><li>  <a href="http://www.cnblogs.com/blankqdb/archive/2012/11/03/blank_qdb.html">mysql 无符号问题</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见写法安全性及效率分析&quot;&gt;&lt;a href=&quot;#常见写法安全性及效率分析&quot; class=&quot;headerlink&quot; title=&quot;常见写法安全性及效率分析&quot;&gt;&lt;/a&gt;常见写法安全性及效率分析&lt;/h1&gt;&lt;p&gt;假设我们的商品表的schema是下面这样的：&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>消息队列幂等性</title>
    <link href="https://leslieaibin.github.io/2021/11/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%8E%E6%A0%B7%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>https://leslieaibin.github.io/2021/11/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%8E%E6%A0%B7%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7/</id>
    <published>2021-11-12T01:15:42.000Z</published>
    <updated>2022-02-13T10:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ消费幂等性"><a href="#RabbitMQ消费幂等性" class="headerlink" title="RabbitMQ消费幂等性"></a>RabbitMQ消费幂等性</h2><h3 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h3><blockquote><p>幂等性，简单来说就是<strong>对于同一个系统，在同样条件下，一次请求和重复多次请求对资源的影响是一致的，就称该操作为幂等的</strong>。比如说如果有一个接口是幂等的，当传入相同条件时，其效果必须是相同的。在RabbitMQ中消费幂等就是指给消费者发送多条同样的消息，消费者只会消费其中的一条。例如，在一次购物中提交订单进行支付时，当网络延迟等其他问题造成消费者重新支付，如果没有幂等性的支持，那么会对同一订单进行两次扣款，这是非常严重的，因此有了幂等性，当对同一个订单进行多次支付时，可以确保只对同一个订单扣款一次。</p></blockquote><h3 id="RabbitMQ消费幂等性-1"><a href="#RabbitMQ消费幂等性-1" class="headerlink" title="RabbitMQ消费幂等性"></a>RabbitMQ消费幂等性</h3><p>在正常情况下，消费者在消费消息的时候，当消费完毕后，会发送一个确认ack给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。而在前面保证生产端消息可靠性投递方案1中，当生产者发送消息给RabbitMQ后，在Broker返回确认ack之前，RabbitMQ出现了宕机（数据库保存的消息状态仍然为<code>“投递中”</code>），则该消息会被定时任务抓取并重新发送；或者当在网络延迟传输中，消费者出现异常或者消费者延迟消费，会造成进行RabbitMQ重试补偿，那么此时RabbitMQ中就可能会有两条消息，会造成消费者重复消费，此时消费端就需要做幂等性校验，让消费者只消费其中一条消息。实现消费端幂等性、保证同一消息不被重复消费下面介绍一种简单的方案。</p><ul><li><p>为了保证消息不被重复消费，首先要保证每个消息是唯一的，所以可以给每一个消息携带一个唯一的id，流程如下：</p><p>  1、消费者监听到消息后获取消息的MsgId（这个MsgId是我们自定义消息的字段，是主键），先去Redis中查询这个MsgId是否存在。也可以生产者发送消息时指给消息对象设置唯一的 MessageID，只有该 MessageID 没有被消费者存入到Redis中即该消息未被消费，这样重发的消息才能在重试机制中再次被消费。</p><p>  2、如果不存在，则正常消费消息，并把消息的id存入Redis中。</p><p>  3、如果存在则丢弃或者拒绝此消息并不返回队列。</p></li><li><p>代码：</p><p>  1.消费者</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessageFromQueue1</span><span class="params">(Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SetOperations&lt;String, Object&gt; ops = redisTemplate.opsForSet();</span><br><span class="line">    <span class="comment">//获取唯一Id</span></span><br><span class="line">    String msgID = message.getMessageProperties().getHeader(</span><br><span class="line">            <span class="string">&quot;spring_returned_message_correlation&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ops.pop(msgID)!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//该订单已经完成扣款，无需再进行扣款</span></span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行扣款操作</span></span><br><span class="line">        ..</span><br><span class="line">        ..</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将对应的订单id保存到redis中         </span></span><br><span class="line">        ops.add(msgID,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回确认ack</span></span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      </span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="消息队列如何限流？"><a href="#消息队列如何限流？" class="headerlink" title="消息队列如何限流？"></a>消息队列如何限流？</h2><p>消息队列限流是指在服务器面临巨额流量时，为了进行自保，进行的一种救急措施。</p><p>因为巨大的流量代表着非常多的消息，这些消息如果多到服务器处理不过来就会造成服务器瘫痪，影响用户体验，造成不良影响。</p><p>所以要进行一次降级操作，把处理不了的流量隔绝在系统之外，避免它们打垮系统。</p><p>基本上任何一个消息队列都有限流的功能，今天我们就来看看在<code>RabbitMQ</code>之中进行限流具体应该怎么做？</p><p>RabbitMQ提供了一种<code>QOS</code>(服务质量保证)功能，即在非自动确认消息的前提下，如果一定数目的消息还未被消费确认，则不进行新消息的消费。</p><h2 id="TTL消息-队列"><a href="#TTL消息-队列" class="headerlink" title="TTL消息/队列"></a>TTL消息/队列</h2><p><code>TTL</code>是Time To Live的缩写，也就是生存时间的意思，<code>RabbitMQ</code>支持消息的过期时间，在消息发送时可以进行指定，也支持队列的过期时间，从消息入队列开始计算，只要超过了队列的超时时间配置，那么消息会自动的清除。</p><p>设置队列的话就是整个队列的消息到时都会过期，设置消息的话就是单条消息到时自动过期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TTL队列示例</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">ttlQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置3s过期</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topicQueue1&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码就是演示如何创建一个TTL队列，需要放入参数才行，队列构造中的其他参数我为了方便直接填了false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTtl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String message = <span class="string">&quot;Hello 我是作者和耳朵，欢迎关注我。&quot;</span> + LocalDateTime.now().toString();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Message content : &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置过期3s</span></span><br><span class="line">    MessageProperties props = MessagePropertiesBuilder.newInstance()</span><br><span class="line">            .setExpiration(<span class="string">&quot;3000&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.send(Producer.QUEUE_NAME,<span class="keyword">new</span> Message(message.getBytes(StandardCharsets.UTF_8),props));</span><br><span class="line">    System.out.println(<span class="string">&quot;消息发送完毕。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="DLX死信队列"><a href="#DLX死信队列" class="headerlink" title="DLX死信队列"></a>DLX死信队列</h2><p><code>DLX死信队列</code>虽然叫队列，但其实指的是<code>Exchange</code>，或者说指的<code>Exchange</code>和它所属的<code>Queue</code>，他俩一块构成了死信队列。</p><p>当一条消息：</p><ul><li>消费被拒绝（basic.reject/basic.nack）并且requeue=false</li><li>TTL过期</li><li>要进入的队列达到最大长度</li></ul><p>这三种情况，就可以判定一条消息死了，这种消息如果我们没有做处理，它就会被自动删除。</p><p>但其实我们可以在队列上加上一个参数，使当队列中发现了<code>死亡的消息</code>之后会将它自动转发到某个<code>Exchange</code>，由指定的<code>Exchange</code>来处理这些死亡的消息。</p><p>这个处理死亡消息的<code>Exchange</code>和之前我们讲述的<code>Exchange</code>没什么区别，依然可以绑定队列然后进行消息消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DLX队列示例</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">dlxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 指定消息死亡后发送到ExchangeName=&quot;dlx.exchange&quot;的交换机去</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,<span class="string">&quot;dlx.exchange&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topicQueue1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上代码，就是设置了一个队列中的消息死亡后的去处，就等于消息死亡后给它不把它删掉而是做一次转发，发到其他<code>Exchange</code>去。</p><p>那这样搞有什么用呢？这就取决于业务需求了，不过下一节会用到它，接着往下看~</p><h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2><p><code>RabbitMQ</code>的基因中没有延时队列这回事，它不能直接指定一个队列类型为延时队列，然后去延时处理，但是经过上面两节的铺垫，我们可以将TTL+DLX相结合，这就能组成一个延时队列。</p><p>设想一个场景，下完订单之后15分钟未付款我们就要将订单关闭，这就是一个很经典的演示消费的场景，如果拿<code>RabbitMQ</code>来做，我们就需要结合TTL+DLX了。</p><p>先把订单消息设置好15分钟过期时间，然后过期后队列将消息转发给我们设置好的<code>DLX-Exchange</code>，<code>DLX-Exchange</code>再将分发给它绑定的队列，我们的消费者再消费这个队列中的消息，就做到了延时十五分钟消费。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RabbitMQ消费幂等性&quot;&gt;&lt;a href=&quot;#RabbitMQ消费幂等性&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ消费幂等性&quot;&gt;&lt;/a&gt;RabbitMQ消费幂等性&lt;/h2&gt;&lt;h3 id=&quot;什么是幂等性&quot;&gt;&lt;a href=&quot;#什么是</summary>
      
    
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>消息队列问题</title>
    <link href="https://leslieaibin.github.io/2021/11/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%A4%AA%E5%A4%9A%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>https://leslieaibin.github.io/2021/11/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%A4%AA%E5%A4%9A%E6%80%8E%E4%B9%88%E5%8A%9E/</id>
    <published>2021-11-11T01:15:42.000Z</published>
    <updated>2022-02-13T02:03:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MQ-的问题"><a href="#MQ-的问题" class="headerlink" title="MQ 的问题"></a>MQ 的问题</h2><p>任何技术都会有利有弊，MQ 给整体系统架构带来很多好处，但也会付出一定的代价。</p><p>MQ 主要引入了以下问题：</p><ul><li><p><strong>系统可用性降低</strong>：引入了 MQ 后，通信需要基于 MQ 完成，如果 MQ 宕机，则服务不可用。</p></li><li><p>系统复杂度提高</p><p>使用 MQ，需要关注一些新的问题：</p><ul><li>如何保证消息没有 <strong>重复消费</strong>？</li><li>如何处理 <strong>消息丢失</strong> 的问题？</li><li>如何保证传递 <strong>消息的顺序性</strong>？</li><li>如何处理大量 <strong>消息积压</strong> 的问题？</li></ul></li><li><p><strong>一致性问题</strong>：假设系统 A 处理完直接返回成功的结果给用户，用户认为请求成功。但如果此时，系统 BCD 中只要有任意一个写库失败，那么数据就不一致了。这种情况如何处理？</p></li></ul><p>下面，我们针对以上问题来一一分析。</p><h3 id="1-重复消费"><a href="#1-重复消费" class="headerlink" title="1. 重复消费"></a>1. 重复消费</h3><p><strong>如何保证消息不被重复消费</strong> 和 <strong>如何保证消息消费的幂等性</strong> 是同一个问题。</p><p>必须先明确产生重复消费的原因，才能对症下药。</p><h4 id="重复消费问题原因"><a href="#重复消费问题原因" class="headerlink" title="重复消费问题原因"></a>重复消费问题原因</h4><p>重复消费问题通常不是 MQ 来处理，而是由开发来处理的。</p><p>以 Kafka 举例，Kafka 每个 Partition 都是一个有序的、不可变的记录序列，不断追加到结构化的提交日志中。Partition 中为每条记录分配一个连续的 id 号，称为偏移量（Offset），用于唯一标识 Partition 内的记录。</p><p>Kafka 的客户端和 Broker 都会保存 Offset。客户端消费消息后，每隔一段时间，就把已消费的 Offset 提交给 Kafka Broker，表示已消费。</p><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210427194009.png" alt="img"></p><p>在这个过程中，如果客户端应用消费消息后，因为宕机、重启等情况而没有提交已消费的 Offset 。当系统恢复后，会继续消费消息，由于 Offset 未提交，就会出现重复消费的问题。</p><h4 id="重复消费解决方案"><a href="#重复消费解决方案" class="headerlink" title="重复消费解决方案"></a>重复消费解决方案</h4><p>应对重复消费问题，需要在业务层面，通过 <strong>幂等性设计</strong> 来解决。</p><p>MQ 重复消费不可怕，可怕的是没有应对机制，可以借鉴的思路有：</p><ul><li>如果是写关系型数据库，可以先根据主键查询，判断数据是否已存在，存在则更新，不存在则插入；</li><li>如果是写 Redis，由于 set 操作天然具有幂等性，所以什么都不用做；</li><li>如果是根据消息做较复杂的逻辑处理，可以在消息中加入全局唯一 ID，例如：订单 ID 等。在客户端存储中（Mysql、Redis 等）保存已消费消息的 ID。一旦接受到新消息，先判断消息中的 ID 是否在已消费消息 ID 表中存在，存在则不再处理，不存在则处理。</li></ul><p>在实际开发中，可以参考上面的例子，结合现实场景，设计合理的幂等性方案。</p><h3 id="2-消息丢失"><a href="#2-消息丢失" class="headerlink" title="2. 消息丢失"></a>2. 消息丢失</h3><p><strong>如何处理消息丢失的问题</strong> 和 <strong>如何保证消息不被重复消费</strong> 是同一个问题。关注点有：</p><ul><li>MQ Server 丢失数据</li><li>消费方丢失数据</li><li>生产方丢失数据</li></ul><h4 id="消费方丢失数据"><a href="#消费方丢失数据" class="headerlink" title="消费方丢失数据"></a>消费方丢失数据</h4><p>唯一可能导致消费方丢失数据的情况是：消费方设置了<strong>自动提交 Offset</strong>。一旦设置了自动提交 Offset，接受到消息后就会自动提交 Offset 给 Kafka ，Kafka 就认为消息已被消费。如果此时，消费方尚未来得及处理消息就挂了，那么消息就丢了。</p><p>解决方法就是：消费方关闭自动提交 Offset，处理完消息后<strong>手动提交 Offset</strong>。但这种情况下可能会出现重复消费的情形，需要自行保证幂等性。</p><h4 id="RabbitMq弄丢了数据"><a href="#RabbitMq弄丢了数据" class="headerlink" title="RabbitMq弄丢了数据"></a><strong>RabbitMq弄丢了数据</strong></h4><p>就是 RabbitMQ 自己弄丢了数据，这个你必须<strong>开启 RabbitMQ 的持久化</strong>，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，<strong>恢复之后会自动读取之前存储的数据</strong>，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，<strong>可能导致少量数据丢失</strong>，但是这个概率较小。</p><p>设置持久化有<strong>两个步骤</strong>：</p><ul><li>创建 queue 的时候将其设置为持久化<br>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li><li>第二个是发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2<br>就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li></ul><p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p><p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p><p>所以，持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code>，你也是可以自己重发的。</p><h4 id="生产方丢失数据"><a href="#生产方丢失数据" class="headerlink" title="生产方丢失数据"></a>生产方丢失数据</h4><p>如果按照上述的思路设置了 <code>acks=all</code>，生产方一定不会丢数据。</p><p>要求是，你的 Leader 接收到消息，所有的 Follower 都同步到了消息之后，才认为本生产消息成功了。如果未满足这个条件，生产者会自动不断的重试，重试无限次。</p><h3 id="3-消息的顺序性"><a href="#3-消息的顺序性" class="headerlink" title="3. 消息的顺序性"></a>3. 消息的顺序性</h3><p>要保证 MQ 的顺序性，势必要付出一定的代价，所以实施方案前，要先明确业务场景是不是有必要保证消息的顺序性。只有那些明确对消息处理顺序有要求的业务场景才值得去保证消息顺序性。</p><p>方案一</p><p>一个 Topic，一个 Partition，一个 Consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</p><p>方案二</p><ul><li>写入数据到 Partition 时指定一个全局唯一的 ID，例如订单 ID。发送方保证相同 ID 的消息有序的发送到同一个 Partition。</li><li>基于上一点，消费方从 Kafka Partition 中消费消息时，此刻一定是顺序的。但如果消费方式以并发方式消费消息，顺序就可能会被打乱。为此，还有做到以下几点：<ul><li>消费方维护 N 个缓存队列，具有相同 ID 的数据都写入同一个队列中；</li><li>创建 N 个线程，每个线程只负责从指定的一个队列中取数据。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210427194215.png" alt="img"></p><h3 id="4-消息积压"><a href="#4-消息积压" class="headerlink" title="4. 消息积压"></a>4. 消息积压</h3><p>假设一个 MQ 消费者可以一秒处理 1000 条消息，三个 MQ 消费者可以一秒处理 3000 条消息，那么一分钟的处理量是 18 万条。如果 MQ 中积压了几百万到上千万的数据，即使消费者恢复了，也需要大概很长的时间才能恢复过来。</p><p>对于产线环境来说，漫长的等待是不可接受的，所以面临这种窘境时，只能临时紧急扩容以应对了，具体操作步骤和思路如下：</p><ul><li>先修复 Consumer 的问题，确保其恢复消费速度，然后将现有 Consumer 都停掉。</li><li>新建一个 Topic，Partition 是原来的 10 倍，临时建立好原先 10 倍的 Queue 数量。</li><li>然后写一个临时的分发数据的 Consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 Queue。</li><li>接着临时征用 10 倍的机器来部署 Consumer ，每一批 Consumer 消费一个临时 Queue 的数据。这种做法相当于是临时将 Queue 资源和 Consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li><li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MQ-的问题&quot;&gt;&lt;a href=&quot;#MQ-的问题&quot; class=&quot;headerlink&quot; title=&quot;MQ 的问题&quot;&gt;&lt;/a&gt;MQ 的问题&lt;/h2&gt;&lt;p&gt;任何技术都会有利有弊，MQ 给整体系统架构带来很多好处，但也会付出一定的代价。&lt;/p&gt;
&lt;p&gt;MQ 主要引入</summary>
      
    
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Skip List--跳表</title>
    <link href="https://leslieaibin.github.io/2021/10/30/Redis/%E8%B7%B3%E8%A1%A8/"/>
    <id>https://leslieaibin.github.io/2021/10/30/Redis/%E8%B7%B3%E8%A1%A8/</id>
    <published>2021-10-30T01:15:42.000Z</published>
    <updated>2022-02-14T02:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Skip-List–跳表"><a href="#Skip-List–跳表" class="headerlink" title="Skip List–跳表"></a>Skip List–跳表</h1><p>跳表是一种神奇的数据结构，因为几乎所有版本的大学本科教材上都没有跳表这种数据结构，而且神书《算法导论》、《算法第四版》这两本书中也没有介绍跳表。但是跳表插入、删除、查找元素的时间复杂度跟红黑树都是一样量级的，时间复杂度都是O(logn)，而且跳表有一个特性是红黑树无法匹敌的（具体什么特性后面会提到）。所以在工业中，跳表也会经常被用到。废话不多说了，开始今天的跳表学习。</p><p>通过本文，你能 get 到以下知识：</p><ul><li>  什么是跳表？</li><li>  跳表的查找、插入、删除元素的流程</li><li>  跳表查找、插入、删除元素的时间复杂度</li><li>  跳表插入元素时，如何动态维护索引？</li><li>  为什么Redis选择使用跳表而不是红黑树来实现有序集合？</li><li>  工业上其他使用跳表的场景</li></ul><blockquote><p>友情提示：下文在跳表插入数据时，会讲述如何动态维护索引，实现比较简单，逻辑比较绕，不要放弃，加油！！！如果一遍看不懂没关系，可以选择暂时性的跳过，毕竟这块偏向于源码。但是读者必须知道跳表的查找、插入、删除的时间复杂度都是 O(logn)，而且可以按照范围区间查找元素，当工作中遇到某些场景时，需要想到可以使用跳表解决问题即可。毕竟平时的工作都是直接使用封装好的跳表，例如：java.util.concurrent 下的 ConcurrentSkipListMap()。</p></blockquote><h3 id="理解跳表，从单链表开始说起"><a href="#理解跳表，从单链表开始说起" class="headerlink" title="理解跳表，从单链表开始说起"></a>理解跳表，从单链表开始说起</h3><p>下图是一个简单的<strong>有序单链表</strong>，单链表的特性就是每个元素存放下一个元素的引用。即：通过第一个元素可以找到第二个元素，通过第二个元素可以找到第三个元素，依次类推，直到找到最后一个元素。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/37027.jpg"></p><p>跳表-原始链表.jpeg</p><p>现在我们有个场景，想快速找到上图链表中的 10 这个元素，只能从头开始遍历链表，直到找到我们需要找的元素。查找路径：1、3、4、5、7、8、9、10。这样的查找效率很低，平均时间复杂度很高O(n)。那有没有办法提高链表的查找速度呢？如下图所示，我们从链表中每两个元素抽出来，加一级索引，一级索引指向了原始链表，即：通过一级索引 7 的down指针可以找到原始链表的 7 。那现在怎么查找 10 这个元素呢？</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/60225.jpg"></p><p>跳表-一级索引.jpeg</p><p>先在索引找 1、4、7、9，遍历到一级索引的 9 时，发现 9 的后继节点是 13，比 10 大，于是不往后找了，而是通过 9 找到原始链表的 9，然后再往后遍历找到了我们要找的 10，遍历结束。有没有发现，加了一级索引后，查找路径：1、4、7、9、10，查找节点需要遍历的元素相对少了，我们不需要对 10 之前的所有数据都遍历，查找的效率提升了。</p><p>那如果加二级索引呢？如下图所示，查找路径：1、7、9、10。是不是找 10 的效率更高了？这就是跳表的思想，用“空间换时间”，通过给链表建立索引，提高了查找的效率。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/23212.jpg"></p><p>跳表-二级索引.jpeg</p><p>可能同学们会想，从上面案例来看，提升的效率并不明显，本来需要遍历8个元素，优化了半天，还需要遍历 4 个元素，其实是因为我们的数据量太少了，当数据量足够大时，效率提升会很大。如下图所示，假如有序单链表现在有1万个元素，分别是 0~9999。现在我们建了很多级索引，最高级的索引，就两个元素 0、5000，次高级索引四个元素 0、2500、5000、7500，依次类推，当我们查找 7890 这个元素时，查找路径为 0、5000、7500 … 7890，通过最高级索引直接跳过了5000个元素，次高层索引直接跳过了2500个元素，<strong>从而使得链表能够实现二分查找</strong>。由此可以看出，当元素数量较多时，索引提高的效率比较大，近似于二分查找。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/65247.jpg"></p><p>数据量增多后，索引效果图.png</p><p>到这里大家应该已经明白了什么是跳表。跳表是<strong>可以实现二分查找的有序链表</strong>。</p><h3 id="查找的时间复杂度"><a href="#查找的时间复杂度" class="headerlink" title="查找的时间复杂度"></a>查找的时间复杂度</h3><p>既然跳表可以提升链表查找元素的效率，那查找一个元素的时间复杂度到底是多少呢？查找元素的过程是从最高级索引开始，一层一层遍历最后下沉到原始链表。所以，时间复杂度 = 索引的高度 * 每层索引遍历元素的个数。</p><p>先来求跳表的索引高度。如下图所示，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/2k个元素。最高级索引一般有2个元素，即：最高级索引 h 满足 2 = n/2h，即 h = log2n - 1，最高级索引 h 为索引层的高度加上原始数据一层，跳表的总高度 h = log2n。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214100936207.png" alt="image-20220214100936207"></p><p>查找的时间复杂度证明.jpeg</p><p>我们看上图中加粗的箭头，表示查找元素 x 的路径，那查找过程中每一层索引最多遍历几个元素呢？</p><p>图中所示，现在到达第 k 级索引，我们发现要查找的元素 x 比 y 大比 z 小，所以，我们需要从 y 处下降到 k-1 级索引继续查找，k-1级索引中比 y 大比 z 小的只有一个 w，所以在 k-1 级索引中，我们遍历的元素最多就是 y、w、z，发现 x 比 w大比 z 小之后，再下降到 k-2 级索引。所以，k-2 级索引最多遍历的元素为 w、u、z。其实每级索引都是类似的道理，每级索引中都是两个结点抽出一个结点作为上一级索引的结点。 现在我们得出结论：当每级索引都是两个结点抽出一个结点作为上一级索引的结点时，每一层最多遍历3个结点。</p><p>跳表的索引高度 h = log2n，且每层索引最多遍历 3 个元素。所以跳表中查找一个元素的时间复杂度为 O(3*logn)，省略常数即：O(logn)。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>跳表通过建立索引，来提高查找元素的效率，就是典型的“空间换时间”的思想，所以在空间上做了一些牺牲，那空间复杂度到底是多少呢？</p><p>假如原始链表包含 n 个元素，则一级索引元素个数为 n/2、二级索引元素个数为 n/4、三级索引元素个数为 n/8 以此类推。所以，索引节点的总和是：n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2，**空间复杂度是 O(n)**。</p><p>如下图所示：如果每三个结点抽一个结点做为索引，索引总和数就是 n/3 + n/9 + n/27 + … + 9 + 3 + 1= n/2，减少了一半。所以我们可以通过较少索引数来减少空间复杂度，但是相应的肯定会造成查找效率有一定下降，我们可以根据我们的应用场景来控制这个阈值，看我们更注重时间还是空间。</p><p>![image-20220214100955292](/Users/leslie/Library/Application Support/typora-user-images/image-20220214100955292.png)</p><p>三个节点提取一个做索引.jpeg</p><p>But，索引结点往往只需要存储 key 和几个指针，并不需要存储完整的对象，所以当对象比索引结点大很多时，索引占用的额外空间就可以忽略了。举个例子：我们现在需要用跳表来给所有学生建索引，学生有很多属性：学号、姓名、性别、身份证号、年龄、家庭住址、身高、体重等。学生的各种属性只需要在原始链表中存储一份即可，我们只需要用学生的学号（int 类型的数据）建立索引，所以索引相对原始数据而言，占用的空间可以忽略。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入数据看起来也很简单，跳表的原始链表需要保持有序，所以我们会向查找元素一样，找到元素应该插入的位置。如下图所示，要插入数据6，整个过程类似于查找6，整个的查找路径为 1、1、1、4、4、5。查找到第底层原始链表的元素 5 时，发现 5 小于 6 但是后继节点 7 大于 6，所以应该把 6 插入到 5 之后 7 之前。整个时间复杂度为查找元素的时间复杂度 O(logn)。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101012915.png" alt="image-20220214101012915"></p><p>插入数据图示.jpeg</p><p>如下图所示，假如一直往原始列表中添加数据，但是不更新索引，就可能出现两个索引节点之间数据非常多的情况，极端情况，跳表退化为单链表，从而使得查找效率从 O(logn) 退化为 O(n)。那这种问题该怎么解决呢？我们需要在插入数据的时候，索引节点也需要相应的增加、或者重建索引，来避免查找效率的退化。那我们该如何去维护这个索引呢？</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101025149.png" alt="image-20220214101025149"></p><p>插入数据，不更新索引图示.jpeg</p><p>比较容易理解的做法就是完全重建索引，我们每次插入数据后，都把这个跳表的索引删掉全部重建，重建索引的时间复杂度是多少呢？因为索引的空间复杂度是 O(n)，即：索引节点的个数是 O(n) 级别，每次完全重新建一个 O(n) 级别的索引，时间复杂度也是 O(n) 。造成的后果是：为了维护索引，导致每次插入数据的时间复杂度变成了 O(n)。</p><p>那有没有其他效率比较高的方式来维护索引呢？假如跳表每一层的晋升概率是 1/2，最理想的索引就是在原始链表中每隔一个元素抽取一个元素做为一级索引。换种说法，<strong>我们在原始链表中随机的选 n/2 个元素做为一级索引是不是也能通过索引提高查找的效率呢？</strong> 当然可以了，因为一般随机选的元素相对来说都是比较均匀的。如下图所示，随机选择了n/2 个元素做为一级索引，虽然不是每隔一个元素抽取一个，但是对于查找效率来讲，影响不大，比如我们想找元素 16，仍然可以通过一级索引，使得遍历路径较少了将近一半。如果抽取的一级索引的元素恰好是前一半的元素 1、3、4、5、7、8，那么查找效率确实没有提升，但是这样的概率太小了。我们可以认为：当原始链表中<strong>元素数量足够大</strong>，且<strong>抽取足够随机</strong>的话，我们得到的索引是均匀的。我们要清楚设计良好的数据结构都是为了应对大数据量的场景，如果原始链表只有 5 个元素，那么依次遍历 5 个元素也没有关系，因为数据量太少了。所以，我们可以维护一个这样的索引：<strong>随机选 n/2 个元素做为一级索引、随机选 n/4 个元素做为二级索引、随机选 n/8 个元素做为三级索引，依次类推，一直到最顶层索引</strong>。这里每层索引的元素个数已经确定，且每层索引元素选取的足够随机，所以可以通过索引来提升跳表的查找效率。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101046805.png" alt="image-20220214101046805"></p><p>跳表-一级索引随机分布.jpg</p><p>那代码该如何实现，才能使跳表满足上述这个样子呢？可以在每次新插入元素的时候，尽量让该元素有 1/2 的几率建立一级索引、1/4 的几率建立二级索引、1/8 的几率建立三级索引，以此类推，就能满足我们上面的条件。现在我们就需要一个概率算法帮我们把控这个 1/2、1/4、1/8 … ，<strong>当每次有数据要插入时，先通过概率算法告诉我们这个元素需要插入到几级索引中</strong>，然后开始维护索引并把数据插入到原始链表中。下面开始讲解这个概率算法代码如何实现。</p><p>我们可以实现一个 randomLevel() 方法，该方法会随机生成 1~MAX_LEVEL 之间的数（MAX_LEVEL表示索引的最高层数），且该方法<strong>有 1/2 的概率返回 1、1/4 的概率返回 2、1/8的概率返回 3，以此类推</strong>。</p><ul><li>  randomLevel() 方法返回 1 表示当前插入的该元素不需要建索引，只需要存储数据到原始链表即可（概率 1/2）</li><li>  randomLevel() 方法返回 2 表示当前插入的该元素需要建一级索引（概率 1/4）</li><li>  randomLevel() 方法返回 3 表示当前插入的该元素需要建二级索引（概率 1/8）</li><li>  randomLevel() 方法返回 4 表示当前插入的该元素需要建三级索引（概率 1/16）</li><li>  。。。以此类推</li></ul><p>所以，通过 randomLevel() 方法，我们可以控制整个跳表各级索引中元素的个数。<strong>重点来了</strong>：randomLevel() 方法返回 2 的时候会建立一级索引，我们想要一级索引中元素个数占原始数据的 1/2，但是 randomLevel() 方法返回 2 的概率为 1/4，那是不是有矛盾呢？明明说好的 1/2，结果一级索引元素个数怎么变成了原始链表的 1/4？我们先看下图，应该就明白了。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101108858.png" alt="image-20220214101108858"></p><p>插入数据图示.jpeg</p><p>假设我们在插入元素 6 的时候，randomLevel() 方法返回 1，则我们不会为 6 建立索引。插入 7 的时候，randomLevel() 方法返回3 ，所以我们需要为元素 7 建立二级索引。这里我们发现了一个特点：当建立二级索引的时候，同时也会建立一级索引；当建立三级索引时，同时也会建立一级、二级索引。所以，一级索引中元素的个数等于 <em>[ 原始链表元素个数 ]</em> * _[ randomLevel() 方法返回值 &gt; 1 的概率 ]_。因为 randomLevel() 方法返回值 &gt; 1就会建索引，凡是建索引，无论几级索引必然有一级索引，<strong>所以一级索引中元素个数占原始数据个数的比率为 randomLevel() 方法返回值 &gt; 1 的概率</strong>。那 randomLevel() 方法返回值 &gt; 1 的概率是多少呢？因为 randomLevel() 方法随机生成 1~MAX_LEVEL 的数字，且 randomLevel() 方法返回值 1 的概率为 1/2，则 randomLevel() 方法返回值 &gt; 1 的概率为 1 - 1/2 = 1/2。即<strong>通过上述流程实现了一级索引中元素个数占原始数据个数的 1/2</strong>。</p><p>同理，当 randomLevel() 方法返回值 &gt; 2 时，会建立二级或二级以上索引，都会在二级索引中增加元素，因此<strong>二级索引中元素个数占原始数据的比率为 randomLevel() 方法返回值 &gt; 2 的概率</strong>。 randomLevel() 方法返回值 &gt; 2 的概率为 1 减去 randomLevel() = 1 或 =2 的概率，即 1 - 1/2 - 1/4 = 1/4。OK，达到了我们设计的目标：<strong>二级索引中元素个数占原始数据的 1/4</strong>。</p><p>以此类推，可以得出，遵守以下两个条件：</p><ul><li>  randomLevel() 方法，随机生成 1~MAX_LEVEL 之间的数（MAX_LEVEL表示索引的最高层数），且<strong>有 1/2的概率返回 1、1/4的概率返回 2、1/8的概率返回 3 …</strong></li><li>  randomLevel() 方法返回 1 不建索引、返回2建一级索引、返回 3 建二级索引、返回 4 建三级索引 …</li></ul><p>就可以满足我们想要的结果，即：一级索引中元素个数应该占原始数据的 1/2，二级索引中元素个数占原始数据的 1/4，三级索引中元素个数占原始数据的 1/8 ，依次类推，一直到最顶层索引。</p><p>但是问题又来了，怎么设计这么一个 randomLevel() 方法呢？直接撸代码：</p><pre><code>// 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：//        1/2 的概率返回 1//        1/4 的概率返回 2//        1/8 的概率返回 3 以此类推private int randomLevel() &#123;  int level = 1;  // 当 level &lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level + 1  while (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL)    level += 1;  return level;&#125;</code></pre><p>上述代码可以实现我们的功能，而且，我们的案例中晋升概率 SKIPLIST_P 设置的 1/2，即：每两个结点抽出一个结点作为上一级索引的结点。如果我们想节省空间利用率，可以适当的降低代码中的 SKIPLIST_P，从而减少索引元素个数，Redis 的 zset 中 SKIPLIST_P 设定的 0.25。下图所示，是Redis <a href="https://links.jianshu.com/go?to=https://github.com/antirez/redis/blob/unstable/src/t_zset.c">t_zset.c</a> 中 zslRandomLevel 函数的实现：</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101129643.png" alt="image-20220214101129643"></p><p>Redis 源码中 <code>(random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF)</code> 在功能上等价于我代码中的 <code>Math.random() &lt; SKIPLIST_P</code> ，只不过 Redis 作者 <a href="https://links.jianshu.com/go?to=https://github.com/antirez">antirez</a> 使用位运算来提高浮点数比较的效率。</p><p>整体思路大家应该明白了，那插入数据时维护索引的时间复杂度是多少呢？**元素插入到单链表的时间复杂度为 O(1)**，我们索引的高度最多为 logn，当插入一个元素 x 时，最坏的情况就是元素 x 需要插入到每层索引中，所以插入数据到各层索引中，最坏时间复杂度是 O(logn)。</p><p>过程大概理解了，再通过一个例子描述一下跳表插入数据的全流程。现在我们要插入数据 6 到跳表中，首先 randomLevel() 返回 3，表示<strong>需要建二级索引</strong>，即：一级索引和二级索引需要增加元素 6。该跳表目前最高三级索引，首先找到三级索引的 1，发现 6 比 1大比 13小，所以，从 1 下沉到二级索引。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101146750.png" alt="image-20220214101146750"></p><p>下沉到二级索引后，发现 6 比 1 大比 7 小，此时需要在二级索引中 1 和 7 之间加一个元素6 ，并从元素 1 继续下沉到一级索引。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101201432.png" alt="image-20220214101201432">插入数据且维护跳表图示2.jpeg</p><p>下沉到一级索引后，发现 6 比 1 大比 4 大，所以往后查找，发现 6 比 4 大比 7 小，此时需要在一级索引中 4 和 7 之间加一个元素 6 ，并把二级索引的 6 指向 一级索引的 6，最后，从元素 4 继续下沉到原始链表。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101216693.png" alt="image-20220214101216693"></p><p>下沉到原始链表后，就比较简单了，发现 4、5 比 6小，7比6大，所以将6插入到 5 和 7 之间即可，整个插入过程结束。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101229592.png" alt="image-20220214101229592">整个插入过程的路径与查找元素路径类似， 每层索引中插入元素的时间复杂度 O(1)，所以整个插入的时间复杂度是 O(logn)。</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>跳表删除数据时，要把索引中对应节点也要删掉。如下图所示，如果要删除元素 9，需要把原始链表中的 9 和第一级索引的 9 都删除掉。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101245553.png" alt="image-20220214101245553">跳表中，删除元素的时间复杂度是多少呢？</p><p>删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素 x，则执行删除操作。跳表中，每一层索引其实都是一个有序的单链表，单链表删除元素的时间复杂度为 O(1)，索引层数为 logn 表示最多需要删除 logn 个元素，所以删除元素的总时间包含 <em>查找元素的时间</em> 加 <em>删除 logn个元素的时间</em> 为 O(logn) + O(logn) = 2 O(logn)，忽略常数部分，删除元素的时间复杂度为 O(logn)。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p> 跳表是可以实现二分查找的有序链表；</p></li><li><p> 每个元素插入时随机生成它的level；</p></li><li><p> 最底层包含所有的元素；</p></li><li><p> 如果一个元素出现在level(x)，那么它肯定出现在x以下的level中；</p></li><li><p> 每个索引节点包含两个指针，一个向下，一个向右；（笔记目前看过的各种跳表源码实现包括Redis 的zset 都没有向下的指针，那怎么从二级索引跳到一级索引呢？留个悬念，看源码吧，文末有跳表实现源码）</p></li><li><p> 跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近；</p></li></ol><h3 id="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"><a href="#为什么Redis选择使用跳表而不是红黑树来实现有序集合？" class="headerlink" title="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"></a>为什么Redis选择使用跳表而不是红黑树来实现有序集合？</h3><p>Redis 中的有序集合(zset) 支持的操作：</p><ol><li><p> 插入一个元素</p></li><li><p> 删除一个元素</p></li><li><p> 查找一个元素</p></li><li><p> 有序输出所有元素</p></li><li><p> 按照范围区间查找元素（比如查找值在 [100, 356] 之间的数据）</p></li></ol><p>其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。</p><h3 id="工业上其他使用跳表的场景"><a href="#工业上其他使用跳表的场景" class="headerlink" title="工业上其他使用跳表的场景"></a>工业上其他使用跳表的场景</h3><p>在博客上从来没有见过有同学讲述 HBase MemStore 的数据结构，其实 HBase MemStore 内部存储数据就使用的跳表。为什么呢？HBase 属于 LSM Tree 结构的数据库，LSM Tree 结构的数据库有个特点，实时写入的数据先写入到内存，内存达到阈值往磁盘 flush 的时候，会生成类似于 StoreFile 的<strong>有序文件</strong>，而跳表恰好就是天然有序的，所以在 flush 的时候效率很高，而且跳表查找、插入、删除性能都很高，这应该是 HBase MemStore 内部存储数据使用跳表的原因之一。HBase 使用的是 java.util.concurrent 下的 ConcurrentSkipListMap()。</p><p>Google 开源的 key/value 存储引擎 LevelDB 以及 Facebook 基于 LevelDB 优化的 RocksDB 都是 LSM Tree 结构的数据库，他们内部的 MemTable 都是使用了跳表这种数据结构。</p><p>后期笔者还会输出一篇深入剖析 LSM Tree 的博客，到时候再结合场景分析为什么使用跳表。</p><p>参考：</p><p><a href="https://links.jianshu.com/go?to=https://github.com/antirez/redis/blob/unstable/src/t_zset.c">Redis zset源码</a></p><p><a href="https://links.jianshu.com/go?to=https://time.geekbang.org/column/article/42896">极客时间-数据结构与算法之美课程</a></p><ul><li>  王争老师的整套课程都很棒，对数据结构与算法想整体提高的同学可以订阅</li></ul><p><a href="https://links.jianshu.com/go?to=https://github.com/wangzheng0822/algo/blob/master/java/17_skiplist/SkipList.java">王争老师SkipList 实现</a></p><ul><li>  这个跳表实现相对简单，建议初学者参考，整个项目是王争老师极客时间课程配套的代码，其他数据结构实现也可以参考</li><li>  笔记在写本博客期间，向该项目提交了 pr，已被merge，模仿 redis 源码重新实现了 randomLevel() 方法，不过为了容易理解没有使用redis的位运算，之前的 randomLevel() 方法会导致索引冗余特别严重，5 级以下的索引中元素个数接近于所有元素的个数，有兴趣的同学可以继续深入研究</li></ul><p><a href="https://links.jianshu.com/go?to=https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5ac63d5188256255299d9c">源码 5：凌波微步 —— 探索「跳跃列表」内部结构</a></p><ul><li>  老钱的《Redis 深度历险》系列非常推荐</li></ul><p><a href="https://www.jianshu.com/p/dd01e8dc4d1f">拜托，面试别再问我跳表了！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Skip-List–跳表&quot;&gt;&lt;a href=&quot;#Skip-List–跳表&quot; class=&quot;headerlink&quot; title=&quot;Skip List–跳表&quot;&gt;&lt;/a&gt;Skip List–跳表&lt;/h1&gt;&lt;p&gt;跳表是一种神奇的数据结构，因为几乎所有版本的大学本科教材上都</summary>
      
    
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>11.数据库优化</title>
    <link href="https://leslieaibin.github.io/2021/10/25/MySQL/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <id>https://leslieaibin.github.io/2021/10/25/MySQL/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</id>
    <published>2021-10-25T12:17:42.000Z</published>
    <updated>2022-02-13T03:56:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库优化和查询优化方案"><a href="#数据库优化和查询优化方案" class="headerlink" title="数据库优化和查询优化方案"></a>数据库优化和查询优化方案</h1><h3 id="数据库优化方案"><a href="#数据库优化方案" class="headerlink" title="数据库优化方案"></a>数据库优化方案</h3><ol><li> 优化索引，sql语句，分析慢查询</li><li> 设计表的时候严格按照数据库设计规范来设计数据库</li><li> 使用缓存，把经常访问并且不需要经常变化的数据放在缓存中，能够节约磁盘IO</li><li> 优化硬件，采用ssd，使用磁盘队列技术（RAID0， RAID1，RAID5）</li><li> 采用mysql自带的表分区技术，把数据分析分成不同文件，能够磁盘的读写效率</li><li> 垂直分表，把一些不经常读的数据放在一张表当中，节约磁盘IO</li><li> 主从分离读写，采用主从复制把数据库的读操作和写操作分离开来</li><li> 分库分表分机器，数据量特别大的时候，主要的原理是数据路由</li><li> 选择合适的表引擎，参数上的优化</li><li> 进行架构级别的缓存，静态化和分布式</li><li> 不采用全文检索</li><li> 采用更快的存储方恨少，例如nosql存储经常访问的数据</li></ol><h3 id="优化数据库的查询效率"><a href="#优化数据库的查询效率" class="headerlink" title="优化数据库的查询效率"></a>优化数据库的查询效率</h3><ol><li> 存储引擎的选择，如果数据表需要事务处理，应该考虑Innodb，因为它完全符合ACID的特性，如果不需要食物处理，使用默认存储引擎MyISAM是比较明智的</li><li> 分表分库主从</li><li> 对查询进行优化，要尽量避免全表扫描，首先应考虑在shere以及orderby涉及的列上建立索引</li><li> 应尽量避免在where子句当中使用，不等于或者大于小于操作符，否则将导致引擎放弃使用索引而进行全表扫描</li><li> 应尽量避免在where子句当中使用null值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li> 应尽量避免在where子句当中使用or的判断，如果一个字段有索引，一个字段没有索引，将会导致引擎放弃使用索引而进行全表扫描</li><li> update语句如果只改一两个字段，不要update全部字段，否则频繁调用，会引起明显的性能消耗，同时带来的大量的日志</li><li> 对于多张数据量的表进行join，要先分页在做join，否则逻辑读写高，性能差</li></ol><hr><p>详细的优化方案</p><ul><li><p>1）数据库设计方面：</p><ul><li><p>  a. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p></li><li><p>  b. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0</p></li><li><p>  c. 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p></li><li><p>  d. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p></li><li><p>  e. 应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引。</p></li><li><p>  f. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p></li><li><p>  g. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p></li><li><p>  h. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p></li><li><p>  i. 避免频繁创建和删除临时表，以减少系统表资源的消耗。</p></li><li><p>  j. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p></li><li><p>  k. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p></li><li><p>  l. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p></li></ul></li></ul><ul><li><p>2)SQL语句方面：</p><ul><li><p>  a. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p></li><li><p>  b. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p></li></ul></li></ul><p><code>select id from t where num=10 or num=20</code></p><p>可以这样查询：</p><p><code>select id from t where num=10 union all select id from t where num=20</code></p><pre><code>- c. in 和 not in 也要慎用，否则会导致全表扫描，如： </code></pre><p><code>select id from t where num in(1,2,3)</code></p><p>对于连续的数值，能用 between 就不要用 in 了：</p><p><code>select id from t where num between 1 and 3</code></p><pre><code>- d. 下面的查询也将导致全表扫描： </code></pre><p><code>select id from t where name like ‘%abc%’</code></p><pre><code>- e. 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。</code></pre><p>然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><p><code>select id from t where num=@num</code></p><p>可以改为强制查询使用索引：</p><p><code>select id from t with(index(索引名)) where num=@num</code></p><pre><code>- f. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： </code></pre><p><code>select id from t where num/2=100</code></p><p>应改为:</p><p><code>select id from t where num=100*2</code></p><pre><code>- g. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： </code></pre><p><code>select id from t where substring(name,1,3)=’abc’</code></p><p>–name以abc开头的id</p><p><code>select id from t where datediff(day,createdate,’2005-11-30′)=0</code></p><p>–‘2005-11-30’生成的id</p><p>应改为:</p><p><code>select id from t where name like ‘abc%’ select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′</code></p><pre><code>- h. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。- i. 不要写一些没有意义的查询，如需要生成一个空表结构： </code></pre><p><code>select col1,col2 into #t from t where 1=0</code></p><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p><p>create table #t(…)</p><pre><code>- j. 很多时候用 exists 代替 in 是一个好的选择： </code></pre><p><code>select num from a where num in(select num from b)</code></p><p>用下面的语句替换：</p><p><code>select num from a where exists(select 1 from b where num=a.num)</code></p><pre><code>- k. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。- l. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。- m. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。- n. 尽量避免大事务操作，提高系统并发能力。</code></pre><ul><li><p>3)java方面：重点内容</p><ul><li><p>  a.尽可能的少造对象。</p></li><li><p>  b.合理摆正系统设计的位置。大量数据操作，和少量数据操作一定是分开的。大量的数据操作，肯定不是ORM框架搞定的。，</p></li><li><p>  c.使用jDBC链接数据库操作数据</p></li><li><p>  d.控制好内存，让数据流起来，而不是全部读到内存再处理，而是边读取边处理；</p></li><li><p>  e.合理利用内存，有的数据要缓存</p></li></ul></li></ul><p>如何优化数据库，如何提高数据库的性能?</p><p>1） 硬件调整性能 </p><p>最有可能影响性能的是磁盘和网络吞吐量,解决办法扩大虚拟内存，并保证有足够可以扩充的空间；把数据库服务器上的不必要服务关闭掉；把数据库服务器和主域服务器分开；把SQL数据库服务器的吞吐量调为最大；在具有一个以上处理器的机器上运行SQL。</p><p>2）调整数据库</p><p>若对该表的查询频率比较高，则建立索引；建立索引时，想尽对该表的所有查询搜索操作， 按照where选择条件建立索引，尽量为整型键建立为有且只有一个簇集索引，数据在物理上按顺序在数据页上，缩短查找范围，为在查询经常使用的全部列建立非簇集索引，能最大地覆盖查询；但是索引不可太多，执行UPDATE DELETE INSERT语句需要用于维护这些索引的开销量急剧增加；避免在索引中有太多的索引键；避免使用大型数据类型的列为索引；保证每个索引键值有少数行。</p><p>3）使用存储过程</p><p>应用程序的实现过程中，能够采用存储过程实现的对数据库的操作尽量通过存储过程来实现，因为存储过程是存放在数据库服务器上的一次性被设计、编码、测试，并被再次使用，需要执行该任务的应用可以简单地执行存储过程，并且只返回结果集或者数值，这样不仅可以使程序模块化，同时提高响应速度，减少网络流量，并且通过输入参数接受输入，使得在应用中完成逻辑的一致性实现。</p><p>4）应用程序结构和算法</p><p>建立查询条件索引仅仅是提高速度的前提条件，响应速度的提高还依赖于对索引的使用。因为人们在使用SQL时往往会陷入一个误区，即太关注于所得的结果是否正确，特别是对数据量不是特别大的数据库操作时，是否建立索引和使用索引的好坏对程序的响应速度并不大，因此程序员在书写程序时就忽略了不同的实现方法之间可能存在的性能差异，这种性能差异在数据量特别大时或者大型的或是复杂的数据库环境中（如联机事务处理OLTP或决策支持系统DSS）中表现得尤为明显。在工作实践中发现，不良的SQL往往来自于不恰当的索引设计、不充份的连接条件和不可优化的where子句。在对它们进行适当的优化后，其运行速度有了明显地提高！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库优化和查询优化方案&quot;&gt;&lt;a href=&quot;#数据库优化和查询优化方案&quot; class=&quot;headerlink&quot; title=&quot;数据库优化和查询优化方案&quot;&gt;&lt;/a&gt;数据库优化和查询优化方案&lt;/h1&gt;&lt;h3 id=&quot;数据库优化方案&quot;&gt;&lt;a href=&quot;#数据库优化方</summary>
      
    
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>10.分库分表</title>
    <link href="https://leslieaibin.github.io/2021/10/25/MySQL/10.%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>https://leslieaibin.github.io/2021/10/25/MySQL/10.%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2021-10-25T12:17:42.000Z</published>
    <updated>2022-02-13T01:59:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要拆分数据库？"><a href="#1-为什么要拆分数据库？" class="headerlink" title="1. 为什么要拆分数据库？"></a><strong>1. 为什么要拆分数据库？</strong></h2><p>单体项目在构建之初，<a href="https://link.zhihu.com/?target=https://coding.imooc.com/class/274.html?mc_marking=b9478d5f12bd4de1a83dc61bc224d99f&mc_channel=shouji">数据库</a>的负载和数据量都不大，所以不需要对数据库做拆分，小型财务系统、文书系统、ERP系统、OA系统，用一个MySQL数据库实例基本就够用了。</p><p>就像《淘宝技术这十年》里面说到的，电商业务的数据量增长飞快，所以最开始的PHP+MySQL的架构已经不能满足实际要求了，于是淘宝想到的第一个办法就是把MySQL替换成Oracle。但是没过了多久，在08年前后，单节点的Oracle数据库也不好用了，于是淘宝终于告别了单节点数据库，开始拆分数据库。从一个节点，变成多个节点。</p><p>拆分数据库是有讲究的，比如说拆分方法有两种：垂直切分和水平切分。那你是先水平切分还是垂直切分呢？顺序无所谓？不，顺序有所为，次序绝对不能错：先水平切分，然后垂直切分。</p><h2 id="2-什么是垂直切分？"><a href="#2-什么是垂直切分？" class="headerlink" title="2. 什么是垂直切分？"></a><strong>2. 什么是垂直切分？</strong></h2><p>垂直切分是根据业务来拆分数据库，同一类业务的数据表拆分到一个独立的数据库，另一类的数据表拆分到其他数据库。</p><p>比如说一个新零售的电商数据库，我们可以把跟商品相关的数据表拆分成一个数据库，然后在这些数据表的基础之上，构建出商品系统。比如用JAVA或者PHP语言，创建出一个商城系统。然后把跟进销存相关的数据表拆分到另外一个数据库上，再用程序构建出仓库系统。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-cb822f0a43ecbeeeef8ed3845a3fa278_1440w.jpg" alt="img"></p><p><strong>垂直切分解决了什么问题</strong></p><p>垂直切分可以降低单节点数据库的负载。原来所有数据表都放在一个数据库节点上，无疑所有的读写请求也都发到这个MySQL上面，所以数据库的负载太高。如果把一个节点的数据库拆分成多个MySQL数据库，这样就可以有效的降低每个MySQL数据库的负载。</p><p><strong>垂直切分不能解决什么问题</strong></p><p>垂直切分不能解决的是缩表，比如说商品表无论划分给哪个数据库节点，商品表的记录还是那么多，不管你把数据库垂直拆分的有多细致，每个数据表里面的数据量是没有变化的。</p><p>MySQL单表记录超过2000万，读写性能会下降的很快，因此说垂直切分并不能起到缩表的效果。</p><h2 id="3-什么是水平切分？"><a href="#3-什么是水平切分？" class="headerlink" title="3. 什么是水平切分？"></a><strong>3. 什么是水平切分？</strong></h2><p>水平切分是按照某个字段的某种规则，把数据切分到多张数据表。一张数据表化整为零，拆分成多张数据表，这样就可以起到缩表的效果了。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-e8376833abf17549ed97853ab7f71b90_1440w.jpg" alt="img"></p><p>很多人，都会水平切分存在误解，以为水平切分出来的数据表必须保存在不同的MySQL节点上。其实水平切分出来的数据表也可以保存在一个MySQL节点上面。不是水平切分一定需要多个MySQL节点。为什么这么说呢？</p><p>许多人不知道MySQL自带一种数据分区的技术，可以把一张表的数据，按照特殊规则，切分存储在不同的目录下。如果我们给Linux主机挂载了多块硬盘，我们完全可以利用MySQL分区技术，把一张表的数据切分存储在多个硬盘上。这样就由原来一块硬盘有限的IO能力，升级成了多个磁盘增强型的IO。如果你感兴趣数据分区的具体效果，可以看<a href="https://link.zhihu.com/?target=https://coding.imooc.com/class/274.html?mc_marking=b9478d5f12bd4de1a83dc61bc224d99f&mc_channel=shouji">《MySQL数据库集群》</a>这门实战课。</p><p><strong>水平切分的用途</strong></p><p>水平切分可以把数据切分到多张数据表，可以起到缩表的作用。</p><p>但是也不是所有的数据表都要做水平切分。数据量较大的数据表才需要做数据切分，比如说电商系统中的，用户表、商品表、产品表、地址表、订单表等等。有些数据表就不需要切分，因为数据量不多，比如说品牌表、供货商表、仓库表，这些都是不需要切分的。</p><p><strong>水平切分的缺点</strong></p><p>不同数据表的切分规则并不一致，要根据实际业务来确定。所以我们在选择数据库中间件产品的时候，就要选择切分规则丰富的产品。常见的数据库中间件有：MyCat、Atlas、ProxySQL等等。有些人觉得MyCat是Java语言开发的，就怀疑MyCat运行效率。其实数据库中间件的作用相当于SQL语句的路由器。你家路由器硬件配置不怎么高，但是不影响你享用百兆宽带。MyCat也是一个道理，它仅仅是起到SQL语句转发的作用，并不会实际执行SQL语句。我推荐使用MyCat最主要的原因是它自带了非常多的数据切分规则，我们可以按照主键求模切分数据，可以按照主键范围切分数据，还可以按照日期切分数据等等。因此说，为了满足业务的需要，MyCat目前来说算是非常不错的中间件产品。</p><p>水平切分的另一个缺点就是扩容比较麻烦，日积月累，分片迟早有不够用的时候。这时候不是首先选择增加新的集群分片。因为一个MySQL分片，需要4~8个MySQL节点（最小规模），增加一个分片的投入成本是很高的。所以正确的做法是做冷热数据分离，定期对分片中的数据归档。把过期的业务数据，从分片中转移到归档库。目前来说数据压缩比最高的MySQL引擎是TokuDB，而且带着事物的写入速度是InnoDB引擎的6-14倍。用TokuDB作为归档数据库最适合不过。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-90c4e1014db42321db91c4cf330f1168_1440w.jpg" alt="img"></p><h2 id="4-到底是应该先水平还是先垂直"><a href="#4-到底是应该先水平还是先垂直" class="headerlink" title="4. 到底是应该先水平还是先垂直"></a>4. 到底是应该先水平还是先垂直</h2><p><strong>感觉各有道理</strong>。但我支持先垂直，然后水平</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAT2NlYW4mJlN0YXI=,size_10,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><p>数据库拆分原则：</p><ul><li>优先考虑缓存降低对数据库的读操作</li><li>再考虑读写分离，降低数据库写操作</li><li>最后开始数据拆分：<ul><li>先按照业务垂直拆分</li><li>在考虑水平拆分：先分库（设置数据路由规则，把数据分配到不同的库中）</li><li>最后在考虑分表，单表拆分到数据1000万以内。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-为什么要拆分数据库？&quot;&gt;&lt;a href=&quot;#1-为什么要拆分数据库？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要拆分数据库？&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 为什么要拆分数据库？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;单体项目在构建之初，&lt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>13.线程安全</title>
    <link href="https://leslieaibin.github.io/2021/10/24/Thread/13.%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://leslieaibin.github.io/2021/10/24/Thread/13.%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-24T02:15:42.000Z</published>
    <updated>2022-02-12T13:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4种解决线程安全问题的方式"><a href="#4种解决线程安全问题的方式" class="headerlink" title="4种解决线程安全问题的方式"></a>4种解决线程安全问题的方式</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>线程安全问题，在做高并发的系统的时候，是程序员经常需要考虑的地方。怎么有效的防止线程安全问题，保证数据的准确性？怎么合理的最大化的利用系统资源等，这些问题都需要充分的理解并运行线程。当然关于多线程的问题在面试的时候也是出现频率比较高的。下面就来学习一下吧！</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>先来看看什么是进程和线程？</p><p>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。就比如说，我们开发的一个单体项目，运行它，就会产生一个进程。</p><p>线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。在这里强调一点就是：计算机中的线程和应用程序中的线程不是同一个概念。</p><p>总之一句话描述就是：进程是资源分配的最小单位，线程是程序执行的最小单位。</p><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>什么是线程安全呢？什么样的情况会造成线程安全问题呢？怎么解决线程安全呢？这些问题都是在下文中所要讲述的。</p><p><strong>线程安全：</strong>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p><p>那什么时候会造成线程安全问题呢？当多个线程同时去访问一个对象时，就可能会出现线程安全问题。那么怎么解决呢？请往下看！</p><h3 id="解决线程安全"><a href="#解决线程安全" class="headerlink" title="解决线程安全"></a>解决线程安全</h3><p>在这里提供4种方法来解决线程安全问题，也是最常用的4种方法。前提是项目在一个服务器中，如果是分布式项目可能就会用到分布锁了，这个就放到后面文章来详谈了。</p><p>讲4种方法前，还是先来了解一下悲观锁和乐观锁吧！</p><p>悲观锁，顾名思义它是悲观的。讲得通俗点就是，认为自己在使用数据的时候，一定有别的线程来修改数据，因此在获取数据的时候先加锁，确保数据不会被线程修改。形象理解就是总觉得有刁民想害朕。</p><p>而乐观锁就比较乐观了，认为在使用数据时，不会有别的线程来修改数据，就不会加锁，只是在更新数据的时候去判断之前有没有别的线程来更新了数据。具体用法在下面讲解。</p><p>现在来看有那4种方法吧！</p><h3 id="1-使用synchronized关键字"><a href="#1-使用synchronized关键字" class="headerlink" title="1. 使用synchronized关键字"></a>1. 使用synchronized关键字</h3><p>一个表现为原生语法层面的互斥锁，它是一种悲观锁，使用它的时候我们一般需要一个监听对象 并且监听对象必须是唯一的，通常就是当前类的字节码对象。它是JVM级别的，不会造成死锁的情况。使用synchronized可以拿来修饰类，静态方法，普通方法和代码块。比如：Hashtable类就是使用synchronized来修饰方法的。put方法部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure the value is not null</span></span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure><p>而ConcurrentHashMap类中就是使用synchronized来锁代码块的。putVal方法部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">              V oldVal = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                          binCount = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>synchronized关键字底层实现主要是通过monitorenter 与monitorexit计数 ，如果计数器不为0，说明资源被占用，其他线程就不能访问了，但是可重入的除外。说到这，就来讲讲什么是可重入的。这里其实就是指的可重入锁：指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响，执行对象中所有同步方法不用再次获得锁。避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁。</p><p>其实在使用synchronized时，存在一个锁升级原理。它是指在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。锁升级的目的是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。可能你又会问什么是偏向锁？什么是轻量级锁？什么是重量级锁？这里就简单描述一下吧，能够帮你更好的理解synchronized。</p><p>偏向锁（无锁）：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后（线程的id会记录在对象的Mark Word中），消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。</p><p>轻量级锁（CAS）：就是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；轻量级锁的意图是在没有多线程竞争的情况下，通过CAS操作尝试将MarkWord更新为指向LockRecord的指针，减少了使用重量级锁的系统互斥量产生的性能消耗。</p><p>重量级锁：虚拟机使用CAS操作尝试将MarkWord更新为指向LockRecord的指针，如果更新成功表示线程就拥有该对象的锁；如果失败，会检查MarkWord是否指向当前线程的栈帧，如果是，表示当前线程已经拥有这个锁；如果不是，说明这个锁被其他线程抢占，此时膨胀为重量级锁。</p><h3 id="2-使用Lock接口下的实现类"><a href="#2-使用Lock接口下的实现类" class="headerlink" title="2. 使用Lock接口下的实现类"></a>2. 使用Lock接口下的实现类</h3><p>Lock是juc（java.util.concurrent）包下面的一个接口。常用的实现类就是ReentrantLock 类，它其实也是一种悲观锁。一种表现为 API 层面的互斥锁。通过lock() 和 unlock() 方法配合使用。因此也可以说是一种手动锁，使用比较灵活。但是使用这个锁时一定要注意要释放锁，不然就会造成死锁。一般配合try/finally 语句块来完成。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">5000</span>;</span><br><span class="line">      ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">               lock.lock();</span><br><span class="line">               <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName()+<span class="string">&quot;你的票号是&quot;</span>+num--);</span><br><span class="line">               &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">              &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                 lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比 synchronized，ReentrantLock 增加了一些高级功能，主要有以下 3 项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。</p><p>等待可中断是指：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</p><p>公平锁是指：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>锁绑定多个条件是指：一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition() 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="comment">//ConditionObject是Condition的实现类</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><h3 id="3-使用线程本地存储ThreadLocal"><a href="#3-使用线程本地存储ThreadLocal" class="headerlink" title="3. 使用线程本地存储ThreadLocal"></a>3. 使用线程本地存储ThreadLocal</h3><p>当多个线程操作同一个变量且互不干扰的场景下，可以使用ThreadLocal来解决。它会在每个线程中对该变量创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。通过set(T value)方法给线程的局部变量设置值；get()获取线程局部变量中的值。当给线程绑定一个 Object 内容后，只要线程不变,就可以随时取出；改变线程,就无法取出内容.。这里提供一个用法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">500</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                  ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line">                  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                        local.set(++a);   <span class="comment">//子线程对a的操作不会影响主线程中的a</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                              Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">&quot;子线程：&quot;</span>+local.get());</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            a = <span class="number">22</span>;</span><br><span class="line">            ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line">            local.set(a);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                  System.out.println(<span class="string">&quot;主线程：&quot;</span>+local.get());</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>ThreadLocal线程容器保存变量时，底层其实是通过ThreadLocalMap来实现的。它是以当前ThreadLocal变量为key ，要存的变量为value。获取的时候就是以当前ThreadLocal变量去找到对应的key，然后获取到对应的值。源码参考如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals; <span class="comment">//ThreadLocal.ThreadLocalMap threadLocals = null;Thread类中声明的</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">       t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>观察源码就会发现，其实每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p><p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p><p>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找即可。</p><h3 id="4-使用乐观锁机制"><a href="#4-使用乐观锁机制" class="headerlink" title="4. 使用乐观锁机制"></a>4. 使用乐观锁机制</h3><p>前面已经讲述了什么是乐观锁。这里就来描述哈在java开发中怎么使用的。</p><p>其实在表设计的时候，我们通常就需要往表里加一个version字段。每次查询时，查出带有version的数据记录，更新数据时，判断数据库里对应id的记录的version是否和查出的version相同。若相同，则更新数据并把版本号+1；若不同，则说明，该数据发生了并发，被别的线程使用了，进行递归操作，再次执行递归方法，直到成功更新数据为止。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4种解决线程安全问题的方式&quot;&gt;&lt;a href=&quot;#4种解决线程安全问题的方式&quot; class=&quot;headerlink&quot; title=&quot;4种解决线程安全问题的方式&quot;&gt;&lt;/a&gt;4种解决线程安全问题的方式&lt;/h1&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>7.CPU密集型和IO密集型</title>
    <link href="https://leslieaibin.github.io/2021/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8CIO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://leslieaibin.github.io/2021/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8CIO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-10-23T16:15:42.000Z</published>
    <updated>2022-02-18T00:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在看《Java并发编程的艺术》线程池这一块时，提到了要合理地配置线程池，要分析任务特性。任务的性质：CPU密集型、IO密集型和混合型。</p><h1 id="CPU密集型和IO密集型"><a href="#CPU密集型和IO密集型" class="headerlink" title="CPU密集型和IO密集型"></a>CPU密集型和IO密集型</h1><p>CPU密集型也是指计算密集型，大部分时间用来做计算逻辑判断等CPU动作的程序称为CPU密集型任务。该类型的任务需要进行大量的计算，主要消耗CPU资源。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p><p>IO密集型任务指任务需要执行大量的IO操作，涉及到网络、磁盘IO操作，对CPU消耗较少。</p><h1 id="和线程池配置的关系"><a href="#和线程池配置的关系" class="headerlink" title="和线程池配置的关系"></a>和线程池配置的关系</h1><p>CPU密集型任务应配置尽可能小的线程，如配置CPU数目+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*CPU数目。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在看《Java并发编程的艺术》线程池这一块时，提到了要合理地配置线程池，要分析任务特性。任务的性质：CPU密集型、IO密集型和混合型。&lt;/p&gt;
&lt;h1 id=&quot;CPU密集型和IO密集型&quot;&gt;&lt;a href=&quot;#CPU密集型和IO密集型&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>代理</title>
    <link href="https://leslieaibin.github.io/2021/10/12/java%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2021/10/12/java%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2021-10-12T01:15:42.000Z</published>
    <updated>2022-02-14T08:38:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-反射和动态代理"><a href="#Java-反射和动态代理" class="headerlink" title="Java 反射和动态代理"></a>Java 反射和动态代理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p><p><strong>通过反射机制，可以在运行时访问 Java 对象的属性，方法，构造方法等。</strong></p><h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>反射的主要应用场景有：</p><ul><li>  开发通用框架 - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li><li>  动态代理 - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</li><li>  注解 - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</li><li>  可扩展性功能 - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。</li></ul><h3 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h3><ul><li>  <strong>性能开销</strong> - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。</li><li>  <strong>破坏封装性</strong> - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li><li>  <strong>内部曝光</strong> - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。</li></ul><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-41136c8c767fb7469ddb9c446f662de8_b.jpg"></p><p>类加载的完整过程如下：</p><ol><li> 在编译时，Java 编译器编译好 .java 文件之后，在磁盘中产生 .class 文件。.class 文件是二进制文件，内容是只有 JVM 能够识别的机器码。</li><li> JVM 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 java.lang.Class 对象。</li><li> 加载结束后，JVM 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。</li></ol><h3 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h3><p>要想使用反射，首先需要获得待操作的类所对应的 Class 对象。<strong>Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构。</strong>所以，java.lang.Class 可以视为所有反射 API 的入口点。</p><p><strong>反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。</strong></p><p>举例来说，假如定义了以下代码：</p><pre><code>User user = new User(); </code></pre><p>步骤说明：</p><ol><li> JVM 加载方法的时候，遇到 new User()，JVM 会根据 User 的全限定名去加载 User.class 。</li><li> JVM 会去本地磁盘查找 User.class 文件并加载 JVM 内存中。</li><li> JVM 通过调用类加载器自动创建这个类对应的 Class 对象，并且存储在 JVM 的方法区。注意：一个类有且只有一个 Class 对象。</li></ol><h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><p><strong>java.lang.reflect 包</strong></p><p>Java 中的 java.lang.reflect 包提供了反射功能。java.lang.reflect 包中的类都没有 public 构造方法。</p><p>java.lang.reflect 包的核心接口和类如下：</p><ul><li>  Member 接口 - 反映关于单个成员(字段或方法)或构造函数的标识信息。</li><li>  Field 类 - 提供一个类的域的信息以及访问类的域的接口。</li><li>  Method 类 - 提供一个类的方法的信息以及访问类的方法的接口。</li><li>  Constructor 类 - 提供一个类的构造函数的信息以及访问类的构造函数的接口。</li><li>  Array 类 - 该类提供动态地生成和访问 JAVA 数组的方法。</li><li>  Modifier 类 - 提供了 static 方法和常量，对类和成员访问修饰符进行解码。</li><li>  Proxy 类 - 提供动态地生成代理类和类实例的静态方法。</li></ul><p><strong>获得 Class 对象</strong></p><p>获得 Class 的三种方法：</p><p>（1）<strong>使用 Class 类的 forName 静态方法</strong></p><p>示例：</p><pre><code>package io.github.dunwu.javacore.reflect;public class ReflectClassDemo01 &#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        Class c1 = Class.forName(&quot;io.github.dunwu.javacore.reflect.ReflectClassDemo01&quot;);        System.out.println(c1.getCanonicalName());        Class c2 = Class.forName(&quot;[D&quot;);        System.out.println(c2.getCanonicalName());        Class c3 = Class.forName(&quot;[[Ljava.lang.String;&quot;);        System.out.println(c3.getCanonicalName());    &#125;&#125;//Output://io.github.dunwu.javacore.reflect.ReflectClassDemo01//double[]//java.lang.String[][]</code></pre><p>使用类的完全限定名来反射对象的类。常见的应用场景为：在 JDBC 开发中常用此方法加载数据库驱动。</p><p>（2）<strong>直接获取某一个对象的 class</strong></p><p>示例：</p><pre><code>public class ReflectClassDemo02 &#123;    public static void main(String[] args) &#123;        Boolean b;        // Class c = b.getClass(); // 编译错误        Class c1 = Boolean.class;        System.out.println(c1.getCanonicalName());        Class c2 = java.io.PrintStream.class;        System.out.println(c2.getCanonicalName());        Class c3 = int[][][].class;        System.out.println(c3.getCanonicalName());    &#125;&#125;//Output://boolean//java.io.PrintStream//int[][][]</code></pre><p>（3）<strong>调用 Object 的 getClass 方法，</strong>示例：</p><p>Object 类中有 getClass 方法，因为所有类都继承 Object 类。从而调用 Object 类来获取</p><p>示例：</p><pre><code>package io.github.dunwu.javacore.reflect;import java.util.HashSet;import java.util.Set;public class ReflectClassDemo03 &#123;    enum E &#123;        A, B    &#125;    public static void main(String[] args) &#123;        Class c = &quot;foo&quot;.getClass();        System.out.println(c.getCanonicalName());        Class c2 = ReflectClassDemo03.E.A.getClass();        System.out.println(c2.getCanonicalName());        byte[] bytes = new byte[1024];        Class c3 = bytes.getClass();        System.out.println(c3.getCanonicalName());        Set&lt;String&gt; set = new HashSet&lt;&gt;();        Class c4 = set.getClass();        System.out.println(c4.getCanonicalName());    &#125;&#125;//Output://java.lang.String//io.github.dunwu.javacore.reflect.ReflectClassDemo.E//byte[]//java.util.HashSet</code></pre><p><strong>判断是否为某个类的实例</strong></p><p>判断是否为某个类的实例有两种方式：</p><ol><li> 用 instanceof 关键字</li><li> 用 Class 对象的 isInstance 方法（它是一个 Native 方法）</li></ol><p>示例：</p><pre><code>public class InstanceofDemo &#123;    public static void main(String[] args) &#123;        ArrayList arrayList = new ArrayList();        if (arrayList instanceof List) &#123;            System.out.println(&quot;ArrayList is List&quot;);        &#125;        if (List.class.isInstance(arrayList)) &#123;            System.out.println(&quot;ArrayList is List&quot;);        &#125;    &#125;&#125;//Output://ArrayList is List//ArrayList is List</code></pre><p><strong>创建实例</strong></p><p>通过反射来创建实例对象主要有两种方式：</p><ol><li> 用 Class 对象的 newInstance 方法。</li><li> 用 Constructor 对象的 newInstance 方法。</li></ol><p>示例：</p><pre><code>public class NewInstanceDemo &#123;    public static void main(String[] args)            throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;        Class&lt;?&gt; c1 = StringBuilder.class;        StringBuilder sb = (StringBuilder) c1.newInstance();        sb.append(&quot;aaa&quot;);        System.out.println(sb.toString());        //获取String所对应的Class对象        Class&lt;?&gt; c2 = String.class;        //获取String类带一个String参数的构造器        Constructor constructor = c2.getConstructor(String.class);        //根据构造器创建实例        String str2 = (String) constructor.newInstance(&quot;bbb&quot;);        System.out.println(str2);    &#125;&#125;//Output://aaa//bbb</code></pre><p><strong>Field</strong></p><p>Class 对象提供以下方法获取对象的成员（Field）：</p><ol><li> getFiled - 根据名称获取公有的（public）类成员。</li><li> getDeclaredField - 根据名称获取已声明的类成员。但不能得到其父类的类成员。</li><li> getFields - 获取所有公有的（public）类成员。</li><li> getDeclaredFields - 获取所有已声明的类成员。</li></ol><p>示例如下：</p><pre><code>public class ReflectFieldDemo &#123;    class FieldSpy&lt;T&gt; &#123;        public Boolean[][] b = &#123;&#123;false, false&#125;, &#123;true, true&#125;&#125;;        public String name = &quot;Alice&quot;;        public List&lt;Integer&gt; list;        public T val;    &#125;    public static void main(String[] args) throws NoSuchFieldException &#123;        Field f1 = FieldSpy.class.getField(&quot;b&quot;);        System.out.format(&quot;Type: %s%n&quot;, f1.getType());        Field f2 = FieldSpy.class.getField(&quot;name&quot;);        System.out.format(&quot;Type: %s%n&quot;, f2.getType());        Field f3 = FieldSpy.class.getField(&quot;list&quot;);        System.out.format(&quot;Type: %s%n&quot;, f3.getType());        Field f4 = FieldSpy.class.getField(&quot;val&quot;);        System.out.format(&quot;Type: %s%n&quot;, f4.getType());    &#125;&#125;//Output://Type: class [[Z//Type: class java.lang.String//Type: interface java.util.List//Type: class java.lang.Object</code></pre><p><strong>Method</strong></p><p>Class 对象提供以下方法获取对象的方法（Method）：</p><ul><li>  getMethod - 返回类或接口的特定方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li><li>  getDeclaredMethod - 返回类或接口的特定声明方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li><li>  getMethods - 返回类或接口的所有 public 方法，包括其父类的 public 方法。</li><li>  getDeclaredMethods - 返回类或接口声明的所有方法，包括 public、protected、默认（包）访问和 private 方法，但不包括继承的方法。</li></ul><p>获取一个 Method 对象后，可以用 invoke 方法来调用这个方法。</p><p>invoke 方法的原型为:</p><pre><code>public Object invoke(Object obj, Object... args)        throws IllegalAccessException, IllegalArgumentException,           InvocationTargetException</code></pre><p>示例：</p><pre><code>public class ReflectMethodDemo &#123;    public static void main(String[] args)            throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;        // 返回所有方法        Method[] methods1 = System.class.getDeclaredMethods();        System.out.println(&quot;System getDeclaredMethods 清单（数量 = &quot; + methods1.length + &quot;）：&quot;);        for (Method m : methods1) &#123;            System.out.println(m);        &#125;        // 返回所有 public 方法        Method[] methods2 = System.class.getMethods();        System.out.println(&quot;System getMethods 清单（数量 = &quot; + methods2.length + &quot;）：&quot;);        for (Method m : methods2) &#123;            System.out.println(m);        &#125;        // 利用 Method 的 invoke 方法调用 System.currentTimeMillis()        Method method = System.class.getMethod(&quot;currentTimeMillis&quot;);        System.out.println(method);        System.out.println(method.invoke(null));    &#125;&#125;</code></pre><p><strong>Constructor</strong></p><p>Class 对象提供以下方法获取对象的构造方法（Constructor）：</p><ul><li>  getConstructor - 返回类的特定 public 构造方法。参数为方法参数对应 Class 的对象。</li><li>  getDeclaredConstructor - 返回类的特定构造方法。参数为方法参数对应 Class 的对象。</li><li>  getConstructors - 返回类的所有 public 构造方法。</li><li>  getDeclaredConstructors - 返回类的所有构造方法。</li></ul><p>获取一个 Constructor 对象后，可以用 newInstance 方法来创建类实例。</p><p>示例：</p><pre><code>public class ReflectMethodConstructorDemo &#123;    public static void main(String[] args)            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;        Constructor&lt;?&gt;[] constructors1 = String.class.getDeclaredConstructors();        System.out.println(&quot;String getDeclaredConstructors 清单（数量 = &quot; + constructors1.length + &quot;）：&quot;);        for (Constructor c : constructors1) &#123;            System.out.println(c);        &#125;        Constructor&lt;?&gt;[] constructors2 = String.class.getConstructors();        System.out.println(&quot;String getConstructors 清单（数量 = &quot; + constructors2.length + &quot;）：&quot;);        for (Constructor c : constructors2) &#123;            System.out.println(c);        &#125;        System.out.println(&quot;====================&quot;);        Constructor constructor = String.class.getConstructor(String.class);        System.out.println(constructor);        String str = (String) constructor.newInstance(&quot;bbb&quot;);        System.out.println(str);    &#125;&#125;</code></pre><p><strong>Array</strong></p><p>数组在 Java 里是比较特殊的一种类型，它可以赋值给一个对象引用。下面我们看一看利用反射创建数组的例子：</p><pre><code>public class ReflectArrayDemo &#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.String&quot;);        Object array = Array.newInstance(cls, 25);        //往数组里添加内容        Array.set(array, 0, &quot;Scala&quot;);        Array.set(array, 1, &quot;Java&quot;);        Array.set(array, 2, &quot;Groovy&quot;);        Array.set(array, 3, &quot;Scala&quot;);        Array.set(array, 4, &quot;Clojure&quot;);        //获取某一项的内容        System.out.println(Array.get(array, 3));    &#125;&#125;//Output://Scala</code></pre><p>其中的 Array 类为 java.lang.reflect.Array 类。我们通过 Array.newInstance 创建数组对象，它的原型是：</p><pre><code>public static Object newInstance(Class&lt;?&gt; componentType, int length)    throws NegativeArraySizeException &#123;    return newArray(componentType, length);&#125;</code></pre><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是反射的一个非常重要的应用场景。动态代理常被用于一些 Java 框架中。例如 Spring 的 AOP ，Dubbo 的 SPI 接口，就是基于 Java 动态代理实现的。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>静态代理其实就是指设计模式中的代理模式。-<br>代理模式为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic4.zhimg.com/v2-e8162f682944cfd99112e7dea37f0387_b.jpg"></p><p><strong>Subject</strong> 定义了 RealSubject 和 Proxy 的公共接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy 。</p><pre><code>abstract class Subject &#123;    public abstract void Request();&#125;</code></pre><p><strong>RealSubject</strong> 定义 Proxy 所代表的真实实体。</p><pre><code>class RealSubject extends Subject &#123;    @Override        public void Request() &#123;        System.out.println(&quot;真实的请求&quot;);    &#125;&#125;</code></pre><p><strong>Proxy</strong> 保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。</p><pre><code>class Proxy extends Subject &#123;    private RealSubject real;    @Override        public void Request() &#123;        if (null == real) &#123;            real = new RealSubject();        &#125;        real.Request();    &#125;&#125;</code></pre><blockquote><p>说明：-<br>静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和 RealSubject 的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。</p></blockquote><h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><p>为了解决静态代理的问题，就有了创建动态代理的想法：</p><p>在运行状态中，需要代理的地方，根据 Subject 和 RealSubject，动态地创建一个 Proxy，用完之后，就会销毁，这样就可以避免了 Proxy 角色的 class 在系统中冗杂的问题了。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic4.zhimg.com/v2-126d7905882d5a27b0ff6efcaa0ff07b_b.jpg"></p><p>Java 动态代理基于经典代理模式，引入了一个 InvocationHandler，InvocationHandler 负责统一管理所有的方法调用。</p><p>动态代理步骤：</p><ol><li> 获取 RealSubject 上的所有接口列表；</li><li> 确定要生成的代理类的类名，默认为：com.sun.proxy.$ProxyXXXX；</li><li> 根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；</li><li> 将对应的字节码转换为对应的 class 对象；</li><li> 创建 InvocationHandler 实例 handler，用来处理 Proxy 所有方法调用；</li><li> Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。</li></ol><p>从上面可以看出，JDK 动态代理的实现是基于实现接口的方式，使得 Proxy 和 RealSubject 具有相同的功能。</p><p>但其实还有一种思路：通过继承。即：让 Proxy 继承 RealSubject，这样二者同样具有相同的功能，Proxy 还可以通过重写 RealSubject 中的方法，来实现多态。CGLIB 就是基于这种思路设计的。</p><p>在 Java 的动态代理机制中，有两个重要的类（接口），一个是 InvocationHandler 接口、另一个则是 Proxy 类，这一个类和一个接口是实现我们动态代理所必须用到的。</p><h3 id="InvocationHandler-接口"><a href="#InvocationHandler-接口" class="headerlink" title="InvocationHandler 接口"></a>InvocationHandler 接口</h3><p>InvocationHandler 接口定义：</p><pre><code>public interface InvocationHandler &#123;    public Object invoke(Object proxy, Method method, Object[] args)            throws Throwable;&#125;</code></pre><p>每一个动态代理类都必须要实现 InvocationHandler 这个接口，并且每个代理类的实例都关联到了一个 Handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 InvocationHandler 这个接口的 invoke 方法来进行调用。</p><p>我们来看看 InvocationHandler 这个接口的唯一一个方法 invoke 方法：</p><pre><code>Object invoke(Object proxy, Method method, Object[] args)throws Throwable </code></pre><p>参数说明：</p><ul><li>  proxy - 代理的真实对象。</li><li>  method - 所要调用真实对象的某个方法的 Method 对象</li><li>  args - 所要调用真实对象某个方法时接受的参数</li></ul><p>如果不是很明白，等下通过一个实例会对这几个参数进行更深的讲解。</p><h3 id="Proxy-类"><a href="#Proxy-类" class="headerlink" title="Proxy 类"></a>Proxy 类</h3><p>Proxy 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法：</p><pre><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)  throws IllegalArgumentException</code></pre><p>这个方法的作用就是得到一个动态的代理对象。</p><p>参数说明：</p><ul><li>  <strong>loader</strong> - 一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载。</li><li>  <strong>interfaces</strong> - 一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</li><li>  <strong>h</strong> - 一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上</li></ul><h3 id="动态代理实例"><a href="#动态代理实例" class="headerlink" title="动态代理实例"></a>动态代理实例</h3><p>上面的内容介绍完这两个接口(类)以后，我们来通过一个实例来看看我们的动态代理模式是什么样的：</p><p>首先我们定义了一个 Subject 类型的接口，为其声明了两个方法：</p><pre><code>public interface Subject &#123;    void hello(String str);    String bye();&#125;</code></pre><p>接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject 类：</p><pre><code>public class RealSubject implements Subject &#123;    @Override        public void hello(String str) &#123;        System.out.println(&quot;Hello  &quot; + str);    &#125;    @Override        public String bye() &#123;        System.out.println(&quot;Goodbye&quot;);        return &quot;Over&quot;;    &#125;&#125;</code></pre><p>下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外：</p><pre><code>public class InvocationHandlerDemo implements InvocationHandler &#123;    // 这个就是我们要代理的真实对象    private Object subject;    // 构造方法，给我们要代理的真实对象赋初值    public InvocationHandlerDemo(Object subject) &#123;        this.subject = subject;    &#125;    @Override        public Object invoke(Object object, Method method, Object[] args)            throws Throwable &#123;        // 在代理真实对象前我们可以添加一些自己的操作        System.out.println(&quot;Before method&quot;);        System.out.println(&quot;Call Method: &quot; + method);        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用        Object obj = method.invoke(subject, args);        // 在代理真实对象后我们也可以添加一些自己的操作        System.out.println(&quot;After method&quot;);        System.out.println();        return obj;    &#125;&#125;</code></pre><p>最后，来看看我们的 Client 类：</p><pre><code>public class Client &#123;    public static void main(String[] args) &#123;        // 我们要代理的真实对象        Subject realSubject = new RealSubject();        // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的        InvocationHandler handler = new InvocationHandlerDemo(realSubject);        /*         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上         */        Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject                        .getClass().getInterfaces(), handler);        System.out.println(subject.getClass().getName());        subject.hello(&quot;World&quot;);        String result = subject.bye();        System.out.println(&quot;Result is: &quot; + result);    &#125;&#125;</code></pre><p>我们先来看看控制台的输出：</p><pre><code>com.sun.proxy.$Proxy0Before methodCall Method: public abstract void io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)Hello  WorldAfter methodBefore methodCall Method: public abstract java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()GoodbyeAfter methodResult is: Over</code></pre><p>我们首先来看看 com.sun.proxy.$Proxy0 这东西，我们看到，这个东西是由 System.out.println(subject.getClass().getName()); 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？</p><pre><code>Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject                .getClass().getInterfaces(), handler);</code></pre><p>可能我以为返回的这个代理对象会是 Subject 类型的对象，或者是 InvocationHandler 的对象，结果却不是，首先我们解释一下<strong>为什么我们这里可以将其转化为 Subject 类型的对象</strong>？</p><p>原因就是：在 newProxyInstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是 Subject 类型，所以就可以将其转化为 Subject 类型了。</p><p><strong>同时我们一定要记住，通过 Proxy.newProxyInstance 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy 为中，最后一个数字表示对象的标号。</strong></p><p>接着我们来看看这两句</p><pre><code>subject.hello(&quot;World&quot;); String result = subject.bye();</code></pre><p>这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的 invoke 方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject 类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的 invoke 方法去执行。</p><p>我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：</p><pre><code>public abstract void io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)public abstract java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()</code></pre><p>正好就是我们的 Subject 接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的 invoke 方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>反射应用</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic2.zhimg.com/v2-2ce2db221bf3a57b6b45a11e2967b14d_b.jpg"></p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic3.zhimg.com/v2-9bd2394aa44f773e90a161e23f0797c2_b.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-反射和动态代理&quot;&gt;&lt;a href=&quot;#Java-反射和动态代理&quot; class=&quot;headerlink&quot; title=&quot;Java 反射和动态代理&quot;&gt;&lt;/a&gt;Java 反射和动态代理&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
</feed>
