<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Ai</title>
  
  <subtitle>春暖花开去见你</subtitle>
  <link href="https://leslieaibin.github.io/atom.xml" rel="self"/>
  
  <link href="https://leslieaibin.github.io/"/>
  <updated>2022-07-21T15:33:36.974Z</updated>
  <id>https://leslieaibin.github.io/</id>
  
  <author>
    <name>Leslie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>11.虚拟内存</title>
    <link href="https://leslieaibin.github.io/2022/07/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <id>https://leslieaibin.github.io/2022/07/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</id>
    <published>2022-07-17T16:15:42.000Z</published>
    <updated>2022-07-21T15:33:36.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是虚拟内存？解决了什么问题？"><a href="#1-什么是虚拟内存？解决了什么问题？" class="headerlink" title="1. 什么是虚拟内存？解决了什么问题？"></a><strong>1. 什么是虚拟内存？解决了什么问题？</strong></h3><p>虚拟内存是操作系统内存管理的一种技术，每个进程启动时，操作系统会提供一个独立的虚拟地址空间，这个地址空间是连续的，进程可以很方便的访问内存，这里的内存指的是访问虚拟内存。<strong>虚拟内存的目的，一是方便进程进行内存的访问，二是可以使有限的物理内存运行一个比它大很多的程序。</strong></p><p>虚拟内存的基本思想：每个程序拥有自己的地址空间，这个空间被分割成很多块，每块称为一页，每一页地址都是连续的地址范围。这些页被映射到物理内存，但不要求是连续的物理内存，也不需要所有的页都映射到物理内存，而是按需分配，在程序片段需要分配内存时由硬件执行映射(通常是 MMU)，调入内存中执行。</p><h3 id="2-说说分页和分段的机制？"><a href="#2-说说分页和分段的机制？" class="headerlink" title="2. 说说分页和分段的机制？"></a><strong>2. 说说分页和分段的机制？</strong></h3><p>分页是实现虚拟内存的技术，虚拟内存按照固定的大小分为页面，物理内存也会按照固定的大小分成页框，页面和页框大小通常是一样的，一般是 4KB，页面和页框可以实现一对一的映射。<strong>分页是一维的，主要是为了获得更大的线性地址空间。</strong>但是一个地址空间可能存在很多个表，表的数据大小是动态增长的，由于多个表都在一维空间中，有可能导致一个表的数据覆盖了另一个表。</p><p>分段是把虚拟内存划分为多个独立的地址空间，每个地址空间可以动态增长，互不影响。每个段可以单独进行控制，有助于保护和共享。</p><h3 id="3-页表的作用？为什么引入多级页表？"><a href="#3-页表的作用？为什么引入多级页表？" class="headerlink" title="3. 页表的作用？为什么引入多级页表？"></a><strong>3. 页表的作用？为什么引入多级页表？</strong></h3><p>页表实现了虚拟内存到物理内存的映射，当访问一个虚拟内存页面时，页面的虚拟地址将作为一个索引指向页表，如果页表中存在对应物理内存的映射，则直接返回物理内存的地址，否则将引发一个缺页异常，从而陷入到内核中分配物理内存，返回对应的物理地址，然后更新页表。</p><p>为了加快虚拟地址到物理地址的转换，多数系统会引入一个转换检测缓冲区（TLB）的设备，通常又称为<strong>快表</strong>，当请求访问一个虚拟地址时，处理器检查是否缓存了该虚拟地址的映射，如果命中则直接返回物理地址，否则就通过页表搜索对应的物理地址。</p><p>由于虚拟内存通常比较大(32 位系统通常是 4G)，要实现整个地址空间的映射，需要非常大的页表。解决的办法是引入多级页表，只将那些用到的页面装载进来，因此，多级页表可以大大节约地址转换所需要的的空间。</p><h3 id="4-页面置换算法有哪几种？"><a href="#4-页面置换算法有哪几种？" class="headerlink" title="4. 页面置换算法有哪几种？"></a><strong>4. 页面置换算法有哪几种？</strong></h3><p>当访问的页面不在内存中时，会发生一个缺页异常，操作系统必须将该页换出内存，如果此时内存已满，则操作系统必须将其中一个页面换出，放到 swap 交换区中，为当前访问的页面腾出空间，这个过程称为页面置换。操作系统提供了多种页面置换算法：</p><p><strong>最优页面置换算法</strong></p><p>选择一个将来最长时间不会被访问的页面换出。这样可以保证将来最低的缺页率。这是一种理论上的算法，因为无法知道哪个页面是将来最长时间都不会被访问的。</p><p><strong>最近未使用页面置换算法 (NRU)</strong></p><p>为每个页面设两个状态位：被访问时设置为 R=1 位，页面被修改时，设置为 M=1 位。当启动一个进程时，所有页面都被初始化为 R=0，M=0。其中 R 位会被定时的清 0，以此区分最近被访问的页面和没有被访问的页面。</p><p>于是所有页面可以分为以下 4 类：</p><p>0 类：R=0，M=0；</p><p>1 类：R=0，M=1；</p><p>2 类：R=1，M=0；</p><p>3 类：R=1，M=1；</p><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出（挑选优先级：1 类 &gt; 2 类 &gt; 3 类）。</p><p><strong>最近最少未使用（LRU）页面置换算法</strong></p><p>在内存中维护一个所有页面的单链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><p><strong>先进先出（FIFO）页面置换算法</strong></p><p>维护一个链表，最先进入的页面放在表头，最后进入的页面放在表尾，当缺页中断发生时，直接淘汰表头的页面，并把新的页面放在表尾。</p><p>这种算法有可能置换掉经常访问的页面，导致缺页率升高。</p><p><strong>第二次机会页面置换算法</strong></p><p>对 FIFO 算法做一个修改：取出表头的页面时，检查该页面的 R 位，如果是 1 表示是最近有访问的，将其清 0，然后放入表尾，然后继续检查下一个表头的页面，直到遇到一个 R 位为 0 的页面，将其换出。</p><p><strong>时钟页面置换算法</strong></p><p>与上一个算法类似，只不过单链表改成了环形链表，形成一个时钟，移动的也不是页面，而是中间的表针。检查页面逻辑类似，如果该页面 R 为 0，则直接置换该页面，否则将该 R 位清 0，然后表针向前移动。</p><h3 id="5-内存是如何分配的"><a href="#5-内存是如何分配的" class="headerlink" title="5. 内存是如何分配的"></a><strong>5. 内存是如何分配的</strong></h3><p>Linux 分配物理内存的主要机制是页面分配机制（页分配器），使用了著名的伙伴算法，主要用来分配页大小的整数倍的内存(4n KB)。如果是小于页大小的内存分配，通常使用 slab 管理器。通过 slab 分配的内存通常会缓存起来，方便下次使用。</p><h3 id="6-内存是如何回收的？"><a href="#6-内存是如何回收的？" class="headerlink" title="6. 内存是如何回收的？"></a><strong>6. 内存是如何回收的？</strong></h3><p>应用程序用完内存后，可以调用 free() 释放内存，或调用 unmap() 取消内存映射，归还系统。</p><p>在内存紧张时，会通过一系列机制来回收内存，如以下三种方式：</p><ul><li>  回收缓存。主要是页缓存。</li><li>  回收不常访问的页面。使用页面置换算法，把不常用的页面放到交换区中。</li><li>  通过 OOM 杀死占用大量内存的进程，释放内存。</li></ul><p>虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度足够快并且容量足够大的存储<br>虚拟内存可以为进程提供独立的内存空间并引入多层的页表结构将虚拟内存翻译为物理内存，进程之间可以互相共享物理内存减少开销，也能简化程序的链接、装载以及内存分配过程<br>虚拟内存可以控制进程对物理内存的访问、隔离不同进程的访问权限，提高系统的安全性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-什么是虚拟内存？解决了什么问题？&quot;&gt;&lt;a href=&quot;#1-什么是虚拟内存？解决了什么问题？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是虚拟内存？解决了什么问题？&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 什么是虚拟内存？解决了什么问题？&lt;/st</summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>10.进程间通信</title>
    <link href="https://leslieaibin.github.io/2022/07/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://leslieaibin.github.io/2022/07/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2022-07-10T16:15:42.000Z</published>
    <updated>2022-07-12T12:26:02.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程间8种通信方式详解"><a href="#进程间8种通信方式详解" class="headerlink" title="进程间8种通信方式详解"></a>进程间8种通信方式详解</h1><p>进程通信：</p><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。</p><h2 id="1-匿名管道通信"><a href="#1-匿名管道通信" class="headerlink" title="1 匿名管道通信"></a>1 匿名管道通信</h2><hr><p>匿名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><pre><code>// 需要的头文件#include &lt;unistd.h&gt;// 通过pipe()函数来创建匿名管道// 返回值：成功返回0，失败返回-1// fd参数返回两个文件描述符// fd[0]指向管道的读端，fd[1]指向管道的写端// fd[1]的输出是fd[0]的输入。int pipe (int fd[2]);</code></pre><p>通过匿名管道实现进程间通信的步骤如下：</p><ul><li>  父进程创建管道，得到两个⽂件描述符指向管道的两端</li><li>  父进程fork出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。</li><li>  父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。</li></ul><p>详细可参考文章：<a href="https://blog.csdn.net/skyroben/article/details/71513385">进程间的通信方式——pipe（管道）</a></p><h2 id="2-高级管道通信"><a href="#2-高级管道通信" class="headerlink" title="2 高级管道通信"></a>2 高级管道通信</h2><hr><p>高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p><h2 id="3-有名管道通信"><a href="#3-有名管道通信" class="headerlink" title="3 有名管道通信"></a>3 有名管道通信</h2><hr><p>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><h2 id="4-消息队列通信"><a href="#4-消息队列通信" class="headerlink" title="4 消息队列通信"></a>4 消息队列通信</h2><hr><p>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><h2 id="5-信号量通信"><a href="#5-信号量通信" class="headerlink" title="5 信号量通信"></a>5 信号量通信</h2><hr><p>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><h2 id="6-信号"><a href="#6-信号" class="headerlink" title="6 信号"></a>6 信号</h2><hr><p>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><h2 id="7-共享内存通信"><a href="#7-共享内存通信" class="headerlink" title="7 共享内存通信"></a>7 共享内存通信</h2><hr><p>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p><h2 id="8-套接字通信"><a href="#8-套接字通信" class="headerlink" title="8 套接字通信"></a>8 套接字通信</h2><hr><p>套接字( socket ) ： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p><h3 id="8-1命名socket"><a href="#8-1命名socket" class="headerlink" title="8.1命名socket"></a>8.1命名socket</h3><p>SOCK_STREAM 式本地套接字的通信双方均需要具有本地地址，其中<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>端的本地地址需要明确指定，指定方法是使用 struct sockaddr_un 类型的变量。</p><h3 id="8-2-绑定"><a href="#8-2-绑定" class="headerlink" title="8.2 绑定"></a>8.2 绑定</h3><p>SOCK_STREAM 式本地套接字的通信双方均需要具有本地地址，其中服务器端的本地地址需要明确指定，指定方法是使用 struct sockaddr_un 类型的变量，将相应字段赋值，再将其绑定在创建的服务器套接字上，绑定要使用 bind 系统调用，其原形如下：</p><pre><code>int bind(int socket, const struct sockaddr *address, size_t address_len);</code></pre><p>其中 socket表示服务器端的套接字描述符，address 表示需要绑定的本地地址，是一个 struct sockaddr_un 类型的变量，address_len 表示该本地地址的字节长度。</p><h3 id="8-3-监听"><a href="#8-3-监听" class="headerlink" title="8.3 监听"></a>8.3 监听</h3><p>服务器端套接字创建完毕并赋予本地地址值（名称，本例中为Server Socket）后，需要进行监听，等待客户端连接并处理请求，监听使用 listen 系统调用，接受客户端连接使用accept系统调用，它们的原形如下：</p><pre><code>int listen(int socket, int backlog);int accept(int socket, struct sockaddr *address, size_t *address_len);</code></pre><p>其中 socket 表示服务器端的套接字描述符；backlog 表示排队连接队列的长度（若有多个客户端同时连接，则需要进行排队）；address 表示当前连接客户端的本地地址，该参数为输出参数，是客户端传递过来的关于自身的信息；address_len 表示当前连接客户端本地地址的字节长度，这个参数既是输入参数，又是输出参数。</p><h3 id="8-4-连接服务器"><a href="#8-4-连接服务器" class="headerlink" title="8.4 连接服务器"></a>8.4 连接服务器</h3><p>客户端套接字创建完毕并赋予本地地址值后，需要连接到服务器端进行通信，让服务器端为其提供处理服务。</p><p>对于SOCK_STREAM类型的流式套接字，需要客户端与服务器之间进行连接方可使用。连接要使用 connect 系统调用，其原形为</p><pre><code>int connect(int socket, const struct sockaddr *address, size_t address_len);</code></pre><p>其中socket为客户端的套接字描述符，address表示当前客户端的本地地址，是一个 struct sockaddr_un 类型的变量，address_len 表示本地地址的字节长度。实现连接的代码如下：</p><pre><code>connect(client_sockfd, (struct sockaddr*)&amp;client_address, sizeof(client_address));</code></pre><h3 id="8-5-相互发送接收数据"><a href="#8-5-相互发送接收数据" class="headerlink" title="8.5 相互发送接收数据"></a>8.5 相互发送接收数据</h3><p>无论客户端还是服务器，都要和对方进行数据上的交互，这种交互也正是我们进程通信的主题。一个进程扮演客户端的角色，另外一个进程扮演服务器的角色，两个进程之间相互发送接收数据，这就是基于本地套接字的进程通信。发送和接收数据要使用 write 和 read 系统调用，它们的原形为：</p><pre><code>int read(int socket, char *buffer, size_t len);int write(int socket, char *buffer, size_t len);</code></pre><p>其中 socket 为套接字描述符；len 为需要发送或需要接收的数据长度；</p><p>对于 read 系统调用，buffer 是用来存放接收数据的缓冲区，即接收来的数据存入其中，是一个输出参数；</p><p>对于 write 系统调用，buffer 用来存放需要发送出去的数据，即 buffer 内的数据被发送出去，是一个输入参数；返回值为已经发送或接收的数据长度。</p><h3 id="8-6-断开连接"><a href="#8-6-断开连接" class="headerlink" title="8.6 断开连接"></a>8.6 断开连接</h3><p>交互完成后，需要将连接断开以节省资源，使用close系统调用，其原形为：</p><pre><code>int close(int socket);</code></pre><p>参考资料：</p><ul><li>  <a href="https://blog.csdn.net/skyroben/article/details/71513385">进程间的通信方式——pipe（管道）</a></li><li>  <a href="https://blog.csdn.net/violet_echo_0908/article/details/49539593">Linux下socket编程实现客户机服务器通信的例子</a></li><li>  <a href="https://blog.csdn.net/violet_echo_0908/article/details/49670901">Linux进程间套接字（Socket）通信</a></li><li>  <a href="https://blog.csdn.net/violet_echo_0908/article/details/50277537">基于Internet的Linux客户机/服务器系统通讯设计与实现</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程间8种通信方式详解&quot;&gt;&lt;a href=&quot;#进程间8种通信方式详解&quot; class=&quot;headerlink&quot; title=&quot;进程间8种通信方式详解&quot;&gt;&lt;/a&gt;进程间8种通信方式详解&lt;/h1&gt;&lt;p&gt;进程通信：&lt;/p&gt;
&lt;p&gt;每个进程各自有不同的用户地址空间,任何一个</summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>https保证传输安全</title>
    <link href="https://leslieaibin.github.io/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/12.https%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8/"/>
    <id>https://leslieaibin.github.io/2022/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/12.https%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8/</id>
    <published>2022-07-08T01:15:42.000Z</published>
    <updated>2022-07-22T01:48:22.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-HTTP存在的问题"><a href="#1-HTTP存在的问题" class="headerlink" title="1. HTTP存在的问题"></a>1. HTTP存在的问题</h1><p>传统的不使用SSL/TLS的HTTP协议，是不加密的通信。无论是客户端发送给服务端的请求体，还是服务端响应给客户端的响应体，都是明文传输的，这会带来几个问题：</p><p><strong>1. 窃听</strong> 第三方劫持请求后可以获取通信内容。对于一些敏感数据，这是不被允许的。</p><p><strong>2. 篡改</strong> 第三方劫持请求后可以篡改通信内容。例如银行系统中，张三本来要给李四转账，第三方劫持请求后篡改了请求数据，将收款方改为自己，导致用户资金流失。</p><p><strong>3. 冒充</strong> 第三方可以冒充客户端发送数据。由于是明文传输，没有「加签/验签」操作，服务端无法保证请求来源的合法性。</p><p>正是因为这些问题，HTTP通信存在巨大的安全隐患，于是HTTPS出现了。 本文将一步步深入，看看HTTPS是如何解决这些问题的。</p><hr><h1 id="2-SSL-TLS"><a href="#2-SSL-TLS" class="headerlink" title="2. SSL/TLS"></a>2. SSL/TLS</h1><p>在介绍HTTPS之前，必须先了解SSL/TLS协议，因为HTTPS是构建在此基础之上的，了解了SSL/TLS基本也就清楚HTTPS的工作原理了。</p><p>SSL（Secure Sockets Layer）译为「安全套接字协议」，TLS（Transport Layer Security）译为「传输层安全性协议」。</p><p>简单回顾一下它们的发展历史吧：</p><ul><li>1994年，网景公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。</li><li>1995年，网景公司发布SSL 2.0版，但很快发现有严重漏洞。</li><li>1996年，SSL 3.0版问世，得到大规模应用。</li><li>1999年，互联网标准化组织ISOC接替网景公司，发布了SSL的升级版TLS 1.0版。</li><li>2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。</li></ul><p>SSL/TLS协议处于「传输层」和「应用层」之间，主要作用是对网络连接进行加解密，如下图： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc524914f0b3438883517c77f8fdeca2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><h2 id="2-1-防窃听：加密"><a href="#2-1-防窃听：加密" class="headerlink" title="2.1 防窃听：加密"></a>2.1 防窃听：加密</h2><p>先来看看第一个问题：窃听。既然明文传输可以被第三方窃听数据，那么改为加密传输不就行了吗？ 方向是对的，但是如何加密才能保证数据的安全呢？</p><h2 id="2-1-1-对称加密"><a href="#2-1-1-对称加密" class="headerlink" title="2.1.1 对称加密"></a>2.1.1 对称加密</h2><blockquote><p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。</p></blockquote><p>例如DES就是一种对称加密算法，甲乙双方约定一个密钥「Key」，双方发送数据前都用该密钥对数据进行加密传输，收到数据后再解密成明文即可。这种方式，只要保证密钥不被泄漏，理论上也是安全的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61c62256ba4949b298067a2276b1885e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><p>但是这会带来一个新的问题：<strong>密钥如何保存？</strong></p><p>对于PC端来说，浏览器页面是明文的，肯定不能存储密钥。对于iOS/Android来说，即使把密钥藏在安装包的某个位置，也很容易被第三方拆包破解。</p><p>既然客户端保存不靠谱，那么密钥只在服务端保存，客户端去向服务端拿密钥是否可行？</p><p>依然不可行，服务端要怎么把密钥给你呢？明文肯定不行，如果要加密，又要用到密钥B，密钥B的传输又要用到密钥C，如此循环，无解。</p><h2 id="2-1-2-非对称加密"><a href="#2-1-2-非对称加密" class="headerlink" title="2.1.2 非对称加密"></a>2.1.2 非对称加密</h2><blockquote><p>非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p></blockquote><p>甲乙双方各有一套自己的密钥对，互相公开彼此的公钥，当甲方要发送数据给乙方时，用乙方公钥加密，这样密文就只有乙方自己能解开了，就算请求被劫持，第三方拿到了数据，由于没有乙方的私钥，也无法解密，这样就保证了数据被窃听。</p><p><strong>单向非对称加密</strong> 绝大多数互联网网站对外是完全公开的，所有人都可以访问，服务端没必要验证所有客户端的合法性，只有客户端需要验证服务端的合法性。例如用户在访问电商网站时，必须确保不是钓鱼网站，以防资金损失。</p><p>这种情况下，只需要单向加密即可。服务端发送给客户端的一般不会有敏感信息，明文传输即可。但是客户端发送给服务端的就很有可能是敏感信息，例如用户修改密码，这时就必须加密传输了。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7742e77bfb8d47748b8a08d28329a337~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><p><strong>双向非对称加密</strong> 有时，服务端也需要验证客户端的合法性，例如银行系统。由于涉及到金钱，因此系统必须设计的足够安全。除了客户端发送给服务端的数据是加密的，服务端发送给客户端的数据也必须加密。</p><p>怎么做的呢？一般银行会给用户一个U盘，里面存储的就是一套密钥对，客户端告诉服务端自己的公钥，服务端根据公钥加密后再传输给客户端。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32e208f160c441b98493264a1cbd934a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><h2 id="2-2-防篡改：加签"><a href="#2-2-防篡改：加签" class="headerlink" title="2.2 防篡改：加签"></a>2.2 防篡改：加签</h2><p>通过非对称加密的密文传输，可以防止数据被窃听，但是如果存在这种场景呢？</p><p>张三登陆银行系统，要给李四转一笔钱，数据通过服务端的公钥PubB加密传输，但是第三方劫持了这个请求，篡改了报文数据，写入的是「给王五转钱」，因为服务端的公钥是公开的，谁都能拿到，因此第三方也可以正常加密传输，服务端正常解密后进行了错误的操作，导致用户资金流失。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/050642b7e2084bb0a6fd8122e071f06c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><p>对于涉及到资金的操作，服务端必须要验证数据的合法性，确保数据没有被篡改，这就需要客户端对数据进行加签了。</p><p>非对称加密除了可以「公钥加密，私钥解密」外，还可以「私钥加签，公钥验签」。</p><p>银行给用户一个U盘，里面有一套密钥对。客户端在发送转账请求前，先对请求体加签，得到签名「sign」，然后再用服务端公钥加密，得到密文「data」，客户端将签名和密文一起发送给服务端，服务端解密后，还需要用客户端的公钥对「sign」进行验签，只有验签通过才能进行后续操作，否则就是非法请求了。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f166792c0840da965c9d2c2654cb98~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"> 这样，即使请求被第三方劫持了，第三方可以篡改数据，但是签名它改不了，服务端解密后会发现数据和「sign」对不上，说明数据是被篡改过的。</p><h2 id="2-3-防冒充：证书"><a href="#2-3-防冒充：证书" class="headerlink" title="2.3 防冒充：证书"></a>2.3 防冒充：证书</h2><p>通过加密防止数据被窃听，通过加签防止数据被篡改，现在看来好像已经很安全了，但是别忘了，有个前提是：公钥的传输是安全的。不幸的是，公钥的安全传输很难保证。</p><p><strong>中间人攻击</strong> 假设存在这样一种场景，客户端和服务端想互换公钥，但是请求都被一个中间人劫持了，结果就是：服务端和客户端以为是和双方互换公钥了，结果是客户端和服务端都和中间人互换公钥了。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a9bad2d65848239e935ab66166eef8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"> 一旦出现这种问题就非常严重，前面讲到的加密解密、加签验签都失效了。客户端以为中间人就是服务端，服务端以为中间人就是客户端，双方以为是在和对方通信，其实都是在和中间人通信，中间人可以随意的窃听和篡改数据。</p><p>这个问题之所以会出现，就是因为公钥的传输是不安全的。客户端和服务端之间互换公钥时，如何确保公钥就是对方发出的，没有被篡改过呢？？？</p><h3 id="2-3-1-数字证书与认证中心"><a href="#2-3-1-数字证书与认证中心" class="headerlink" title="2.3.1 数字证书与认证中心"></a>2.3.1 数字证书与认证中心</h3><p>在之前的基础上，引入一个中间角色：证书认证中心CA。当服务端要把公钥发送给客户端时，不是直接发送公钥，而是先把公钥发送给CA，CA根据公钥生成一份「证书」给到服务端，服务端将证书给客户端。客户端拿到证书后去CA验证证书的合法性，确保证书是服务端下发的。</p><p>CA就类似于「公证处」，也是一台服务器，它自己本身也有一套密钥对。它的工作就是根据服务端的公钥生成证书，然后帮助客户端来验证证书的合法性。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10a0699adf394f8aba2f570a67b8c822~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><h3 id="2-3-2-CA被冒充怎么办？"><a href="#2-3-2-CA被冒充怎么办？" class="headerlink" title="2.3.2 CA被冒充怎么办？"></a>2.3.2 CA被冒充怎么办？</h3><p>引入CA可以保证公钥的传输安全，但是有一个前提，客户端和服务端是信任CA的，也就是说CA必须是安全可信任的，如果CA被冒充，就又会出现上面的问题。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/413c90b77a584b16a492759c372f75b0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"> 基于这个问题，就引入了「根证书」和「CA信任链」的概念。</p><p>要让客户端和服务端信任CA，其实CA也面临着同样的问题，那就是：如何保证CA的公钥是安全不被篡改的？答案也是一样的，就是给CA也颁发证书，那这个证书由谁来颁发呢？自然是CA的上一级CA了。CA的上一级CA如何保证安全？那就CA的上一级CA的上一级CA给它颁发证书了。最终就会形成一个证书信用链，如下： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdab72d1f973471fbbbb11fbc926cfc8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"> 客户端要想验证服务器的C3证书是否合法，会跑去CA2验证，要验证CA2就去CA1验证，以此类推。对于根证书，是没法验证的，只能无条件相信。因为Root CA都是国际上公认的机构，一般用户的操作系统或浏览器在发布时，就会在里面嵌入这些机构的Root证书。</p><p>如下是百度官网的证书，点击浏览器地址栏旁边的锁标识就能看到了。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85ad02c959154c4c9338bea115583749~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><h2 id="2-4-SSL-TLS-四次握手"><a href="#2-4-SSL-TLS-四次握手" class="headerlink" title="2.4 SSL/TLS 四次握手"></a>2.4 SSL/TLS 四次握手</h2><p>了解了底层的实现，加密、加签、证书等概念后，再来看SSL/TLS协议就很容易理解了。SSL/TLS需要四次握手的过程：</p><ol><li>客户端向服务端所有证书。</li><li>服务端发送证书。</li><li>客户端验证证书，提取公钥，发送对称加密的密钥。</li><li>服务端收到密钥，响应OK。</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c3d8bf5d7694215a9b552927355ae34~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><h1 id="3-再看HTTPS"><a href="#3-再看HTTPS" class="headerlink" title="3. 再看HTTPS"></a>3. 再看HTTPS</h1><p>了解SSL/TLS，再回过头来看HTTPS就很简单了，HTTPS=HTTP+SSL/TLS。</p><p>使用HTTPS进行通信时，先是建立传输层TCP的连接，完成三次握手，然后再是SSL/TLS协议的四次握手，双方协商出对称加密的密钥，之后的通信数据会利用该密钥进行加密传输。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6ea1e26a955433abe3d86c446ef0a71~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"> HTTP1.1开始支持长连接了，只要连接不关闭，七次握手只需要执行一次，性能损耗不会太大，而且数据传输采用的是对称加密，相比于非对称加密，性能损耗也小得多。因此HTTPS相比于HTTP，性能会有一定影响，但不会太大，相比之下，数据传输安全显得更加重要！</p><h3 id="HTTPS使用对称加密和非对称加密结合"><a href="#HTTPS使用对称加密和非对称加密结合" class="headerlink" title="HTTPS使用对称加密和非对称加密结合"></a>HTTPS使用对称加密和非对称加密结合</h3><p>传输数据阶段依然使用对称加密，但是对称加密的秘钥我们采用非对称加密传输。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000022950455.png" alt="HTTPS加密"></p><ul><li>浏览器向服务器发送client_random和加密方法列表。</li><li>服务器接收到，返回server_random、加密方法以及公钥。</li><li>浏览器接收，接着生成另一个随机数pre_master, 并且用公钥加密，传给服务器。(重点操作！)</li><li>服务器用私钥解密这个被加密后的pre_master。</li></ul><p>到此为止，服务器和浏览器就有了相同的 <code>client_random</code>、<code>server_random</code> 和 <code>pre_master</code>, 然后服务器和浏览器会使用这三组随机数生成对称秘钥。有了对称秘钥之后，双方就可以使用对称加密的方式来传输数据了。</p><h2 id="CA-数字证书"><a href="#CA-数字证书" class="headerlink" title="CA (数字证书)"></a>CA (数字证书)</h2><p>使用对称和非对称混合的方式，实现了数据的加密传输。但是这种仍然存在一个问题，服务器可能是被黑客冒充的。这样，浏览器访问的就是黑客的服务器，黑客可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它并不完全知道现在访问的是这个是黑客的站点。</p><p>服务器需要证明自己的身份，需要使用权威机构颁发的证书，这个权威机构就是 CA（Certificate Authority）， 颁发的证书就称为数字证书 (Digital Certificate)。</p><p>对于浏览器来说，数字证书有两个作用：</p><ol><li>通过数字证书向浏览器证明服务器的身份</li><li>数字证书里面包含了服务器公钥</li></ol><p>下面我们来看一下含有数字证书的HTTPS的请求流程</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000022950456.png" alt="含有数字证书的HTTPS的请求流程"></p><p>相对于不含数字证书的HTTPS请求流程，主要以下两点改动</p><ol><li>服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含数字证书中的；</li><li>在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后序流程。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-HTTP存在的问题&quot;&gt;&lt;a href=&quot;#1-HTTP存在的问题&quot; class=&quot;headerlink&quot; title=&quot;1. HTTP存在的问题&quot;&gt;&lt;/a&gt;1. HTTP存在的问题&lt;/h1&gt;&lt;p&gt;传统的不使用SSL/TLS的HTTP协议，是不加密的通信。无论是</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP/IP" scheme="https://leslieaibin.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>12.MySql事务</title>
    <link href="https://leslieaibin.github.io/2022/07/04/MySQL/12.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%E4%BA%8B%E5%8A%A1/"/>
    <id>https://leslieaibin.github.io/2022/07/04/MySQL/12.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-07-04T11:17:42.000Z</published>
    <updated>2022-07-19T14:43:17.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>事务（<code>Transaction</code>），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元。事务通常由高<a href="https://so.csdn.net/so/search?q=%E7%BA%A7%E6%95%B0&spm=1001.2101.3001.7020">级数</a>据库操作语言或编程语言（如 SQL，C++ 或 Java）书写的用户程序的执行所引起，并用形如<code>begin transaction</code>和<code>end transaction</code>语句（或函数调用）来界定。事务由事务开始（<code>begin transaction</code>）和事务结束（<code>end transaction</code>）之间执行的全部操作组成。</p><p>对于 MySQL 数据库来说，事务是指以执行<code>start transaction</code>命令开始，到执行<code>commit</code>或者<code>rollback</code>命令结束之间的全部 SQL 操作，如果这些 SQL 操作全部执行成功，则执行<code>commit</code>命令提交事务，表示事务执行成功；如果这些 SQL 操作中任一操作执行失败，则执行<code>rollback</code>命令回滚事务，表示事务执行失败，并将数据库回滚到执行<code>start transaction</code>命令之前的状态。特别地，在现阶段的 MySQL 数据库中，仅 InnoDB 和 NDB 两个存储引擎是支持事务的。</p><p>以 MySQL 的 InnoDB 存储引擎为例，其默认是开启<code>autocommit</code>配置的，即自动提交事务。在自动提交模式下，如果没有以<code>start transaction</code>显式地开始一个事务，那么每条 SQL 语句都会被当做一个事务执行提交操作。通过<code>set autocommit = 0</code>命令可以关闭自动提交模式，如果关闭了<code>autocommit</code>，则所有的 SQL 语句都在一个事务中，直到执行<code>commit</code>或<code>rollback</code>，该事务结束，并同时开始另外一个新的事务。在此，需要我们注意的是，<code>autocommit</code>参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响。</p><p>除此之外，在 MySQL 中，还存在一些特殊的命令，如果在事务中执行了这些命令，则会强制执行<code>commit</code>命令提交事务，如 DDL 语句（<code>create table</code>/<code>drop table</code>/<code>alter table</code>）、<code>lock tables</code>语句等。不过，我们常用的<code>select</code>、<code>insert</code>、<code>update</code>和<code>delete</code>命令，都不会强制提交事务。</p><h2 id="事务的四个特性：ACID"><a href="#事务的四个特性：ACID" class="headerlink" title="事务的四个特性：ACID"></a>事务的四个特性：ACID</h2><p>通过上面的内容，我们已经知道了什么是事务，但实际上，事务还具有以下四个特性，即：</p><ul><li>  原子性（<code>Atomicity</code>）</li><li>  一致性（<code>Consistency</code>）</li><li>  隔离性（<code>Isolation</code>）</li><li>  持久性（<code>Durability</code>）</li></ul><p>按照严格的标准，只有同时满足 ACID 特性才是事务，但是在各大数据库厂商的实现中，真正满足 ACID 的事务少之又少。例如，MySQL 的 NDB 事务不满足持久性和隔离性；InnoDB 默认的事务隔离级别是“可重复读”，不满足隔离性；Oracle 默认的事务隔离级别为“读提交”，不满足隔离性等等，因此与其说 ACID 是事务必须满足的条件，不如说它们是衡量事务的四个维度。</p><p>我们刚刚提到的“隔离级别”在后文中会进行详细的讲解，下面我们先详细介绍 ACID 特性及其实现原理。</p><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>原子性，是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个 SQL 语句执行失败，则已执行的语句也必须回滚，数据库回退到事务开始前的状态。</p><h4 id="实现原理：undo-log"><a href="#实现原理：undo-log" class="headerlink" title="实现原理：undo log"></a>实现原理：undo log</h4><p>在说明原子性的实现原理之前，我们先来了解一下 MySQL 的事务日志。MySQL 的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外 InnoDB 存储引擎还提供了两种事务日志：<code>redo log</code>（重做日志）和<code>undo log</code>（回滚日志）。其中，<code>redo log</code>用于保证事务持久性；<code>undo log</code>则是事务原子性和隔离性实现的基础。</p><p>实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的 SQL 语句。InnoDB 实现回滚，靠的是<code>undo log</code>：当事务对数据库进行修改时，InnoDB 会生成对应的<code>undo log</code>；如果事务执行失败或调用了<code>rollback</code>，导致事务需要回滚，便可以利用<code>undo log</code>中的信息将数据回滚到修改之前的样子。</p><p><code>undo log</code>属于逻辑日志，它记录的是 SQL 执行的相关信息。当发生回滚时，InnoDB 会根据<code>undo log</code>的内容做与之前相反的工作：对于每个<code>insert</code>，回滚时会执行<code>delete</code>；对于每个<code>delete</code>，回滚时会执行<code>insert</code>；对于每个<code>update</code>，回滚时会执行一个相反的<code>update</code>，把数据改回去。</p><p>以<code>update</code>操作为例：当事务执行<code>update</code>时，其生成的<code>undo log</code>中会包含被修改行的主键（以便知道修改了哪些行）、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到<code>update</code>之前的状态。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>持久性，是指事务一旦提交，它对数据库的改变就应该是永久性的，接下来的其他操作或故障不应该对其有任何影响。</p><h4 id="实现原理：redo-log"><a href="#实现原理：redo-log" class="headerlink" title="实现原理：redo log"></a>实现原理：redo log</h4><p><code>redo log</code>和<code>undo log</code>都属于 InnoDB 的事务日志。下面先聊一下<code>redo log</code>存在的背景。</p><p>InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。为此，InnoDB 提供了缓存（<code>Buffer Pool</code>），<code>Buffer Pool</code>中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从<code>Buffer Pool</code>中读取，如果<code>Buffer Pool</code>中没有，则从磁盘读取后放入<code>Buffer Pool</code>；当向数据库写入数据时，会首先写入<code>Buffer Pool</code>，<code>Buffer Pool</code>中修改的数据会定期刷新到磁盘中，这一过程称为“刷脏”。</p><p><code>Buffer Pool</code>的使用大大提高了读写数据的效率，但是也带了新的问题：如果 MySQL 宕机，而此时<code>Buffer Pool</code>中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p><p>于是，<code>redo log</code>被引入来解决这个问题：当数据修改时，除了修改<code>Buffer Pool</code>中的数据，还会在<code>redo log</code>记录这次操作；当事务提交时，会调用<code>fsync</code>接口对<code>redo log</code>进行刷盘。如果 MySQL 宕机，重启时可以读取<code>redo log</code>中的数据，对数据库进行恢复。<code>redo log</code>采用的是 WAL（<code>Write-ahead logging</code>，预写式日志），所有修改先写入日志，再更新到<code>Buffer Pool</code>，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。</p><p>既然<code>redo log</code>也需要在事务提交时将日志写入磁盘，为什么它比直接将<code>Buffer Pool</code>中修改的数据写入磁盘（即刷脏）要快呢？主要有以下两方面的原因：</p><ul><li>  刷脏是随机 IO，因为每次修改的数据位置随机，但写<code>redo log</code>是追加操作，属于顺序 IO。</li><li>  刷脏是以数据页（<code>Page</code>）为单位的，MySQL 默认页大小是 16 KB，一个<code>Page</code>上一个小修改都要整页写入；而<code>redo log</code>中只包含真正需要写入的部分，无效 IO 大大减少。</li></ul><p>我们知道，在 MySQL 中还存在<code>binlog</code>（二进制日志）也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：</p><ul><li>  <strong>作用不同</strong>：<code>redo log</code>是用于<code>crash recovery</code>的，保证 MySQL 宕机也不会影响持久性；<code>binlog</code>是用于<code>point-in-time recovery</code>的，保证服务器可以基于时间点恢复数据，此外<code>binlog</code>还用于主从复制。</li><li>  <strong>层次不同</strong>：<code>redo log</code>是 InnoDB 存储引擎实现的，而<code>binlog</code>是 MySQL 的服务器层实现的，同时支持 InnoDB 和其他存储引擎。</li><li>  <strong>内容不同</strong>：<code>redo log</code>是物理日志，内容基于磁盘的<code>Page</code>；<code>binlog</code>的内容是二进制的，根据<code>binlog_format</code>参数的不同，可能基于 SQL 语句、基于数据本身或者二者的混合。</li><li><strong>写入时机不同</strong>：<code>binlog</code>在事务提交时写入；<code>redo log</code>的写入时机相对多元：<ul><li>  前面曾提到当事务提交时会调用<code>fsync</code>对<code>redo log</code>进行刷盘，这是默认情况下的策略，修改<code>innodb_flush_log_at_trx_commit</code>参数可以改变该策略，但事务的持久性将无法保证。</li><li>  除了事务提交时，还有其他刷盘时机，如<code>master thread</code>每秒刷盘一次<code>redo log</code>等，这样的好处是不一定要等到<code>commit</code>时刷盘，<code>commit</code>速度大大加快。</li></ul></li></ul><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。隔离性，是指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。严格的隔离性，对应了事务隔离级别中的<code>Serializable</code>（可串行化），但实际应用中出于性能方面的考虑很少会使用可串行化。</p><p>隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作（暂时不考虑带锁读等特殊操作），那么隔离性的探讨，主要可以分为两个方面：</p><ul><li>  （一个事务）写操作对（另一个事务）写操作的影响：锁机制保证隔离性</li><li>  （一个事务）写操作对（另一个事务）读操作的影响：MVCC 保证隔离性</li></ul><h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><p>首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB 通过锁机制来保证这一点。</p><p>锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</p><p>按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源（获得锁、检查锁、释放锁等都需要消耗资源），因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL 中不同的存储引擎支持的锁是不一样的，例如 MyIsam 只支持表锁，而 InnoDB 同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p><blockquote><p><strong>如何查看锁信息</strong>：有多种方法可以查看 InnoDB 中锁的情况，例如</p><ul><li>  <code>select * from information_schema.innodb_locks;</code> # 查询锁的概况</li><li>  <code>show engine innodb status;</code> # 查询 InnoDB 整体状态，其中包括锁的情况</li></ul></blockquote><p>下面来看一个例子：</p><pre><code># 在事务 A 中执行start transaction;update account SET balance = 1000 where id = 1;# 在事务 B 中执行start transaction;update account SET balance = 2000 where id = 1;</code></pre><p>​        </p><p>此时，查看锁的情况：</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20200510195637126.png"></p><p>使用<code>show engine innodb status</code>语句查看锁相关的部分：</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20200510195747794.png"></p><p>通过上述命令可以查看事务<code>24052</code>和<code>24053</code>占用锁的情况，其中<code>lock_type</code>为<code>RECORD</code>，代表锁为行锁（记录锁）；<code>lock_mode</code>为<code>X</code>，代表排它锁（写锁）。除了排它锁（写锁）之外，MySQL 中还有共享锁（读锁）的概念。</p><p>介绍完写操作之间的相互影响，下面讨论写操作对读操作的影响。</p><h4 id="脏读、不可重复读和幻读"><a href="#脏读、不可重复读和幻读" class="headerlink" title="脏读、不可重复读和幻读"></a>脏读、不可重复读和幻读</h4><p>首先来看并发情况下，读操作可能存在的三类问题。</p><ul><li><p><strong>脏读</strong>：当前事务（<code>A</code>）中可以读到其他事务（<code>B</code>）未提交的数据（脏数据），这种现象是脏读。举例如下（以账户余额表为例）：-<br>  <img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20200510200208456.png"></p></li><li><p><strong>不可重复读</strong>：在事务<code>A</code>中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。举例如下：-<br>  <img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/2020051020041274.png"></p></li><li><p><strong>幻读</strong>：在事务<code>A</code>中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。举例如下：-<br>  <img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20200510200607799.png"></p></li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>SQL 标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。隔离级别与读问题的关系如下：</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20200510200823146.png"></p><p>在实际应用中，读未提交在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。可串行化强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。因此在大多数数据库系统中，默认的隔离级别是读已提交（如 Oracle）或可重复读（后文简称<code>RR</code>）。</p><p>可以通过如下两个命令分别查看全局隔离级别和本次会话的隔离级别：</p><ul><li>  <code>select @@global.tx_isolation</code> # 查询全局隔离级别</li><li>  <code>select @@tx_isolation</code> # 查询本次会话隔离级别</li></ul><p>InnoDB 默认的隔离级别是<code>RR</code>，后文会重点介绍<code>RR</code>。需要注意的是，在 SQL 标准中，<code>RR</code>是无法避免幻读问题的，但是 InnoDB 实现的<code>RR</code>避免了幻读问题。</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p><code>RR</code>解决脏读、不可重复读、幻读等问题，使用的是 MVCC：MVCC 全称<code>Multi-Version Concurrency Control</code>，即多版本的并发控制协议。下面的例子很好的体现了 MVCC 的特点：在同一时刻，不同的事务读取到的数据可能是不同的（即多版本）—— 在 T5 时刻，事务<code>A</code>和事务<code>C</code>可以读取到不同版本的数据。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20200510201347917.png"></p><p>MVCC 最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB 实现 MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列（也可以称之为标记位）和<code>undo log</code>。其中，数据的隐藏列包括了该行数据的版本号、删除时间、指向<code>undo log</code>的指针等等；当读取数据时，MySQL 可以通过隐藏列判断是否需要回滚并找到回滚需要的<code>undo log</code>，从而实现 MVCC；隐藏列的详细格式不再展开。</p><p>下面结合前文提到的几个问题分别说明。</p><ul><li>  <strong>脏读</strong></li></ul><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20200510201757310.png">-<br>当事务<code>A</code>在 T3 时间节点读取<code>zhangsan</code>的余额时，会发现数据已被其他事务修改，且状态为未提交。此时事务<code>A</code>读取最新数据后，根据数据的<code>undo log</code>执行回滚操作，得到事务<code>B</code>修改前的数据，从而避免了脏读。</p><ul><li>  <strong>不可重复读</strong></li></ul><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20200510201757360.png">-<br>当事务<code>A</code>在 T2 节点第一次读取数据时，会记录该数据的版本号（数据的版本号是以<code>row</code>为单位记录的），假设版本号为<code>1</code>；当事务<code>B</code>提交时，该行记录的版本号增加，假设版本号为<code>2</code>；当事务<code>A</code>在 T5 再一次读取数据时，发现数据的版本号<code>2</code>大于第一次读取时记录的版本号<code>1</code>，因此会根据<code>undo log</code>执行回滚操作，得到版本号为<code>1</code>时的数据，从而实现了可重复读。</p><ul><li>  <strong>幻读</strong></li></ul><p>InnoDB 实现的<code>RR</code>通过<code>next-key lock</code>机制避免了幻读现象。<code>next-key lock</code>是行锁的一种，实现相当于<code>record lock(记录锁) + gap lock(间隙锁)</code>；其特点是不仅会锁住记录本身（<code>record lock</code>的功能），还会锁定一个范围（<code>gap lock</code>的功能）。当然，这里我们讨论的是不加锁读：此时的<code>next-key lock</code>并不是真的加锁，只是为读取的数据增加了标记（标记内容包括数据的版本号等），准确起见姑且称之为类<code>next-key lock</code>机制。还是以前面的例子来说明：-<br><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20200510201757412.png">-<br>当事务<code>A</code>在 T2 节点第一次读取<code>0&lt;id&lt;5</code>数据时，标记的不只是<code>id=1</code>的数据，而是将范围<code>(0, 5)</code>进行了标记，这样当 T5 时刻再次读取<code>0&lt;id&lt;5</code>数据时，便可以发现<code>id=2</code>的数据比之前标记的版本号更高，此时再结合<code>undo log</code>执行回滚操作，避免了幻读。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>概括来说，InnoDB 实现的<code>RR</code>，通过锁机制、数据的隐藏列、<code>undo log</code>和类<code>next-key lock</code>，实现了一定程度的隔离性，可以满足大多数场景的需要。不过需要说明的是，<code>RR</code>虽然避免了幻读问题，但是毕竟不是<code>Serializable</code>，不能保证完全的隔离，下面是一个例子，大家可以自己验证一下。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20200510201809221.png"></p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>一致性，是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。实现一致性的措施包括：</p><ul><li>  保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证；</li><li>  数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等；</li><li>  应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下面总结一下 ACID 特性及其实现原理：</p><ul><li>  <strong>原子性</strong>：保证事务要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的，实现主要基于<code>undo log</code>日志；</li><li>  <strong>持久性</strong>：保证事务提交后不会因为宕机等原因导致数据丢失，实现主要基于<code>redo log</code>日志；</li><li>  <strong>隔离性</strong>：保证事务执行尽可能不受其他事务影响，InnoDB 默认的隔离级别是<code>RR</code>，<code>RR</code>的实现主要基于锁机制、数据的隐藏列、<code>undo log</code>日志和类<code>next-key lock</code>机制；</li><li>  <strong>一致性</strong>：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障。</li></ul><h2 id="进一步了解事务的隔离级别"><a href="#进一步了解事务的隔离级别" class="headerlink" title="进一步了解事务的隔离级别"></a>进一步了解事务的隔离级别</h2><p>在上文中，我们已经大致介绍了事务的四种隔离级别，下面我们在来看看这四种隔离级别的实现原理。</p><h3 id="事务隔离的原理是什么？"><a href="#事务隔离的原理是什么？" class="headerlink" title="事务隔离的原理是什么？"></a>事务隔离的原理是什么？</h3><p>我们都知道事务的四种性质，数据库为了维护这些性质，尤其是一致性和隔离性，一般使用加锁这种方式。同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以，对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。</p><h4 id="一次封锁-or-两段锁？"><a href="#一次封锁-or-两段锁？" class="headerlink" title="一次封锁 or 两段锁？"></a>一次封锁 or 两段锁？</h4><p>因为有大量的并发访问，为了预防死锁，一般应用中推荐使用一次封锁法，就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。这种方式可以有效的避免循环死锁，但在数据库中却不适用，因为在事务开始阶段，数据库并不知道会用到哪些数据。</p><p>数据库遵循的是两段锁协议，将事务分成两个阶段，分别为：</p><ul><li>  <strong>加锁阶段</strong>：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得<code>S</code>锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得<code>X</code>锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</li><li>  <strong>解锁阶段</strong>：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</li></ul><p>这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候）的。</p><h3 id="事务中的加锁方式"><a href="#事务中的加锁方式" class="headerlink" title="事务中的加锁方式"></a>事务中的加锁方式</h3><p>在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别，而数据库锁，就是为了构建这些隔离级别存在的。</p><h4 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h4><p><code>Read Uncommitted</code>，虽然其也是隔离级别中的一种，但因为其可能引发的问题比较多，所以数据库一般都不会使用这种隔离级别，而且其任何操作都不会加锁，这里就不讨论了。</p><h4 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h4><p><code>Read Committed</code>，在这种隔离级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。</p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p><code>Repeatable Read</code>，这是 MySQL 中 InnoDB 存储引擎默认的隔离级别。我们姑且分“读”和“写”两个模块来讲解。</p><h5 id="读（快照读）"><a href="#读（快照读）" class="headerlink" title="读（快照读）"></a>读（快照读）</h5><p>读就是可重复读，其解决了脏读和不可重复读的问题，但却可能引发幻读的问题。</p><p>讲到这里，我们先来好好地说明下不可重复读和幻读的区别：</p><ul><li>  很多人容易搞混不可重复读和幻读，两者确实有些相似，但不可重复读的重点在于<code>update</code>和<code>delete</code>操作，而幻读的重点则在于<code>insert</code>操作。</li><li>  如果使用锁机制来实现这两种隔离级别，在可重复读中，该 SQL 第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住<code>insert</code>的数据，所以当事务<code>A</code>先前读取了数据，或者修改了全部数据，事务<code>B</code>还是可以<code>insert</code>数据提交，这时事务<code>A</code>就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。</li><li>  需要<code>Serializable</code>隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但却会极大的降低数据库的并发能力。</li></ul><p>所以说，不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。MySQL、Oracle、PostgreSQL 等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的 MVCC（多版本并发控制）来避免这两种问题。</p><p>这里继续扩展下悲观锁和乐观锁的知识。</p><ul><li><strong>悲观锁</strong>：正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。<ul><li>  悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</li><li>  在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时要加锁，其它事务无法修改这些数据；修改删除数据时也要加锁，其它事务无法读取这些数据。</li></ul></li><li><strong>乐观锁</strong>：相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。而乐观锁机制在一定程度上解决了这个问题。<ul><li>  乐观锁大多是基于数据版本（<code>version</code>）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个<code>version</code>字段来实现。</li><li>  读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</li></ul></li></ul><p>需要说明的是，MVCC 的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是 InnoDB 的 MVCC。接下来，讲解 MVCC 在 MySQL 的 InnoDB 中的实现：</p><ul><li>在 InnoDB 中，会在每行数据后添加两个额外的隐藏的值来实现 MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在<code>RR</code>事务隔离级别下：<ul><li>  <code>insert</code>时，保存当前事务版本号为行的创建版本号；</li><li>  <code>delete</code>时，保存当前事务版本号为行的删除版本号；</li><li>  <code>select</code>时，读取创建版本号<code>&lt;=</code>当前事务版本号，删除版本号为空或<code>&gt;</code>当前事务版本号；</li><li>  <code>update</code>时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行。</li></ul></li></ul><p>通过 MVCC，虽然每行记录都需要额外的存储空间、更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p><p>事务的隔离级别其实都是对于读数据的定义，但到了这里，就被拆成了读和写两个模块来讲解。这主要是因为 MySQL 中的读，和事务隔离级别中的读，是不一样的。</p><p>我们且看，在<code>RR</code>级别中，通过 MVCC 机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据。这在一些对于数据的时效特别敏感的业务中，就很可能出问题。</p><p>对于这种读取历史数据的方式，我们叫它快照读（<code>snapshot read</code>），而读取数据库当前版本数据的方式，叫当前读（<code>current read</code>）。很显然，在 MVCC 中：</p><ul><li>  <strong>快照读</strong>：就是<code>select</code>操作；</li><li>  <strong>当前读</strong>：特殊的读操作，<code>insert</code>、<code>update</code>和<code>delete</code>操作，属于当前读，处理的都是当前的数据，需要加锁。</li></ul><p>事务的隔离级别实际上都是定义了当前读的级别，MySQL 为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得<code>select</code>不用加锁。而<code>update</code>、<code>insert</code>这些“当前读”，就需要另外的模块来解决了。因为更新数据、插入数据是针对当前数据的，所以不能以快照的历史数据为参考，此处就是这个意思。</p><h5 id="写（当前读）"><a href="#写（当前读）" class="headerlink" title="写（当前读）"></a>写（当前读）</h5><p>事务的隔离级别中虽然只定义了读数据的要求，实际上这也可以说是写数据的要求。上文的“读”，实际是讲的快照读，而这里说的“写”就是当前读了。</p><p>为了解决当前读中的幻读问题，MySQL 事务使用了<code>next-key lock</code>锁，我们在上文中已经介绍过了，它是行锁和间隙锁的组合。</p><p>行锁可以防止不同事务版本的数据修改提交时造成数据冲突的情况。但如何避免别的事务插入数据就成了问题。行锁防止别的事务修改或删除，间隙锁防止别的事务新增，行锁和间隙锁结合形成的的<code>next-key lock</code>锁就共同解决了<code>RR</code>级别在写数据时的幻读问题。</p><h4 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h4><p><code>Serializable</code>，这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。如果你的业务并发的特别少或者没有并发，同时又要求数据及时可靠的话，可以使用这种模式。</p><p>在这里需要注意改变一个观念，不要看到<code>select</code>就说不会加锁了，在<code>Serializable</code>这个级别中，<code>select</code>还是会加锁的。</p><hr><p><strong>参考资料</strong>：</p><ul><li>  <a href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1/5945882?fr=aladdin">事务 - 百度百科</a></li><li>  <a href="https://www.cnblogs.com/kismetv/p/10331633.html">深入学习MySQL事务：ACID特性的实现原理</a></li><li>  <a href="https://www.jianshu.com/p/dab1c0ecbac0">MySQL（二）｜深入理解MySQL的四种隔离级别及加锁实现原理</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是事务？&quot;&gt;&lt;a href=&quot;#什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是事务？&quot;&gt;&lt;/a&gt;什么是事务？&lt;/h2&gt;&lt;p&gt;事务（&lt;code&gt;Transaction&lt;/code&gt;），一般是指要做的或所做的事情。在计算机术语中是指访问</summary>
      
    
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis的持久化</title>
    <link href="https://leslieaibin.github.io/2022/06/30/Redis/%E8%81%8A%E8%81%8ARedis%E7%9A%84%E6%8C%81%E4%B9%85%E6%80%A7/"/>
    <id>https://leslieaibin.github.io/2022/06/30/Redis/%E8%81%8A%E8%81%8ARedis%E7%9A%84%E6%8C%81%E4%B9%85%E6%80%A7/</id>
    <published>2022-06-30T01:15:42.000Z</published>
    <updated>2022-07-19T15:22:50.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>  什么是持久化 : Redis读写速度快、性能优越是因为它将所有数据存在了内存中,然而,当Redis进程退出或重启后,所有数据就会丢失,所以我们希望Redis能保存数据到硬盘中,在Redis服务重启之后,原来的数据能够恢复,这个过程就叫持久化.-<br>  MySQL的InnoDB存储引擎通过 redo log、bin log 这两个日志保证了持久化.</p></blockquote><h2 id="Redis的两种持久化方式-—-RDB、AOF"><a href="#Redis的两种持久化方式-—-RDB、AOF" class="headerlink" title="Redis的两种持久化方式 — RDB、AOF"></a>Redis的两种持久化方式 — RDB、AOF</h2><blockquote><p>  Redis 提供了两种持久化功能 : RDB、AOF ,但两种功能无论在磁盘上的存储格式、使用性能、安全性以及使用场景等方面上是有区别的.</p></blockquote><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><blockquote><p>  RDB持久化既可以手动执行,也可以根据服务器配置选项定期执行(即可以在某个时间点上达到配置选项的条件而进行持久化RDB文件中).由于RDB文件是保存在磁盘中,所以Redis服务器进程退出后,甚至运行的计算机停机了,只要RDB文件存在,Redis服务器就可以利用RDB文件来还原数据库状态.</p></blockquote><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=http://www.itabin.com/content/images/2021/06/save_restore.png"></p><blockquote><p>接下来分别看看RDB的两种执行方式 : 手动执行、配置选项定期执行.</p></blockquote><h3 id="手动执行"><a href="#手动执行" class="headerlink" title="手动执行"></a>手动执行</h3><blockquote><p>手动执行 : Redis提供了SAVE、BGSAVE两种命令来生成RDB文件</p><ul><li>  SAVE : 该命令会阻塞Redis服务器进程,直到RDB文件生成完毕为止,在Redis服务器进程生成RDB文件期间(阻塞状态),Redis服务器进程不会处理任何命令请求(所有命令都会被拒绝)</li><li>  BGSAVE : 该命令与SAVE不同,BGSAVE会通过调用fork()生成一个子进程,该子进程负责创建生成RDB文件,而服务器进程(父进程)继续处理请求.</li></ul></blockquote><h3 id="配置选项定期执行"><a href="#配置选项定期执行" class="headerlink" title="配置选项定期执行"></a>配置选项定期执行</h3><blockquote><p>  Redis允许通过设置服务器配置save选项,让服务器每隔一段时间自动执行一次BGSAVE命令.我们可以通过save选项设置多个保存条件,只要满意其中一个条件,服务器就会执行一次BGSAVE命令.</p></blockquote><blockquote><p>通过save命令可以生成保存条件,例如以下 :</p><ul><li>  save 900 1 : 服务器900秒之内,对数据库进行了至少1次修改(写入、删除、更新)</li><li>  save 300 10 : 服务器300秒之内,对数据库进行了至少10次修改(写入、删除、更新)</li><li>  save 60 10000 : 服务器60秒之内,对数据库进行了至少10000次修改(写入、删除、更新)</li></ul></blockquote><blockquote><p>  Redis服务端维护着一个saveparams属性(数组)来存放这些执行的选项条件,除此之外,还通过 dirty计数器、lastsave属性来配合判断是否执行 BGSAVE命令 :</p><ul><li>  dirty计数器 : 记录距离上次成功执行SAVE命令或者BGSAVE命令之后,服务器对数据库状态进行了多少次修改(写入、删除、更新)</li><li>  lastsave属性 : 该属性是一个UNIX时间戳,记录了服务器上次成功执行SAVE命令或者BGSAVE命令的时间</li></ul></blockquote><blockquote><p>  Redis服务器会周期性的执行serverCron(),默认每隔100ms执行一次,该函数用于对正在执行的服务器进行维护,其中一项就是检查sava选项所设置的条件是否存在已经满足的,如果存在的话则执行BGSAVE,具体伪代码如下 :</p></blockquote><pre><code># ... 其他操作# 遍历saveparams所有保存的条件for saveparams in server.saveparams:    # 根据lastsave属性计算距离上次执行保存操作多少秒    save_interval = unixtime_now() - server.lastsave    # 如果数据量状态的修改次数超过条件所设置的次数 并且    # 距离上次保存的时间超过条件锁设置的时间    # 则执行BGSAVE操作    if server.dirty &gt;= saveparam.changes and       save_interval &gt; saveparam.seconds:        BGSAVE()# ... 其他操作</code></pre><p>None</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><ul><li>  可通过手动执行 、 save配置选项定期执行 两种方式来保存RDB文件;</li><li>  BGSAVE命令会通过调用fork()来创建子进程来创建新的RDB文件;当 Redis 调用执行 fork() 时,操作系统会使用写时复制策略(CopyOnWrite)来创建一个子进程创建新的RDB文件,父、子进程共享同一内存数据(物理内存),当父进程要修改某个数据时(执行一条写命令),操作系统会将这个共享内存数据另外复制一份给子进程使用,以此来保证子进程的正确运行.因此,新的 RDB 文件存储的是执行 fork() 过程中的内存数据.</li><li>  serverCron()默认每隔100ms执行一次,通过 saveparams数组、dirty计数器、lastsave属性来配合判断是否执行 BGSAVE命令;</li><li>  当调用操作系统的fock()子进程,即使使用了COW技术,但是如果出现父进程多次的写命令而修改了共享内存,那么此时需要多次复制共享内存数据给子进程以保证子进程正确的运行,此时就会消耗内存,因为内存中不仅保存了当前数据库数据,还会保存 fork() 过程中的内存数据.</li></ul></blockquote><h2 id="RDB相关配置-—-了解"><a href="#RDB相关配置-—-了解" class="headerlink" title="RDB相关配置 — 了解"></a>RDB相关配置 — 了解</h2><blockquote><ul><li>  stop-writes-on-bgsave-error yes : 当执行 BGSAVE 命令出现错误时,Redis 是否终止执行写命令.参数的值默认被设置为 yes,表示当硬盘出现问题时,服务器可以及时发现,及时避免大量数据丢失;当设置为 no 时,就算执行 BGSAVE 命令发生错误,服务器也会继续执行写命令;当对 Redis 服务器的系统设置了监控时,建议将该参数值设置为 no.</li><li>  rdbcompression yes : 是否开启 RDB 压缩文件,默认为 yes 表示开启,不开启则设置为 no.</li><li>  rdbchecksum yes : 是否开启 RDB 文件的校验,在服务器进行 RDB 文件的写入与读取时会用到它.默认设置为 yes.如果将它设置为 no,则在服务器对 RDB 文件进行写入与读取时,可以提升性能,但是无法确定 RDB 文件是否已经被损坏.</li></ul></blockquote><h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><blockquote><p>RDB文件结构如下图 :</p></blockquote><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=http://www.itabin.com/content/images/2021/06/rdb_struc.png"></p><blockquote><ul><li>  REDIS : 这个部分是一个长度为5字节,保存着 “REDIS” 五个字符,通过这五个字符可以快速检验载入的文件是否RDB文件.</li><li>  db_version : 占用4字节,是一个字符串表示的整数,表示RDB文件的版本号,例如 “0006”</li><li>databases : 该部分包含着各个数据库中的键值对数据;<ul><li>  如果服务器的数据库状态为空,该部分也为空,即长度占用0字节.</li><li>  如果服务器的数据库状态至少含有一个数据库,那么会存放各个数据库对应所保存的键值对的数量、类型、内容等.</li></ul></li><li>  EOF : 占用1字节,表示RDB正文内容的结束,即当读取哦到该值时,表示所有数据库的所有键值对都载入到内存了.</li><li>  check_num : 占用8个字节的无符号整数,保存着一个检验和;这个检验和通过前面四个部分的内容进行计算出来的.当服务器在载入RDB文件时,会通将载入数据所计算出的检验和与check_num进行对比,以此来检查RDB文件是否出错或者损坏的情况.</li></ul></blockquote><blockquote><p>  核心看看databases字段,如下图保存了0号、1号两个非空数据库,并且每个非空数据库对应着 SELECTDB、db_number、key_value_pairs 三个字段 :</p></blockquote><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=http://www.itabin.com/content/images/2021/06/rdb_databases.png"></p><blockquote><ul><li>  SELECTDB : 占用1字节,当程序遇到这个值的时候,那么它将直到接下来将会读取到一个数据库号码;</li><li>  db_number : 保存了数据库号码,当程序读取到这个值的时候,服务器会调用SELECT命令,并且根据该值保存的数据库号码来进行数据库切换.</li><li>  key_value_pairs : 保存了数据库中所有的键值对数据,包括带有过期时间的键值对.</li></ul></blockquote><blockquote><p>key_value_pairs,结构如下图 :</p></blockquote><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=http://www.itabin.com/content/images/2021/06/key_value.png"></p><blockquote><ul><li>不带过期键值对 :<ul><li>  TYPE : 占用1字节,记录了value的存储类型,比如字符串、链表、哈希表等</li><li>  key : 总是一个字符串对象</li></ul></li><li>带过期键值对 : 在不带过期键值对的基础上新增了 EXPIRETIME_MS 、 ms :<ul><li>  EXPIRETIME_MS : 占用1字节,表示接下来将会读取到一个以毫秒为单位的过期时间.</li><li>  ms : 一个8字节长的带符号整数,记录了以毫秒为单位的UNIX时间戳,即该键值对的过期时间.</li></ul></li></ul></blockquote><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><blockquote><p>AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的,如下图 :</p></blockquote><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=http://www.itabin.com/content/images/2021/06/aof.png"></p><blockquote><p>AOF持久化功能的实现主要分为命令追加、文件写入、文件同步三个步骤 :</p></blockquote><blockquote><ul><li>  命令追加 : 当AOF持久化功能处于打开状态的时候,服务器执行的写操作之后会以协议格式将被执行的写命令追加到服务器aof_buf缓冲区的末尾,例如:</li></ul></blockquote><pre><code># 写操作SET KEY VALUE# 协议格式*3\rn$3\r\nSET\rn$3\r\nKEY\r\n$5\r\nVALUE\r\n</code></pre><p>Redis</p><blockquote><ul><li>文件写入、同步 : 文件的写入是指将aof_buf缓冲区的内容写入到磁盘中;而同步操作依赖于appendfsync选项值来决定.-<br>  在上面我们有提到serverCron()会根据sava配置项来执行BGSAVE命令,该函数不止只包含该作用,现在我们又看到它包含把客户端发送的写命令以协议格式写入到aof_buf中,然后根据appendfsync选项值来执行同步操作.</li></ul><p>appendfsync选项值有三种选项 :</p><ul><li>  always : 将aof_buf缓冲区所有内容写入并同步到AOF</li><li>  everysec : 将aof_buf缓冲区所有内容写入到AOF,如果上次同步AOF文件的时间距离现在超过一秒钟,那么再次对AOF文件进行同步操作,这里的同步操作是由一个线程专门负责.(默认选项)</li><li>  no : 将aof_buf缓冲区所有内容写入到AOF,当并不同步操作,具体由操作系统决定</li></ul><p>  文件写入磁盘,这里涉及到操作系统的一个知识点 : 在现代操作系统中,对于文件写入操作,为了提高写入效率,通常会将写入的数据暂时保存在一个内存缓冲区中,等到缓冲区的空间被填满、或者超过了指定的时限之后,才真正地将缓冲区中的数据写入到磁盘中;这种做法虽然带来了效率,但是带来了安全性问题,即如果计算机发生停机,那么保存在内存缓冲区的写入数据将会丢失.-<br>  为此,操作系统提供了fsync和fdatasync两个同步函数,它们可以强制让操作系统立即将缓冲区中的数据写入到磁盘中,从而保证了数据的安全性.</p><p>【PS : 对于文件I/O同步操作,与MySQL的InnoDB存储引擎的rego log 写入到磁盘都是类似的】</p></blockquote><blockquote><p>appendfsync三种选项值的安全性、效率 :</p><ul><li>  always : 安全性最高、效率最低,即使出现宕机,AOF持久化也只会丢失一个时间循环所产生的命令数据.</li><li>  everysec : 每个写入命令都会把aof_buf缓存区的内容写入到AOF,但是每个一秒才会同步到磁盘中.效率最高,但是出现宕机情况可能会丢失一秒钟的命令数据.</li><li>  no : 每个写入命令都会把aof_buf缓存区的内容写入到AOF,但是同步操作由操作系统控制.当出现宕机情况,可能会丢失上次同步AOF文件之后的所有写命令数据.</li></ul></blockquote><h3 id="AOF的重写"><a href="#AOF的重写" class="headerlink" title="AOF的重写"></a>AOF的重写</h3><blockquote><p>  随着服务器运行时间的流逝,AOF文件中的内容会越来越多,文件体积越来越大,如果不加以控制的话,体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响,因为AOF文件体积越大,使用AOF文件来进行数据还原所需的时间就越多.-<br>  AOF重写也是调用fork()创建子进程来重写,父进程依然可以继续接收命令.-<br>  AOF在重写过程中,如果父进程有接收到新的写命令,那么父进程会把这些写命令追加到AOF缓冲区、AOF重写缓冲区(子进程重写过程中使用的重写缓冲区);-<br>  当子进程处理完成后,会把AOF重写缓冲区的内容写入到新的AOF文件中,然后原子的覆盖之前所有旧的AOF文件.</p></blockquote><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><blockquote><p>  AOF持久化内容是执行的写入命令;只要涉及到写入操作,都会以协议格式拼接到aof_buf缓冲区中,通过serverCron()的周期性调用以及appendfsync选项值把AOF写入并同步到磁盘中.-<br>  AOF的重写是为了防止AOF文件过大而导致服务器重启的时候重新载入数据的执行时间过长 、甚至严重点会影响宿主计算机的性能问题.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><blockquote><ul><li>RDB 优点 :<ul><li>  ①备份 : 根据设置的保存条件来统一保存到磁盘中,它保存了某个时间点的数据,非常适用于数据的备份,比如你可以在每个小时保存一下过去24小时内的数据,同时每天保存过去30天的数据.</li><li>  ②文件紧凑 : RDB 文件是一个经过压缩的二进制文件,文件紧凑,体积较小.</li><li>  ③性能 : RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做,父进程不需要再做其他IO操作,所以RDB持久化方式可以最大化redis的性能.</li><li>  ④灾难恢复 : RDB 持久化适用于灾难恢复,而且恢复数据时的速度要快于 AOF 持久化.</li></ul></li><li>RDB 缺点 :<ul><li>  ①安全性 : 在服务器出现故障时,如果没有触发 RDB 快照执行,那么它可能会丢失大量数据.RDB 快照的持久化方式决定了必然做不到实时持久化,会存在大量数据丢失.</li><li>  ②内存消耗 : 当数据量非常庞大时,在保存 RDB 文件的时候,服务器会启动一个子进程来完成相关的保存操作.这项操作比较耗时,将会占用太多 CPU 时间,从而影响服务器的性能.</li></ul></li></ul></blockquote><blockquote><ul><li>AOF 优点 :<ul><li>  ①更加持久化 : 使用 AOF 持久化会让 Redis 持久化更长,通过设置不同的 fsync 策略来达到更长的持久化.</li><li>  ②兼容性 : AOF 文件是一个日志文件,它的作用是记录服务器执行的所有写命令.当文件因为某条写命令写入失败时,可以使用 redis-check-aof 进行修复,然后继续使用.</li><li>  ③重写 : 当 AOF 文件的体积过大时,在后台可以自动地对 AOF 文件进行重写,因此数据库当前状态的所有命令集合都会被重写到 AOF 文件中.重写完成后,Redis 就会切换到新的 AOF 文件,继续执行写命令的追加操作.</li></ul></li><li>AOF 缺点 :<ul><li>  ①文件体积过大 : AOF 文件的体积会随着时间的推移逐渐变大,导致在加载时速度会比较慢,进而影响数据库状态的恢复速度,性能快速下降.</li><li>  ②根据所使用的 fsync 策略,使用 AOF 文件恢复数据的速度可能会慢于使用 RDB 文件恢复数据的速度.</li></ul></li></ul></blockquote><blockquote><p>RDB 和 AOF 的加载问题 :</p><ul><li>  如果在 Redis 配置文件中开启了 AOF 持久化（appendonly yes）,那么在启动服务器的时候会优先加载 AOF 文件来还原数据库状态.</li><li>  如果在 Redis 配置文件中关闭了 AOF 持久化（appendonly no）,那么在启动服务器的时候会优先加载 RDB 文件来还原数据库状态.</li></ul></blockquote><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h2><blockquote><ul><li>  原创不易</li><li>  希望看完这篇文章的你有所收获!</li></ul></blockquote><h2 id="相关参考资料"><a href="#相关参考资料" class="headerlink" title="相关参考资料"></a><strong>相关参考资料</strong></h2><blockquote><ul><li>  Redis设计与实现【书籍】</li></ul></blockquote><p><a href="http://www.itabin.com/rdb-aof/">查看原网页: www.itabin.com</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  什么是持久化 : Redis读写速度快、性能优越是因为它将所有数据存在了内存中,然而,当Redis进程退出或重</summary>
      
    
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>15.多线程打印</title>
    <link href="https://leslieaibin.github.io/2022/06/24/Thread/15.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8D%B0/"/>
    <id>https://leslieaibin.github.io/2022/06/24/Thread/15.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8D%B0/</id>
    <published>2022-06-24T02:15:42.000Z</published>
    <updated>2022-07-09T13:40:44.269Z</updated>
    
    <content type="html"><![CDATA[<p>一道面试中常考的并发编程的代码题：</p><ul><li>三个线程T1、T2、T3轮流打印ABC，打印n次，如ABCABCABCABC…….</li><li>两个线程交替打印1-100的奇偶数</li><li>N个线程循环打印1-100</li><li>……</li></ul><p>其实这类问题本质上都是线程通信问题，思路基本上都是一个线程执行完毕，阻塞该线程，唤醒其他线程，按顺序执行下一个线程。下面先来看最简单的，如何按顺序执行三个线程。</p><h3 id="synchronized-wait-notify"><a href="#synchronized-wait-notify" class="headerlink" title="synchronized+wait/notify"></a><strong>synchronized+wait/notify</strong></h3><p>基本思路就是线程A、线程B、线程C三个线程同时启动，因为变量<code>num</code>的初始值为<code>0</code>，所以线程B或线程C拿到锁后，进入<code>while()</code>循环，然后执行<code>wait()</code>方法，线程线程阻塞，释放锁。只有线程A拿到锁后，不进入<code>while()</code>循环，执行<code>num++</code>，打印字符<code>A</code>，最后唤醒线程B和线程C。此时<code>num</code>值为<code>1</code>，只有线程B拿到锁后，不被阻塞，执行<code>num++</code>，打印字符<code>B</code>，最后唤醒线程A和线程C，后面以此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_ABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object Lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> tagertNum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Lock)&#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != tagertNum)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                Lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wait_Notify_ABC wait_Notify_ABC = <span class="keyword">new</span> Wait_Notify_ABC();</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; wait_Notify_ABC.printABC(<span class="number">0</span>), <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; wait_Notify_ABC.printABC(<span class="number">1</span>),  <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(() -&gt; wait_Notify_ABC.printABC(<span class="number">2</span>),  <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABCABCABCABCABCABCABCABCABCABC</span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>下面看第二个问题，两个线程交替打印1-100的奇偶数，为了减少输入所占篇幅，这里将100 改成了10。基本思路上面类似，线程odd先拿到锁——打印数字——唤醒线程even——阻塞线程odd，以此循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Wait_Notify_Odd_Even</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object monitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">    Wait_Notify_Odd_Even(<span class="keyword">int</span> initCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.count = initCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printOddEven</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.print( Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">                    System.out.println(++count);</span><br><span class="line">                    monitor.notifyAll();</span><br><span class="line">                    monitor.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止count=10后，while()循环不再执行，有子线程被阻塞未被唤醒，导致主线程不能退出</span></span><br><span class="line">            monitor.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Wait_Notify_Odd_Even waitNotifyOddEven = <span class="keyword">new</span> Wait_Notify_Odd_Even(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(waitNotifyOddEven::printOddEven, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>); <span class="comment">//为了保证线程odd先拿到锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(waitNotifyOddEven::printOddEven, <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">odd：<span class="number">1</span></span><br><span class="line">even：<span class="number">2</span></span><br><span class="line">odd：<span class="number">3</span></span><br><span class="line">even：<span class="number">4</span></span><br><span class="line">odd：<span class="number">5</span></span><br><span class="line">even：<span class="number">6</span></span><br><span class="line">odd：<span class="number">7</span></span><br><span class="line">even：<span class="number">8</span></span><br><span class="line">odd：<span class="number">9</span></span><br><span class="line">even：<span class="number">10</span></span><br></pre></td></tr></table></figure><p>再看第三个问题，N个线程循环打印1-100，其实仔细想想这个和三个线程循环打印ABC并没有什么本质区别，只需要加上判断是否到了打印数字的最大值的语句即可。假设N=3，为了能把输出结果完全显示，打印1-10，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wait_Notify_100</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxnum = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) &#123; <span class="comment">//想想这里为什么不能用if代替，想不起来可以看公众号上一篇文章</span></span><br><span class="line">                    <span class="keyword">if</span>(num &gt;= maxnum)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num &gt;= maxnum)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + num);</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wait_Notify_100  wait_notify_100 = <span class="keyword">new</span> Wait_Notify_100 ();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            wait_notify_100.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread3&quot;</span>).start();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread1: <span class="number">1</span></span><br><span class="line">thread2: <span class="number">2</span></span><br><span class="line">thread3: <span class="number">3</span></span><br><span class="line">thread1: <span class="number">4</span></span><br><span class="line">thread2: <span class="number">5</span></span><br><span class="line">thread3: <span class="number">6</span></span><br><span class="line">thread1: <span class="number">7</span></span><br><span class="line">thread2: <span class="number">8</span></span><br><span class="line">thread3: <span class="number">9</span></span><br><span class="line">thread1: <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a><strong>Lock</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Lock_ABC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;   <span class="comment">// 当前状态值：保证三个线程之间交替打印</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">3</span> == targetNum) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock_ABC lockABC = <span class="keyword">new</span> Lock_ABC();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lockABC.printABC(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCABCABCABCABCABCABCABCABCABC</span><br></pre></td></tr></table></figure><h3 id="Lock-Condition"><a href="#Lock-Condition" class="headerlink" title="Lock+Condition"></a><strong>Lock+Condition</strong></h3><p>使用Lock+Condition实现对线程的精准唤醒，减少对同步锁的无意义竞争，浪费资源。</p><p>该思路和synchronized+wait/notify方法的很像，synchronized对应lock，await/signal方法对应wait/notify方法。下面的代码为了能精准地唤醒下一个线程，创建了多个Condition对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockConditionABC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printABC</span><span class="params">(<span class="keyword">int</span> targetNum, Condition currentThread, Condition nextThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) &#123;</span><br><span class="line">                    currentThread.await();  <span class="comment">//阻塞当前线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                nextThread.signal();    <span class="comment">//唤醒下一个线程，而不是唤醒所有线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockConditionABC print = <span class="keyword">new</span> LockConditionABC();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            print.printABC(<span class="number">0</span>, c1, c2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            print.printABC(<span class="number">1</span>, c2, c3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            print.printABC(<span class="number">2</span>, c3, c1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCABCABCABCABCABCABCABCABCABC</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一道面试中常考的并发编程的代码题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三个线程T1、T2、T3轮流打印ABC，打印n次，如ABCABCABCABC…….&lt;/li&gt;
&lt;li&gt;两个线程交替打印1-100的奇偶数&lt;/li&gt;
&lt;li&gt;N个线程循环打印1-100&lt;/li&gt;
&lt;li&gt;……&lt;/l</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>9.进程的状态</title>
    <link href="https://leslieaibin.github.io/2022/06/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://leslieaibin.github.io/2022/06/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2022-06-10T16:15:42.000Z</published>
    <updated>2022-06-30T14:14:08.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统之进程状态"><a href="#Linux系统之进程状态" class="headerlink" title="Linux系统之进程状态"></a>Linux系统之进程状态</h1><ul><li>D：uninterruptible sleep (usually IO)</li><li>R：running or runnable (on run queue)</li><li>S：interruptible sleep (waiting for an event to complete)</li><li>T：stopped by job control signal</li><li>t：stopped by debugger during the tracing</li><li>W：paging (not valid since the 2.6.xx kernel)</li><li>X：dead (should never be seen)</li><li>Z：defunct (“zombie”) process, terminated but not - reaped by its parent</li></ul><h2 id="1、R-TASK-RUNNING-，可执行状态"><a href="#1、R-TASK-RUNNING-，可执行状态" class="headerlink" title="1、R (TASK_RUNNING)，可执行状态"></a>1、R (TASK_RUNNING)，可执行状态</h2><p>只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进而，进程调度器就从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。</p><blockquote><p> 很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。 </p></blockquote><h2 id="2、S-TASK-INTERRUPTIBLE-，可中断的睡眠状态"><a href="#2、S-TASK-INTERRUPTIBLE-，可中断的睡眠状态" class="headerlink" title="2、S (TASK_INTERRUPTIBLE)，可中断的睡眠状态"></a>2、S (TASK_INTERRUPTIBLE)，可中断的睡眠状态</h2><p>处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构（进程控制块）被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。</p><blockquote><p> 通过ps命令会看到，一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。毕竟CPU就这么几个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。 </p></blockquote><h2 id="3、D-TASK-UNINTERRUPTIBLE-，不可中断的睡眠状态"><a href="#3、D-TASK-UNINTERRUPTIBLE-，不可中断的睡眠状态" class="headerlink" title="3、D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态"></a>3、D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态</h2><p>与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。</p><p>绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态。</p><blockquote><p> 而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。 例如，在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。 </p></blockquote><h2 id="4、T-t-TASK-STOPPED-or-TASK-TRACED-，暂停状态或跟踪状态"><a href="#4、T-t-TASK-STOPPED-or-TASK-TRACED-，暂停状态或跟踪状态" class="headerlink" title="4、T/t (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态"></a>4、T/t (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态</h2><p><strong>T (TASK_STOPPED)状态</strong>：向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。 SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。 向进程发送一个SIGCONT信号（kill -18），可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态；或者kill -9直接尝试杀死。</p><p><strong>t (TASK_STOPPED)状态</strong>：当进程正在被跟踪时，它处于TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb（UNIX及UNIX-like下的调试工具）调试中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于TASK_TRACED状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。</p><blockquote><p> 对于进程本身来说，TASK_STOPPED和TASK_TRACED状态很类似，都是表示进程暂停下来。 而TASK_TRACED状态相当于在TASK_STOPPED之上多了一层保护，处于TASK_TRACED状态的进程不能响应SIGCONT信号而被唤醒。只能等到调试进程通过ptrace系统调用执行PTRACE_CONT、PTRACE_DETACH等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复TASK_RUNNING状态。 </p></blockquote><h2 id="5、Z-TASK-DEAD-EXIT-ZOMBIE-，退出状态，进程成为僵尸进程"><a href="#5、Z-TASK-DEAD-EXIT-ZOMBIE-，退出状态，进程成为僵尸进程" class="headerlink" title="5、Z (TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程"></a>5、Z (TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程</h2><p>进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。</p><p>之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息（保存在task_struct里）。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。</p><blockquote><p> 当父/子进程在不同时间点退出时，就可能会出现Z的细分状态： </p></blockquote><ol><li>僵尸状态 一个进程使用 fork 创建子进程，如果子进程退出后父进程没有调用 wait 或 waitpid 获取子进程的状态信息，并将子进程释放掉。那么子进程的进程描述符仍然保存在系统中，仍然占用进程表，此时进程就处于僵尸状态。 子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。出现僵尸状态可能有两种情况： 第一种情况，父进程收到通知还没来得及完成收尸，此时正常； 第二种情况，父进程收尸出现异常，此时，只要父进程不退出，子进程的僵尸状态就一直存在，可以通过<strong>杀死父进程</strong>或者<strong>重启</strong>来解决。</li><li>孤儿状态 父进程退出，相应的一个或多个子进程还在运行，那么那些子进程将处于孤儿状态，成为孤儿进程。这些进程会被托管给别的进程，托管给谁呢？可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。  1号进程，pid为1的进程，又称init进程。 linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命： 1、执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）； 2、在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作； init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于TASK_INTERRUPTIBLE状态，“收尸”过程中则处于TASK_RUNNING状态。 </li></ol><h2 id="6、X-TASK-DEAD-EXIT-DEAD-，退出状态，进程即将被销毁"><a href="#6、X-TASK-DEAD-EXIT-DEAD-，退出状态，进程即将被销毁" class="headerlink" title="6、X (TASK_DEAD - EXIT_DEAD)，退出状态，进程即将被销毁"></a>6、X (TASK_DEAD - EXIT_DEAD)，退出状态，进程即将被销毁</h2><p>进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程。或者父进程通过设置SIGCHLD信号的handler为SIG_IGN，显式的忽略了SIGCHLD信号。（这是posix的规定，尽管子进程的退出信号可以被设置为SIGCHLD以外的其他信号。） 此时，进程将被置于EXIT_DEAD退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。</p><h1 id="操作系统中的进程调度策略"><a href="#操作系统中的进程调度策略" class="headerlink" title="操作系统中的进程调度策略"></a>操作系统中的进程调度策略</h1><ul><li><p>先来先服务调度算法：先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p></li><li><p>短作业(进程)优先调度算法：短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p></li><li><p>高优先权优先调度算法：为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。</p><ul><li><p>非抢占式优先权算法：在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p></li><li><p>抢占式优先权调度算法：在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p></li><li><p>容易出现优先级倒置现象：优先级反转是指一个低优先级的任务持有一个被高优先级任务所需要的共享资源。高优先任务由于因资源缺乏而处于受阻状态，一直等到低优先级任务释放资源为止。而低优先级获得的CPU时间少，如果此时有优先级处于两者之间的任务，并且不需要那个共享资源，则该中优先级的任务反而超过这两个任务而获得CPU时间。如果高优先级等待资源时不是阻塞等待，而是忙循环，则可能永远无法获得资源，因为此时低优先级进程无法与高优先级进程争夺CPU时间，从而无法执行，进而无法释放资源，造成的后果就是高优先级任务无法获得资源而继续推进。</p></li><li><p>优先级反转案例解释：不同优先级线程对共享资源的访问的同步机制。优先级为高和低的线程tall和线程low需要访问共享资源，优先级为中等的线程mid不访问该共享资源。当low正在访问共享资源时，tall等待该共享资源的互斥锁，但是此时low被mid抢先了，导致mid运行tall阻塞。即优先级低的线程mid运行，优先级高的tall被阻塞。</p></li><li><p>优先级倒置解决方案：</p><ul><li>设置优先级上限，给临界区一个高优先级，进入临界区的进程都将获得这个高优先级，如果其他试图进入临界区的进程的优先级都低于这个高优先级，那么优先级反转就不会发生。</li><li>优先级继承，当一个高优先级进程等待一个低优先级进程持有的资源时，低优先级进程将暂时获得高优先级进程的优先级别，在释放共享资源后，低优先级进程回到原来的优先级别。嵌入式系统VxWorks就是采用这种策略</li><li>第三种方法就是临界区禁止中断，通过禁止中断来保护临界区，采用此种策略的系统只有两种优先级：可抢占优先级和中断禁止优先级。前者为一般进程运行时的优先级，后者为运行于临界区的优先级。火星探路者正是由于在临界区中运行的气象任务被中断发生的通信任务所抢占才导致故障，如果有临界区的禁止中断保护，此一问题也不会发生。</li></ul></li></ul></li><li><p>高响应比优先调度算法：在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p></li><li><p>时间片轮转法：在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。</p></li><li><p>多级反馈队列调度算法：前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统。</p></li></ul><h1 id="进程同步的四种方法"><a href="#进程同步的四种方法" class="headerlink" title="进程同步的四种方法"></a>进程同步的四种方法</h1><p><img src="https://img-blog.csdn.net/20171121130628916" alt="img"></p><p>1、临界区（Critical Section）:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</p><p>优点：保证在某一时刻只有一个线程能访问数据的简便办法</p><p>缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。</p><p>2、互斥量（Mutex）:为协调共同对一个共享资源的单独访问而设计的。</p><p>互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。</p><p>优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p><p>缺点：①互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</p><p>②通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。</p><p>3、信号量（Semaphore）:为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了。</p><p>优点：适用于对Socket（套接字）程序中线程的同步。（例如，网络上的HTTP服务器要对同一时间内访问同一页面的用户数加以限制，只有不大于设定的最大用户数目的线程能够进行访问，而其他的访问企图则被挂起，只有在有用户退出对此页面的访问后才有可能进入。）</p><p>缺点：①信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点；</p><p>②信号量机制功能强大，但使用时对信号量的操作分散， 而且难以控制，读写和维护都很困难，加重了程序员的编码负担；</p><p>③核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。 </p><p>4、事件（Event）: 用来通知线程有一些事件已发生，从而启动后继任务的开始。</p><p>优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。</p><p>缺点：</p><p>总结：</p><p>①临界区不是内核对象，只能用于进程内部的线程同步，是用户方式的同步。互斥、信号量是内核对象可以用于不同进程之间的线程同步（跨进程同步）。<br>②互斥其实是信号量的一种特殊形式。互斥可以保证在某一时刻只有一个线程可以拥有临界资源。信号量可以保证在某一时刻有指定数目的线程可以拥有临界资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux系统之进程状态&quot;&gt;&lt;a href=&quot;#Linux系统之进程状态&quot; class=&quot;headerlink&quot; title=&quot;Linux系统之进程状态&quot;&gt;&lt;/a&gt;Linux系统之进程状态&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;D：uninterruptible sleep </summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>05.编写Netty应用程序</title>
    <link href="https://leslieaibin.github.io/2022/05/23/Netty/05.Netty%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/"/>
    <id>https://leslieaibin.github.io/2022/05/23/Netty/05.Netty%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/</id>
    <published>2022-05-23T11:15:42.000Z</published>
    <updated>2022-05-24T03:08:27.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="05-Netty服务启动"><a href="#05-Netty服务启动" class="headerlink" title="05.Netty服务启动"></a>05.Netty服务启动</h1><p>之前讲过的 EchoServer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 声明线程池</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EchoServerHandler echoServerHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 服务端引导器</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">// 3. 设置线程池</span></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 4. 设置ServerSocketChannel的类型</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 5. 设置参数</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">                    <span class="comment">// 6. 设置ServerSocketChannel对应的Handler，只能设置一个</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// 7. 设置SocketChannel对应的Handler</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline p = ch.pipeline();</span><br><span class="line">                            <span class="comment">// 可以添加多个子Handler</span></span><br><span class="line">                            p.addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">                            p.addLast(echoServerHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 绑定端口</span></span><br><span class="line">            ChannelFuture f = serverBootstrap.bind(PORT).sync();</span><br><span class="line">            <span class="comment">// 9. 等待服务端监听端口关闭，这里会阻塞主线程</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 10. 优雅地关闭两个线程池</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>通过前面使用案例的学习，我们知道，Netty 启动的时候主要是下面这行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f = serverBootstrap.bind(PORT).sync();</span><br></pre></td></tr></table></figure><p>这里主要有两个方法，一个是 bind ()，一个是 sync ()，sync () 属于 ChannelFuture 的范畴，我们之后再说：</p><ol><li> Netty 的 Channel 跟 Java 原生的 Channel 是否有某种关系？</li><li> bind () 是否调用了 Java 底层的 Socket 相关的操作？</li><li> Netty 服务启动之后 ChannelPipeline 里面长什么样？</li></ol><p>好了，让我们带着这几个问题探索吧。</p><h2 id="服务启动过程剖析"><a href="#服务启动过程剖析" class="headerlink" title="服务启动过程剖析"></a>服务启动过程剖析</h2><p>让我们将断点打在 <code>ChannelFuture f = serverBootstrap.bind(PORT).sync();</code> 这行，以 Debug 模式启动程序，程序会停在此处，按 F7 或者 Shirft+F7 进入 bind () 方法内部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们只传进来了一个端口，而使用 <code>InetSocketAddress</code> 类构造了一个地址，默认的，会生成一个 <code>0.0.0.0:8007</code> 的地址。</p><p>接着往下走，会来到一个叫 <code>doBind()</code> 的方法，一般地，在开源框架中带 <code>doXxx</code> 开头的方法都是干正事的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key1，初始化并注册什么呢？</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="comment">// 注册失败</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已完成，上面未失败，所以这里是已完成且成功了</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        <span class="comment">// key2，绑定什么呢？取决于initAndRegister()中异步执行的快慢，所以不一定到这里，这里可以打一个断点</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未完成</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        <span class="comment">// 设置回调等待完成，回调内部处理注册的结果</span></span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="comment">// 注册失败</span></span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 注册成功</span></span><br><span class="line">                    promise.registered();</span><br><span class="line">                    <span class="comment">// key2，绑定什么呢？取决于initAndRegister()中异步执行的快慢，所以不一定到这里，这里可以打一个断点</span></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关键方法，我前面加上一个 <code>key</code> 表示。</p></blockquote><p><code>doBind()</code> 主要干了两件事：</p><ul><li>  initAndRegister ()，初始化并注册什么呢？</li><li>  doBind0 ()，到底绑定的是什么？</li></ul><p>让我们继续跟进到 <code>initAndRegister()</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// key1，通过ChannelFactory创建一个Channel，使用反射的形式创建一个Channel</span></span><br><span class="line">        <span class="comment">// 反射的类为我们第4步中设置的NioServerSocketChannel.class</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// key2，初始化Channel，干了些什么？</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常处理，可以不看</span></span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key3，注册Channel到哪里？这里有个group()，难道是EventLoopGroup？</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="comment">// 失败了，关闭Channel</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initAndRegister</code> 主要干了三个事：</p><ul><li><p>  channelFactory.newChannel ()，通过反射的形式创建 Channel，而且是无参构造方法，new 的时候做了哪些事儿？</p></li><li><p>  <code>init(channel)</code>，初始化 Channel 的什么？</p></li><li><p>  <code>register(channel)</code>，注册 Channel 到哪里？</p></li></ul><p>因为我们这里使用的是 NioServerSocketChannel，所以，直接查看它的无参构造方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 无参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.1 使用Java底层的SelectorProvider创建一个Java原生的ServerSocketChannel</span></span><br><span class="line"><span class="comment">// windows平台下使用的是WindowsSelectorProvider，因为ServerSocketChannel是跟操作系统交互的，所以是平台相关的，每个平台下都不一样</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// key，创建Java原生ServerSocketChannel</span></span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">            <span class="string">&quot;Failed to open a server socket.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.2 有参构造方法，参数是Java原生的ServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造方法，注意parent参数为null</span></span><br><span class="line">    <span class="comment">// key，感兴趣的事件为Accept事件</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="comment">// 创建ChannelConfig</span></span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.2.1 调用父类构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioMessageChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, readInterestOp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.2.1.1 调用父类父类的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造方法，parent为null</span></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">// ch为Java原生的Channel</span></span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="comment">// 感兴趣的事件，这里为Accept事件</span></span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将channel设置为非阻塞（是不是跟NIO案例中的用法一样？！）</span></span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                <span class="string">&quot;Failed to close a partially initialized socket.&quot;</span>, e2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Failed to enter non-blocking mode.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  1.2.1.1.1 调用父类父类父类的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时parent为null</span></span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="comment">// 赋予一个id</span></span><br><span class="line">    id = newId();</span><br><span class="line">    <span class="comment">// 赋值了一个unsafe，非Java的Unsafe，而是Netty自己的Unsafe</span></span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    <span class="comment">// 创建ChannelPipeline</span></span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.2.1.1.1.1 创建默认的ChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// ChannelPipeline中默认有两个节点，head和tail，且是双向链表</span></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里 NioServerSocketChannel 的创建过程就完毕了，我们简单总结一下：</p><ol><li> Netty 的 ServerSocketChannel 会与 Java 原生的 ServerSocketChannel 绑定在一起；</li><li> 会注册 Accept 事件；</li><li> 会为每一个 Channel 分配一个 id；</li><li> 会为每一个 Channel 创建一个叫作 unsafe 的东西；</li><li> 会为每一个 Channel 分配一个 ChannelPipeline；</li><li> ChannelPipeline 中默认存在一个双向链表 <code>head&lt;=&gt;tail</code>；</li></ol><p>好了，再来看 <code>init(channel)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.bootstrap.ServerBootstrap#init</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将第5步中设置到ServerBootstrap中的Option设置到Channel的Config中</span></span><br><span class="line">    setChannelOptions(channel, options0().entrySet().toArray(EMPTY_OPTION_ARRAY), logger);</span><br><span class="line">    <span class="comment">// 设置一些属性到Channel中，用法与Option一样</span></span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));</span><br><span class="line">    <span class="comment">// 从Channel中取出ChannelPipeline，上面创建的</span></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子Channel的配置，子Channel也就是SocketChannel</span></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions =</span><br><span class="line">        childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将ServerBootstrap中的Handler设置到ChannelPipeline的最后</span></span><br><span class="line">    <span class="comment">// ChannelInitializer的实现原理？</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            <span class="comment">// 第6步设置的Handler</span></span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 同时，又向ChannelPipeline的最后添加了一个叫作ServerBootstrapAcceptor的Handler</span></span><br><span class="line">            <span class="comment">// 这是什么写法？</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 把子Channel相关的参数传到这个Handler里面，那它是干什么的呢？</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init(channel)</code> 方法整体来说还是比较简单的，就是把 ServerBootstrap 中的配置设置到 Channel 中，不过依然有几处我们现在可能还不太理解的地方：</p><ul><li>  ChannelInitializer 的实现原理是什么？</li><li>  <code>ch.eventLoop().execute()</code> 这是什么写法？</li><li>  ServerBootstrapAcceptor 是干什么？</li></ul><p>这三个问题，我们留到后面的章节中再解答。</p><p>好了，我们再来看看 <code>initAndRegister()</code> 方法的最后一个关键步骤，<code>ChannelFuture regFuture = config().group().register(channel);</code> 注册 Channel 到什么地方？</p><p>查看源码，可以发现，这里的 group 就是我们的 bossGroup，所以这里就是调用 bossGroup 的 <code>register(channel)</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用 <code>next()</code> 方法选择出来一个 EventLoop 来注册 Channel，里面实际上使用的是一个叫做 <code>EventExecutorChooser</code> 的东西来选择，它实际上又有两种实现方式 ——<code>PowerOfTwoEventExecutorChooser</code> 和 <code>GenericEventExecutorChooser</code>，本质上就是从 EventExecutor 数组中选择一个 EventExecutor，我们这里就是 NioEventLoop，那么，它们有什么区别呢？有兴趣的可以点开它们的源码看看，我简单地提一下，本质都是按数组长度取余数 ，不过，2 的 N 次方的形式更高效。</p><p>最后，来到了 EventLoop 的 <code>register(channel)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.Channel)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    <span class="comment">// key，调用的是channel的unsafe的register()方法</span></span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，先创建了一个叫做 <code>ChannelPromise</code> 的东西，它是 ChannelFuture 的子类，暂时先把它当作 ChannelFuture 来看待。最后，又调回了 Channel 的 Unsafe 的 register () 方法，这里第一个参数是 this，也就是 NioEventLoop，第二个参数是刚创建的 ChannelPromise。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.AbstractChannel.AbstractUnsafe#register</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 各种检查，可以跳过</span></span><br><span class="line">    ObjectUtil.checkNotNull(eventLoop, <span class="string">&quot;eventLoop&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registered to an event loop already&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">            <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key1，将上面传进来的EventLoop绑定到Channel上</span></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">    <span class="comment">// 判断当前线程是否跟EventLoop线程是同一个</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// key2，调用register0</span></span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// key2，调用register0，实际走的是这里，所以这里需要打个断点</span></span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 异常处理，可以跳过</span></span><br><span class="line">            logger.warn(</span><br><span class="line">                <span class="string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,</span><br><span class="line">                AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要干了两件事：</p><ul><li>  把 EventLoop 与 Channel 绑定在一起；</li><li>  调用 register0 () 方法；</li></ul><p>这里又出现了 eventLoop.execute () 这种写法，先忽略它，专注于主要逻辑。</p><p>接着，跟踪到 <code>register0()</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.AbstractChannel.AbstractUnsafe#register0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断检查，可以跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        <span class="comment">// key1，调用doRegister()方法</span></span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key2，调用invokeHandlerAddedIfNeeded()</span></span><br><span class="line">        <span class="comment">// 触发添加Handler的回调，其中pineline.addLast(ChannelInitializer)的处理就是在这一步完成的</span></span><br><span class="line">        <span class="comment">// 这一步之后pipeline里面应该是head&lt;=&gt;LoggineHandler&lt;=&gt;tail</span></span><br><span class="line">        <span class="comment">// 而ServerBootstrapAcceptor还没有加入到pipeline中，</span></span><br><span class="line">        <span class="comment">// 因为它设置了使用EventLoop的线程执行，当前线程就是EventLoop的线程</span></span><br><span class="line">        <span class="comment">// 所以，添加ServerBootstrapAcceptor会在当前任务执行完毕才会执行</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        <span class="comment">// 调用ChannelPineline的fireChannelRegistered()，实际是调用的各个ChannelHandler的channelRegistered()方法</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="comment">// Channel是否已经激活，此时还未绑定到具体的地址，所以还未激活</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常处理，可以跳过</span></span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>这里有两个个非常重要的方法：</p><ul><li>  doRegister ()，一看就是干正事的方法</li><li>  pipeline.invokeHandlerAddedIfNeeded ()，触发添加 Handler 的回调，其中 pineline.addLast (ChannelInitializer) 的处理就是在这一步完成的，有兴趣的同学可以跟踪看一下，这一块我们本节不详细展开</li></ul><p>先来看 <code>doRegister()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.nio.AbstractNioChannel#doRegister</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// key，将EventLoop中的Selector与Java原生的Channel绑定在一起，并返回这个SelectionKey</span></span><br><span class="line">            <span class="comment">// 注意，第三个参数是this，代表的是当前这个Netty中的Channel，我们这里就是NioServerSocketChannel</span></span><br><span class="line">            <span class="comment">// 它作为Selection的attachment绑定到SelectionKey上，与JavaChannel和Selector是同一个级别的</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理，可以跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实就一行关键代码，将 Selector 与 Java 原生 Channel 绑定在一起，并将当前 Netty 的 Channel 通过 attachment 的形式绑定到 SelectionKey 上，到这里，你可能会有疑问：为什么要把 Netty 的 Channel 当作附件放到 SelectionKey 中呢？后面你会知道的，相信我。</p><p>所以，整个注册的过程主要就干了三个事：</p><ol><li> 把 Channel 绑定到一个 EventLoop 上；</li><li> 把 Java 原生 Channel、Netty 的 Channel、Selector 绑定到 SelectionKey 中；</li><li> 触发 Register 相关的事件；</li></ol><p>至此，<code>initAndRegister()</code> 方法内部就分析完成了，我们再来看看另一个重要方法 <code>doBind0()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. io.netty.bootstrap.AbstractBootstrap#doBind0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步执行</span></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                <span class="comment">// key，调用Channel的bind()方法，因为在线程池里面，所以这里要打一个断点</span></span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 调用Channel的bind()方法 io.netty.channel.AbstractChannel#bind(java.net.SocketAddress, io.netty.channel.ChannelPromise)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用的是pipeline的bind()方法</span></span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 调用的是pipeline的bind()方法io.netty.channel.DefaultChannelPipeline#bind(java.net.SocketAddress, io.netty.channel.ChannelPromise)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从尾开始调用，也就是outbound</span></span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 此时pipeline中的Handler为head&lt;=&gt;LoggingHandler&lt;=&gt;ServerBootstrapAcceptor&lt;=&gt;tail，出站的pineple实际为tail=&gt;LoggingHandler=&gt;head，下面我只贴主要代码</span></span><br><span class="line"><span class="comment">// 5. io.netty.handler.logging.LoggingHandler#bind</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isEnabled(internalLevel)) &#123;</span><br><span class="line">        logger.log(internalLevel, format(ctx, <span class="string">&quot;BIND&quot;</span>, localAddress));</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6. io.netty.channel.DefaultChannelPipeline.HeadContext#bind</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最后调用的是HeadContext这个Handler中unsafe的bind()方法</span></span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7. io.netty.channel.AbstractChannel.AbstractUnsafe#bind</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// key，绑定地址</span></span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 成功激活，调用pipeline.fireChannelActive()方法</span></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置promise为成功状态</span></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8. 绕了一圈，最后又回到了NioServerChannel的doBind()方法 io.netty.channel.socket.nio.NioServerSocketChannel#doBind</span></span><br><span class="line"><span class="meta">@SuppressJava6Requirement(reason = &quot;Usage guarded by java version check&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 根据不同的JDK版本调用不同的方法</span></span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="comment">// 我使用的JDK8版本，所以走到这里了</span></span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>doBind0()</code> 最后也是通过 Java 原生 Channel 的 bind () 方法来实现的。</p><p>最后，我们来总结一下整个服务启动的过程，服务启动主要是通过两个主要的大方法来完成的：</p><ol><li>initAndRegister ()，初始化并注册什么呢？<ul><li>channelFactory.newChannel()<ul><li>  通过反射创建一个 NioServerSocketChannel</li><li>  将 Java 原生 Channel 绑定到 NettyChannel 中</li><li>  注册 Accept 事件</li><li>  为 Channel 分配 id</li><li>  为 Channel 创建 unsafe</li><li>  为 Channel 创建 ChannelPipeline（默认是 head&lt;=&gt;tail 的双向链表）</li></ul></li><li>init(channel)<ul><li>  把 ServerBootstrap 中的配置设置到 Channel 中</li><li>  添加 ServerBootstrapAcceptor 这个 Handler</li></ul></li><li>register(channel)<ul><li>  把 Channel 绑定到一个 EventLoop 上</li><li>  把 Java 原生 Channel、Netty 的 Channel、Selector 绑定到 SelectionKey 中</li><li>  触发 Register 相关的事件</li></ul></li></ul></li><li>doBind0 ()，到底绑定的是什么？<ul><li>  通过 Java 原生 Channel 绑定到一个本地地址上</li></ul></li></ol><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=http://img1.sycdn.imooc.com/5f1805890001d7af18450993.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;05-Netty服务启动&quot;&gt;&lt;a href=&quot;#05-Netty服务启动&quot; class=&quot;headerlink&quot; title=&quot;05.Netty服务启动&quot;&gt;&lt;/a&gt;05.Netty服务启动&lt;/h1&gt;&lt;p&gt;之前讲过的 EchoServer：&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>04.编写Netty应用程序</title>
    <link href="https://leslieaibin.github.io/2022/05/17/Netty/04.%E7%BC%96%E5%86%99Netty%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://leslieaibin.github.io/2022/05/17/Netty/04.%E7%BC%96%E5%86%99Netty%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-05-17T11:15:42.000Z</published>
    <updated>2022-05-17T06:52:00.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编写Netty应用程序"><a href="#编写Netty应用程序" class="headerlink" title="编写Netty应用程序"></a>编写Netty应用程序</h1><p>从 <code>netty-example</code> 工程下抄了一份 EchoServer 过来，并删减了部分代码，归纳出来一份编写 Netty 服务端程序的模板，我把它称为 “Netty 编码十步曲”。</p><h2 id="1-声明线程池（必须）"><a href="#1-声明线程池（必须）" class="headerlink" title="1. 声明线程池（必须）"></a>1. 声明线程池（必须）</h2><p>一般来说，我们会声明两个 Group，一个是 bossGroup，用于处理 Accept 事件，一个是 workerGroup，用于处理消息的读写事件。其中，bossGroup 一般声明为一个线程。当然，如果声明一个 Group 也是可以的，只是不建议。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure><p>这就像是大型餐厅一般有接待生和服务员两种职位一样，接待生一般形象良好，专门负责接待客人，服务员形象稍差，专门负责上菜收碟，你要说不区分两种职位，混用行不行呢，当然也可以，只是不建议，专人干专事。</p><h2 id="2-创建服务端引导类（必须）"><a href="#2-创建服务端引导类（必须）" class="headerlink" title="2. 创建服务端引导类（必须）"></a>2. 创建服务端引导类（必须）</h2><p>引导类，是用来集成所有配置，引导程序加载的，分成两种，一种是客户端引导类 Bootstrap（个人觉得叫 ClientBootstrap 可能更贴切），另一种是服务端引导类 ServerBootstrap，我们这里编写的是服务端程序，创建的当然是服务端引导类。<br>注意，Bootstrap 和 ServerBootstrap 之间并不是继承关系，他们是平等的，都继承了 AbstractBootstrap 抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br></pre></td></tr></table></figure><p>Bootstrap/ServerBootstrap 就像是店长，它负责统筹整个 Netty 程序的正常运行。</p><h2 id="3-设置线程池（必须）"><a href="#3-设置线程池（必须）" class="headerlink" title="3. 设置线程池（必须）"></a>3. 设置线程池（必须）</h2><p>把第一步声明的线程池设置到 ServerBootstrap 中，它说明了 Netty 应用程序以什么样的线程模型运行，正如前面所说 bossGroup 负责接受（Accept）连接，workerGroup 负责读写数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure><h2 id="4-设置-ServerSocketChannel-类型（必须）"><a href="#4-设置-ServerSocketChannel-类型（必须）" class="headerlink" title="4. 设置 ServerSocketChannel 类型（必须）"></a>4. 设置 ServerSocketChannel 类型（必须）</h2><p>设置 Netty 程序以什么样的 IO 模型运行，我们这里介绍的是 NIO 编程，选择的当然是 NioServerSocketChannel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.channel(NioServerSocketChannel.class);</span><br></pre></td></tr></table></figure><p>如果您需要使用阻塞型 IO 模型，直接把 Nio 改成 Oio 就可以了，即 OioServerSocketChannel，不过它已经废弃了，所以不建议。</p><p>另外，如果您的程序运行在 Linux 系统上，还可以使用一种更高效的方式，即 EpollServerSocketChannel，它使用的是 Linux 系统上的 epoll 模型，比 select 模型更高效，可见 Netty 把性能优化做到了极致。</p><h2 id="5-设置参数（可选）"><a href="#5-设置参数（可选）" class="headerlink" title="5. 设置参数（可选）"></a>5. 设置参数（可选）</h2><p>设置 Netty 中可以使用的任何参数，这些参数都在 ChannelOption 及其子类中，后面我们会详细介绍各个参数的含义，不过，很遗憾地告诉你，大多数情况下并不需要修改 Netty 的默认参数，这就是 Netty 比较牛的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.option(ChannelOption.SO_BACKLOG, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>我们这里设置了一个 SO_BACKLOG 系统参数，它表示的是最大等待连接数量。</p><h2 id="6-设置-Handler（可选）"><a href="#6-设置-Handler（可选）" class="headerlink" title="6. 设置 Handler（可选）"></a>6. 设置 Handler（可选）</h2><p>设置 ServerSocketChannel 对应的 Handler，注意只能设置一个，它会在 SocketChannel 建立起来之前执行，等我们看源码的时候会详细介绍它的执行时机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br></pre></td></tr></table></figure><p>我们这里简单地设置一个打印日志的 Handler。</p><h2 id="7-编写并设置子-Handler（必须）"><a href="#7-编写并设置子-Handler（必须）" class="headerlink" title="7. 编写并设置子 Handler（必须）"></a>7. 编写并设置子 Handler（必须）</h2><p>Netty 中的 Handler 分成两种，一种叫做 Inbound，一种叫做 Outbound。我们这里简单地写一个 Inbound 类型的 Handler，它接收到数据后立即写回客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 读取数据后写回客户端</span></span><br><span class="line">ctx.write(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">ctx.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">cause.printStackTrace();</span><br><span class="line">ctx.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置子 Handler 设置的是 SocketChannel 对应的 Handler，注意也是只能设置一个，它用于处理 SocketChannel 的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ChannelPipeline p = ch.pipeline();</span><br><span class="line"><span class="comment">// 可以添加多个子Handler</span></span><br><span class="line">p.addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">p.addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>虽然只能设置一个，但是 Netty 的提供了一种可以设置多个 Handler 的途径，即使用 ChannelInitializer 方式，当然，第六步的设置 Handler 也可以使用这种方式设置多个 Handler。</p><p>这里，我们设置了一个打印的 Handler 和一个自定义的 EchoServerHandler。</p><h2 id="8-绑定端口（必须）"><a href="#8-绑定端口（必须）" class="headerlink" title="8. 绑定端口（必须）"></a>8. 绑定端口（必须）</h2><p>绑定端口，并启动服务端程序，sync () 会阻塞直到启动完成才执行后面的代码。</p><pre><code>ChannelFuture f = serverBootstrap.bind(PORT).sync();</code></pre><h2 id="9-等待服务端端口关闭（必须）"><a href="#9-等待服务端端口关闭（必须）" class="headerlink" title="9. 等待服务端端口关闭（必须）"></a>9. 等待服务端端口关闭（必须）</h2><p>等待服务端监听端口关闭，sync () 会阻塞主线程，内部调用的是 Object 的 wait () 方法。</p><pre><code>f.channel().closeFuture().sync();</code></pre><h2 id="10-优雅地关闭线程池（建议）"><a href="#10-优雅地关闭线程池（建议）" class="headerlink" title="10. 优雅地关闭线程池（建议）"></a>10. 优雅地关闭线程池（建议）</h2><p>最后，是在 finally 中调用 shutdownGracefully () 方法优雅地关闭线程池，优雅停机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bossGroup.shutdownGracefully();</span><br><span class="line">workerGroup.shutdownGracefully();</span><br></pre></td></tr></table></figure><p><strong>为什么需要设置 ServerSocketChannel 的类型，而不需要设置 SocketChannel 的类型呢？</strong></p><p>那是因为 SocketChannel 是 ServerSocketChannel 在接受连接之后创建出来的，所以，并不需要单独再设置它的类型，比如，NioServerSocketChannel 创建出来的肯定是 NioSocketChannel，而 EpollServerSocketChannel 创建出来的肯定是 EpollSocketChannel。</p><h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><p>其实学 Netty 的 99% 都是服务端的同学，所以，我们的课程并不会刻意介绍如何编写客户端的 Netty 程序，但是我们怎么调试呢？</p><p>这里，我教给大家一个技巧，通过 XSHELL 这个工具调试，这个工具几乎是后端同学必备的一个工具，所以调试起来也是比较容易的。</p><p>比如，我上面启动了一个 Netty 服务端，它的端口是 8007，只要打开 Terminal，不要连接任何服务器，输入以下代码即可连接到我们的 Netty 服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 8007</span><br></pre></td></tr></table></figure><p>然后，输入任何你想输入的内容，它都会照样返回，比如下面这样：</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220517144316303.png" alt="image-20220517144316303"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本节，我们学习了 Netty 编码的十步曲，其中，有些步骤是必须的，有些步骤可选的，有些步骤是建议保留的，相信通过本节的学习，你一定可以写出十分健壮且优雅的 Netty 服务端程序了。</p><p>别急哦，本节还没有结束，在附录部分有一份简单的群聊系统，您也可以尝试按照本节介绍的十步曲自己尝试写一个简单的示例练练手。</p><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img1.sycdn.imooc.com/5f0d610d0001afcc10830670.png"></p><h2 id="附录-——-使用-Netty-实现简单群聊系统"><a href="#附录-——-使用-Netty-实现简单群聊系统" class="headerlink" title="附录 —— 使用 Netty 实现简单群聊系统"></a>附录 —— 使用 Netty 实现简单群聊系统</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 1. 声明线程池</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 2. 服务端引导器</span></span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"><span class="comment">// 3. 设置线程池</span></span><br><span class="line">serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line"><span class="comment">// 4. 设置ServerSocketChannel的类型</span></span><br><span class="line">.channel(NioServerSocketChannel.class)</span><br><span class="line"><span class="comment">// 5. 设置参数</span></span><br><span class="line">.option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line"><span class="comment">// 6. 设置ServerSocketChannel对应的Handler，只能设置一个</span></span><br><span class="line">.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line"><span class="comment">// 7. 设置SocketChannel对应的Handler</span></span><br><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ChannelPipeline p = ch.pipeline();</span><br><span class="line"><span class="comment">// 可以添加多个子Handler</span></span><br><span class="line">p.addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line"><span class="comment">// 只需要改这一个地方就可以了</span></span><br><span class="line">p.addLast(<span class="keyword">new</span> ChatNettyHandler());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 绑定端口</span></span><br><span class="line">ChannelFuture f = serverBootstrap.bind(PORT).sync();</span><br><span class="line"><span class="comment">// 9. 等待服务端监听端口关闭，这里会阻塞主线程</span></span><br><span class="line">f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 10. 优雅地关闭两个线程池</span></span><br><span class="line">bossGroup.shutdownGracefully();</span><br><span class="line">workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatNettyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;one conn active: &quot;</span> + ctx.channel());</span><br><span class="line"><span class="comment">// channel是在ServerBootstrapAcceptor中放到EventLoopGroup中的</span></span><br><span class="line">ChatHolder.join((SocketChannel) ctx.channel());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes()];</span><br><span class="line">byteBuf.readBytes(bytes);</span><br><span class="line">String content = <span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class="line">System.out.println(content);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (content.equals(<span class="string">&quot;quit\r\n&quot;</span>)) &#123;</span><br><span class="line">ctx.channel().close();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ChatHolder.propagate((SocketChannel) ctx.channel(), content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;one conn inactive: &quot;</span> + ctx.channel());</span><br><span class="line">ChatHolder.quit((SocketChannel) ctx.channel());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Map&lt;SocketChannel, String&gt; USER_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加入群聊</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> socketChannel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(SocketChannel socketChannel)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 有人加入就给他分配一个id</span></span><br><span class="line">String userId = <span class="string">&quot;用户&quot;</span> + ThreadLocalRandom.current().nextInt(Integer.MAX_VALUE);</span><br><span class="line">send(socketChannel, <span class="string">&quot;您的id为：&quot;</span> + userId + <span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (SocketChannel channel : USER_MAP.keySet()) &#123;</span><br><span class="line">send(channel, userId + <span class="string">&quot; 加入了群聊&quot;</span> + <span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前用户加入到map中</span></span><br><span class="line">USER_MAP.put(socketChannel, userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 退出群聊</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> socketChannel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">(SocketChannel socketChannel)</span> </span>&#123;</span><br><span class="line">String userId = USER_MAP.get(socketChannel);</span><br><span class="line">send(socketChannel, <span class="string">&quot;您退出了群聊&quot;</span> + <span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">USER_MAP.remove(socketChannel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (SocketChannel channel : USER_MAP.keySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (channel != socketChannel) &#123;</span><br><span class="line">send(channel, userId + <span class="string">&quot; 退出了群聊&quot;</span> + <span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩散说话的内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> socketChannel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">propagate</span><span class="params">(SocketChannel socketChannel, String content)</span> </span>&#123;</span><br><span class="line">String userId = USER_MAP.get(socketChannel);</span><br><span class="line"><span class="keyword">for</span> (SocketChannel channel : USER_MAP.keySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (channel != socketChannel) &#123;</span><br><span class="line">send(channel, userId + <span class="string">&quot;: &quot;</span> + content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送消息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> socketChannel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(SocketChannel socketChannel, String msg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ByteBufAllocator allocator = ByteBufAllocator.DEFAULT;</span><br><span class="line">ByteBuf writeBuffer = allocator.buffer(msg.getBytes().length);</span><br><span class="line">writeBuffer.writeCharSequence(msg, Charset.defaultCharset());</span><br><span class="line">socketChannel.writeAndFlush(writeBuffer);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，只需要改动设置子 Handler 里面的那一个地方就可以了，其它地方完全不需要修改，非常便捷。</p><h2 id="模拟群聊"><a href="#模拟群聊" class="headerlink" title="模拟群聊"></a>模拟群聊</h2><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220517145013600.png" alt="image-20220517145013600"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编写Netty应用程序&quot;&gt;&lt;a href=&quot;#编写Netty应用程序&quot; class=&quot;headerlink&quot; title=&quot;编写Netty应用程序&quot;&gt;&lt;/a&gt;编写Netty应用程序&lt;/h1&gt;&lt;p&gt;从 &lt;code&gt;netty-example&lt;/code&gt; 工程下抄了</summary>
      
    
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>03.Java NIO的核心组件</title>
    <link href="https://leslieaibin.github.io/2022/05/17/Netty/03.%20Java%20NIO%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>https://leslieaibin.github.io/2022/05/17/Netty/03.%20Java%20NIO%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</id>
    <published>2022-05-17T01:15:42.000Z</published>
    <updated>2022-05-17T03:23:05.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="03-Java-NIO的核心组件"><a href="#03-Java-NIO的核心组件" class="headerlink" title="03.Java NIO的核心组件"></a>03.Java NIO的核心组件</h1><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><strong>什么是 Channel 呢？</strong> 让我们来看看 JDK 怎么说：</p><blockquote><p>// java.nio.channels.Channel</p><p>A nexus for I/O operations.</p><p>A channel represents an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct I/O operations, for example reading or writing.</p></blockquote><p><strong>Channel 是一种 IO 操作的连接</strong>（nexus，连接的意思），它代表的是到实体的开放连接，这个实体可以是硬件设备、文件、网络套接字或者可执行 IO 操作（比如读、写）的程序组件。</p><p>在 linux 系统中，一切皆可看作是文件，所以，简单点讲，Channel 就是到文件的连接，并可以通过 IO 操作这些文件。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220517110316979.png" alt="image-20220517110316979"><br>因此，针对不同的文件类型又衍生出了<strong>不同类型的 Channel</strong>：</p><ul><li>  FileChannel：操作普通文件</li><li>  DatagramChannel：用于 UDP 协议</li><li>  SocketChannel：用于 TCP 协议，客户端与服务端之间的 Channel</li><li>  ServerSocketChannel：用于 TCP 协议，仅用于服务端的 Channel</li></ul><blockquote><p>ServerSocketChannel 和 SocketChannel 是专门用于 TCP 协议中的。<br>ServerSocketChannel 是一种服务端的 Channel，只能用在服务端，可以看作是到网卡的一种 Channel，它监听着网卡的某个端口。<br>SocketChannel 是一种客户端与服务端之间的 Channel，客户端连接到服务器的网卡之后，被服务端的 Channel 监听到，然后与客户端之间建立一个 Channel，这个 Channel 就是 SocketChannel。</p></blockquote><p>那么，这些 <strong>Channel 又该如何使用呢？</strong> 我们以 FileChannel 为代表来写一个简单的示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 从文件获取一个FileChannel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;D:\\object.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">        <span class="comment">// 声明一个Byte类型的Buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 将FileChannel中的数据读出到buffer中，-1表示读取完毕</span></span><br><span class="line">        <span class="comment">// buffer默认为写模式</span></span><br><span class="line">        <span class="comment">// read()方法是相对channel而言的，相对buffer就是写</span></span><br><span class="line">        <span class="keyword">while</span> ((fileChannel.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// buffer切换为读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// buffer中是否有未读数据</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 未读数据的长度</span></span><br><span class="line">                <span class="keyword">int</span> remain = buffer.remaining();</span><br><span class="line">                <span class="comment">// 声明一个字节数组</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[remain];</span><br><span class="line">                <span class="comment">// 将buffer中数据读出到字节数组中</span></span><br><span class="line">                buffer.get(bytes);</span><br><span class="line">                <span class="comment">// 打印出来</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清空buffer，为下一次写入数据做准备</span></span><br><span class="line">            <span class="comment">// clear()会将buffer再次切换为写模式</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的示例，我们可以发现，Channel 是和 Buffer 一起使用的，那么，什么是 Buffer 呢？为什么要和 Buffer 一起使用呢？必须吗？</p><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p><strong>什么是 Buffer 呢？</strong> 让我们再来看看 JDK 怎么说：</p><blockquote><p>// java.nio.Buffer</p><p>A container for data of a specific primitive type.</p><p>A buffer is a linear, finite sequence of elements of a specific primitive type. Aside from its content, the essential properties of a buffer are its capacity, limit, and position.</p></blockquote><p>Buffer 是一个容器，什么样的容器呢？存放数据的容器。存放什么样的数据呢？特定基本类型的数据。这个容器有哪些特点呢？它是线性的，有限的序列，元素是某种基本类型的数据。它又有哪些属性呢？主要有三个属性：<strong>capacity、limit、position</strong>。</p><p>那么，<strong>Buffer 为什么要和 Channel 一起使用呢？必须一起使用吗？</strong></p><p>打个比方，我们知道，山西盛产煤这种资源，一粒一粒的煤我们可以看作是数据。煤要往外运，那就需要修铁路，比如从山西运到上海，那就要修一条从山西到上海的铁路，这条铁路就相当于是连接山西和上海的通道（Channel）。数据和通道都有了，煤要放在哪里运过去呢？那就需要一种容器，有人可能会想到火车，其实火车可以看作是运输的一种方式或者叫协议，不使用火车，使用滑板车可不可以呢？其实也可以，只是运输的风险比较大而已，所以，火车可以看作是 TCP 协议，而滑板车是 UDP 协议。真正的容器应该是装煤的箱子，也就是 Buffer。</p><p>它们之间的关系如下图所示：</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220517110842715.png" alt="image-20220517110842715"></p><p>所以，Channel 和 Buffer 能不能单独使用呢？其实也可以，只是意义不大，比如，声明了一个 Channel 啥也不干，声明了一个 Buffer 里面存放一些数据啥也不干，意义不大，数据有交互才有意义，所以我们一般把 Channel 和 Buffer 一起使用，从 Channel 读取数据到 Buffer 中，或者从 Buffer 写入数据到 Channel 中。</p><p><strong>NIO 的传输方式和传统的基于 BIO 的传输方式基本是类似的，那么，它们有什么区别呢</strong>？</p><p>首先，BIO 是面向流的，而 NIO 是面向 Channel 或者面向缓冲区的，它的效率更高。</p><p>其次，流是单向的，所以又分成 InputStream 和 OutputStream，而 Channel 是双向的，既可读也可写。</p><p>然后，流只支持同步读写，而 Channel 是可以支持异步读写的。</p><p>最后，流一般与字节数组或者字符数组配合使用，而 Channel 一般与 Buffer 配合使用。</p><p>我们知道了 Buffer 是一个容器，它里面存储的是特定的基本类型，那么，<strong>有哪些类型的 Buffer 呢？</strong></p><p>我们知道基本类型有：byte、char、short、int、long、float、double、boolean，那么是不是每一种基本类型对应一种 Buffer 呢？嗯，基本上是这样，除了 boolean 没有对应的 Buffer 以外，其它的类型都有对应的 Buffer，因为 boolean 本质上就是 0 和 1 两种情况，Java 字节码层面也是用 0 和 1 来表示 boolean 类型的 false 和 true 的。</p><p>所以，Buffer 的类型有：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。</p><p>上面是按照基本类型的角度来划分的，其实针对每一种类型还有不同的内存实现，分为<strong>堆内存实现和直接内存实现</strong>，比如，ByteBuffer 又分为 HeapByteBuffer 和 DirectByteBuffer 两种不同的内存实现。</p><p>OK，Buffer 有这么多种不同的实现，那么，<strong>它们该如何使用呢？</strong></p><p>从前面 Buffer 的定义，我们知道 Buffer 有三个非常重要的属性，分别为：capacity、limit、position。</p><ul><li><p>  capacity，比较好理解，Buffer 的容量，即能够容纳多少数据。</p></li><li><p>  limit，这个稍微费脑一些，表示的是最大可写或者最大可读的数据。</p></li><li><p>  position，这个就更难理解一些，表示下一次可使用的位置，针对读模式表示下一个可读的位置，针对写模式表示下一个可写的位置。</p></li></ul><p>上面的描述可能比较抽象，让我们上一张图来细细品味一下：</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220517111648246.png" alt="image-20220517111648246"><br>上图中，深蓝色表示已经写入的空间，这部分有数据可读；淡蓝色表示未被写入的空间，这部分没有数据可读。</p><p>写模式下，position 指向下一个可写的位置，limit 表示最大可写的数据，capacity 表示容量。比如，Buffer 的大小为 8，已经写了三个单位的数据，则 capacity=8，limit=8，position=3。</p><p>读模式下，position 指向下一个可读的位置，limit 表示最大可读的数据，capacity 表示容量。比如，Buffer 的大小为 8，已经写了三个单位的数据，此时切换为读模式，则 capacity=8，limit=3，position=0。</p><blockquote><p>注意，position 表示的是位置，类似于数组的下标，是从 0 开始的。而 limit 和 capacity 表示的是大小，类似于数组的长度，是从 1 开始的。当 Buffer 从写模式切换为读模式时，limit 变为原 position 的值，position 变为 0。</p></blockquote><p>好了，Buffer 的结构我们了解了，那么，要如何使用 Buffer 呢？</p><p>Buffer 提供了一系列的方法，供我们简单快捷地使用 Buffer，我们从使用的流程上来说的话，大概有下面这么<strong>几个重要的方法：</strong></p><ul><li>  分配一个 Buffer：allocate ()</li><li>  写入数据：buf.put () 或者 channel.read (buf)，read 为 read to 的意思，从 channel 读出并写入 buffer</li><li>  切换为读模式：buf.flip ()</li><li>  读取数据：buf.read () 或者 channel.write (buf)，write 为 write from 的意思，从 buffer 读出并写入 channel</li><li>  重新读取或重新写入：rewind ()，重置 position 为 0，limit 和 capacity 保持不变，可以重新读取或重新写入数据</li><li>  清空数据：buf.clear ()，清空所有数据</li><li>  压缩数据：buf.compact ()，清除已读取的数据，并将未读取的数据往前移</li></ul><p>我们对照着代码来看看如何使用 Buffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 从文件获取一个FileChannel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;D:\\object.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">        <span class="comment">// 分配一个Byte类型的Buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 将FileChannel中的数据读出到buffer中，-1表示读取完毕</span></span><br><span class="line">        <span class="comment">// buffer默认为写模式</span></span><br><span class="line">        <span class="comment">// read()方法是相对channel而言的，相对buffer就是写</span></span><br><span class="line">        <span class="keyword">while</span> ((fileChannel.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// buffer切换为读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// buffer中是否有未读数据</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 读取数据</span></span><br><span class="line">                System.out.print((<span class="keyword">char</span>)buffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清空buffer，为下一次写入数据做准备</span></span><br><span class="line">            <span class="comment">// clear()会将buffer再次切换为写模式</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看 NIO 的另一个核心组件 ——Selector，可以毫不夸张地说，没有 Selector 就无法使用 NIO 来进行网络编程，那么，<strong>Selector 有哪些过人之处呢？</strong></p><h2 id="Selecor"><a href="#Selecor" class="headerlink" title="Selecor"></a>Selecor</h2><p><strong>什么是 Selector？</strong> 让我们再来看看 JDK 怎么说：</p><blockquote><p>// java.nio.channels.Selector</p><p>A multiplexor of {@link SelectableChannel} objects.</p></blockquote><p>首先，Selector 是一个多路复用器。什么的多路复用器？SelectableChannel 对象的多路复用器，注意，这里的对象是复数，说明一个 Selector 可以关联到多个 SelectableChannel。另外，它是 <strong>SelectableChannel</strong> 的多路复用器，可以跟 FileChannel 配合使用吗？不可以，因为 FileChannel 不是 SelectableChannel。那么 SelectableChannel 有哪些呢？跟网络编程相关的那些 Channel 基本上都是 SelectableChannel，比如 SocketChannel、ServerSocketChannel、DatagramChannel 等。</p><p>那么，<strong>Selector 跟 Channel 究竟是怎样的关系呢？</strong></p><p>从上面的描述中，我们也能够大胆猜测，Selector 和 Channel 是一对多的关系，一个 Selector 可以为多个 Channel 服务，监听它们准备好的事件。Selector 就像饭店中的服务员一样，一个服务员是可以服务于多位顾客的，时刻监听着顾客的吩咐。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220517111956805.png" alt="image-20220517111956805"><br>OK，那么，<strong>Selector 又该怎么使用呢？</strong> 我们还是以饭店来举例。</p><p>首先，饭店需要先聘请一个服务员，然后这个服务员来上班。同样地，Selector 也需要先创建出来，创建的方式有两种，一种是调用 <code>Selector.open()</code> 方法，一种是调用 <code>SelectorProvider.openSelector()</code> 方法，其中 SelectorProvider 是自定义的。鉴于第二种方式不太常用，所以我们只讲第一种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Selector</span></span><br><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p>接着，有顾客上门了，服务员去接待，“吃啥啊兄弟？”，“小炒黄牛肉。”，顾客把点的菜告诉服务员。同样地，你需要 Selector 干什么，也需要告诉他，在 Java 里面，我们叫作注册事件到 Selector 上，当然了，我们是非阻塞式的，所以，注册之前还要先设置为非阻塞式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册事件到Selector上</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p>Channel 注册到 Selector 上之后，返回了一个叫作 SelectionKey 的对象，<strong>SelectionKey 又是什么呢？</strong></p><p>一般地，我们在饭店点完菜之后，都会给一个牌子到你手上，服务员通过这个牌子可以找到你，你通过这个牌子可以去拿饭。SelectionKey 就相当于是这个牌子，它将 Channel 和 Selector 的牢牢地绑定在一起，并保存着你感兴趣的事件。</p><p><strong>事件又是什么东西？</strong></p><p>事件是 Channel 感兴趣的事情，比如读事件、写事件等等，在 Java 中，定义了四种事件，位于 SelectionKey 这个类中：</p><ul><li>  读事件：SelectionKey.OP_READ = 1 &lt;&lt; 0 = 0000 0001</li><li>  写事件：SelectionKey.OP_WRITE = 1 &lt;&lt; 2 = 0000 0100</li><li>  连接事件：SelectionKey.OP_CONNECT = 1 &lt;&lt; 3 = 0000 1000</li><li>  接受连接事件：SelectionKey.OP_ACCEPT = 1 &lt;&lt; 4 = 0001 0000</li></ul><p>细心的同学会发现，四种事件的位正好是错开的，所以，我们可以使用 “位或” 操作监听多种感兴趣的事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p>然后，服务员拿到了好几个顾客的菜单后，不断地去后厨询问，看看有没有做好的，有做好的就通知到这些顾客。在 Java 中，这叫作轮询，“轮” 是一次又一次的意思，包含循环的含义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select()只有询问的意思，加上循环才是轮询的意思</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    selector.select(); <span class="comment">// 一直阻塞直到有感兴趣的事件</span></span><br><span class="line">    <span class="comment">// selector.selectNow(); // 立即返回，不阻塞</span></span><br><span class="line">    <span class="comment">// selector.select(timeout); // 阻塞一段时间返回</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>与服务员不断地询问后厨不同的是，服务员没问到结果，可能就去忙其它的事了，比如玩手机，而 select () 没询问到结果会一直阻塞着，直到有感兴趣的事件来了为止。当然，你也可以使用的它的兄弟方法 <code>selectNow()</code> 不阻塞立即返回，或者 <code>select(timeout)</code> 阻塞一段时间后返回。</p><p>最后，服务员拿到这些做好的菜单，通知顾客自己过来聚餐（这个服务员比较懒）。在 Java 中，通过 <code>selector.selectedKeys()</code> 返回就绪的事件，然后遍历这些事件就可以拿到想要的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// 接受连接事件已就绪</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// 连接事件已就绪</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// 读事件已就绪</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// 写事件已就绪</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是从 Channel 中取数据了，也就是 Channel 和 Buffer 的交互了，在上面已经介绍过了，这里我们就不重复介绍了。</p><h2 id="Channel、Buffer、Selector-三者如何联合使用"><a href="#Channel、Buffer、Selector-三者如何联合使用" class="headerlink" title="Channel、Buffer、Selector 三者如何联合使用"></a>Channel、Buffer、Selector 三者如何联合使用</h2><p>Channel、Buffer、Selector 这三个 NIO 的核心组件我们都剖析完了，那么，它们该如何联合起来使用呢？让我们看一个完整的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOEchoServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 创建ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 绑定8080端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8002</span>));</span><br><span class="line">        <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 将Channel注册到selector上，并注册Accept事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;server start&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞在select上（第一阶段阻塞）</span></span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果使用的是select(timeout)或selectNow()需要判断返回值是否大于0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有就绪的Channel</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">// 遍历selectKeys</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                <span class="comment">// 如果是accept事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 强制转换为ServerSocketChannel</span></span><br><span class="line">                    ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                    SocketChannel socketChannel = ssc.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;accept new conn: &quot;</span> + socketChannel.getRemoteAddress());</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 将SocketChannel注册到Selector上，并注册读事件</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 如果是读取事件</span></span><br><span class="line">                    <span class="comment">// 强制转换为SocketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">// 创建Buffer用于读取数据</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">// 将数据读入到buffer中（第二阶段阻塞）</span></span><br><span class="line">                    <span class="keyword">int</span> length = socketChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">                        <span class="comment">// 将数据读入到byte数组中</span></span><br><span class="line">                        buffer.get(bytes);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 换行符会跟着消息一起传过来</span></span><br><span class="line">                        String content = <span class="keyword">new</span> String(bytes, <span class="string">&quot;UTF-8&quot;</span>).replace(<span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;receive msg: &quot;</span> + content);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img1.sycdn.imooc.com/5f0d5cad00014cc413761908.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;03-Java-NIO的核心组件&quot;&gt;&lt;a href=&quot;#03-Java-NIO的核心组件&quot; class=&quot;headerlink&quot; title=&quot;03.Java NIO的核心组件&quot;&gt;&lt;/a&gt;03.Java NIO的核心组件&lt;/h1&gt;&lt;h2 id=&quot;Channel&quot;&gt;</summary>
      
    
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>02.IO多路复用实现机制</title>
    <link href="https://leslieaibin.github.io/2022/05/14/Netty/02.%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>https://leslieaibin.github.io/2022/05/14/Netty/02.%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</id>
    <published>2022-05-14T01:15:42.000Z</published>
    <updated>2022-05-14T10:47:45.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO-多路复用实现机制"><a href="#IO-多路复用实现机制" class="headerlink" title="IO 多路复用实现机制"></a>IO 多路复用实现机制</h1><h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><p>IO 多路复用有三种实现，在介绍select、poll、epoll之前，首先介绍一下Linux操作系统中<strong>基础的概念</strong>：</p><ul><li><p>  用户空间和内核空间</p></li><li><p>  进程切换</p></li><li><p>  进程的阻塞</p></li><li><p>  文件描述符</p></li><li><p>  缓存 I/O</p></li></ul><h3 id="用户空间-内核空间"><a href="#用户空间-内核空间" class="headerlink" title="用户空间 / 内核空间"></a>用户空间 / 内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p><p>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的，并且进程切换是非常耗费资源的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li><p> 保存处理机上下文，包括程序计数器和其他寄存器。</p></li><li><p> 更新PCB信息。</p></li><li><p> 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</p></li><li><p> 选择另一个进程执行，并更新其PCB。</p></li><li><p> 更新内存管理的数据结构。</p></li><li><p> 恢复处理机上下文。</p></li></ol><h3 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得了CPU资源），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><h3 id="缓存I-O"><a href="#缓存I-O" class="headerlink" title="缓存I/O"></a>缓存I/O</h3><p>缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p><strong>缓存 I/O 的缺点：</strong></p><p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h2 id="什么是IO多路复用？"><a href="#什么是IO多路复用？" class="headerlink" title="什么是IO多路复用？"></a>什么是IO多路复用？</h2><ul><li><p>  IO 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；</p></li><li><p>  一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</p></li><li><p>  没有文件句柄就绪就会阻塞应用程序，交出CPU。</p></li></ul><blockquote><p>多路是指网络连接，复用指的是同一个线程</p></blockquote><h2 id="为什么有IO多路复用机制？"><a href="#为什么有IO多路复用机制？" class="headerlink" title="为什么有IO多路复用机制？"></a>为什么有IO多路复用机制？</h2><p>没有IO多路复用机制时，有BIO、NIO两种实现方式，但它们都有一些问题</p><h3 id="同步阻塞（BIO）"><a href="#同步阻塞（BIO）" class="headerlink" title="同步阻塞（BIO）"></a>同步阻塞（BIO）</h3><ul><li><p>服务端采用单线程，当 <code>accept</code> 一个请求后，在 <code>recv</code> 或 <code>send</code> 调用阻塞时，将无法 <code>accept</code> 其他请求（必须等上一个请求处理 <code>recv</code> 或 <code>send</code> 完 ）（无法处理并发）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// accept阻塞</span></span><br><span class="line">    client_fd = accept(listen_fd);</span><br><span class="line">    fds.append(client_fd);</span><br><span class="line">    <span class="keyword">for</span> (fd in fds) &#123;</span><br><span class="line">    <span class="comment">// recv阻塞（会影响上面的accept）</span></span><br><span class="line">        <span class="keyword">if</span> (recv(fd)) &#123;</span><br><span class="line">        <span class="comment">// logic</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>服务端采用多线程，当 accept 一个请求后，开启线程进行 recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销，10000个线程真正发生读写实际的线程数不会超过20%，每次accept都开一个线程也是一种资源浪费。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="comment">// accept阻塞</span></span><br><span class="line">  client_fd = accept(listen_fd)</span><br><span class="line">  <span class="comment">// 开启线程read数据（fd增多导致线程数增多）</span></span><br><span class="line">  <span class="function">newThread <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// recv阻塞（多线程不影响上面的accept）</span></span><br><span class="line">    <span class="keyword">if</span> (recv(fd)) &#123;</span><br><span class="line">      <span class="comment">// logic</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="同步非阻塞（NIO）"><a href="#同步非阻塞（NIO）" class="headerlink" title="同步非阻塞（NIO）"></a>同步非阻塞（NIO）</h3><ul><li><p>服务器端当 <code>accept</code> 一个请求后，加入 <code>fds</code> 集合，每次轮询一遍 <code>fds</code> 集合 <code>recv</code> (非阻塞)数据，没有数据则立即返回错误，每次轮询所有 fd （包括没有发生读写实际的 fd）会很浪费 CPU。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="comment">// accept非阻塞（cpu一直忙轮询）</span></span><br><span class="line">  client_fd = accept(listen_fd)</span><br><span class="line">  <span class="keyword">if</span> (client_fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 有人连接</span></span><br><span class="line">    fds.append(client_fd)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 无人连接</span></span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">for</span> (fd in fds) &#123;</span><br><span class="line">    <span class="comment">// recv非阻塞</span></span><br><span class="line">    setNonblocking(client_fd)</span><br><span class="line">    <span class="comment">// recv 为非阻塞命令</span></span><br><span class="line">    <span class="keyword">if</span> (len = recv(fd) &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 有读写数据</span></span><br><span class="line">      <span class="comment">// logic</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       无读写数据</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>服务器端采用单线程通过 <code>select/poll/epoll</code> 等系统调用获取 fd 列表，遍历有事件的 fd 进行 <code>accept/recv/send</code> ，使其能支持更多的并发连接请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 通过内核获取有读写事件发生的fd，只要有一个则返回，无则阻塞</span></span><br><span class="line">  <span class="comment">// 整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，accept/recv是不会阻塞</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="function">fd in <span class="title">select</span><span class="params">(fds)</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd == listen_fd) &#123;</span><br><span class="line">        client_fd = accept(listen_fd)</span><br><span class="line">        fds.append(client_fd)</span><br><span class="line">    &#125; elseif (len = recv(fd) &amp;&amp; len != -<span class="number">1</span>) &#123; </span><br><span class="line">      <span class="comment">// logic</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO多路复用的三种实现"><a href="#IO多路复用的三种实现" class="headerlink" title="IO多路复用的三种实现"></a>IO多路复用的三种实现</h2><ul><li><p>  select</p></li><li><p>  poll</p></li><li><p>  epoll</p></li></ul><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p><h4 id="select调用过程"><a href="#select调用过程" class="headerlink" title="select调用过程"></a>select调用过程</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514172305481.png" alt="image-20220514172305481"></p><p>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间</p><p>（2）注册回调函数__pollwait</p><p>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</p><p>（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</p><p>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</p><p>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</p><p>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</p><p>（8）把fd_set从内核空间拷贝到用户空间。</p><h4 id="select函数接口"><a href="#select函数接口" class="headerlink" title="select函数接口"></a>select函数接口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFDBITS (8 * sizeof(unsigned long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FDSET_LONGS (FD_SETSIZE/NFDBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构 (bitmap)</span></span><br><span class="line">typedefstruct &#123;</span><br><span class="line">    unsignedlong fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> max_fd, </span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *readset, </span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *writeset, </span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *exceptset, </span></span></span><br><span class="line"><span class="function"><span class="params">    struct timeval *timeout</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>                              <span class="comment">// 返回值就绪描述符的数目</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">FD_ZERO</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>   <span class="comment">// 清空集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>    <span class="comment">// 将给定的描述符加入集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>  <span class="comment">// 判断指定描述符是否在集合中 </span></span></span><br><span class="line"><span class="function"><span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>    <span class="comment">// 将给定的描述符从文件中删除</span></span></span><br></pre></td></tr></table></figure><h4 id="select使用示例"><a href="#select使用示例" class="headerlink" title="select使用示例"></a>select使用示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 这里进行一些初始化的设置，</span></span><br><span class="line"><span class="comment">   * 包括socket建立，地址的设置等,</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  fd_set read_fs, write_fs;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">0</span>;  <span class="comment">// 用于记录最大的fd，在轮询中时刻更新即可</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化比特位</span></span><br><span class="line">  FD_ZERO(&amp;read_fs);</span><br><span class="line">  FD_ZERO(&amp;write_fs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nfds = <span class="number">0</span>; <span class="comment">// 记录就绪的事件，可以减少遍历的次数</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="comment">// 每次需要把fd从用户态拷贝到内核态</span></span><br><span class="line">    nfds = select(max + <span class="number">1</span>, &amp;read_fd, &amp;write_fd, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">    <span class="comment">// 每次需要遍历所有fd，判断有无读写事件发生</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max &amp;&amp; nfds; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == listenfd) &#123;</span><br><span class="line">         --nfds;</span><br><span class="line">         <span class="comment">// 这里处理accept事件</span></span><br><span class="line">         FD_SET(i, &amp;read_fd);<span class="comment">//将客户端socket加入到集合中</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (FD_ISSET(i, &amp;read_fd)) &#123;</span><br><span class="line">        --nfds;</span><br><span class="line">        <span class="comment">// 这里处理read事件</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (FD_ISSET(i, &amp;write_fd)) &#123;</span><br><span class="line">         --nfds;</span><br><span class="line">        <span class="comment">// 这里处理write事件</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点"></a>select缺点</h4><ul><li> 每次调用select，都需要把被监控的fds集合从用户态空间拷贝到内核态空间，高并发场景下这样的拷贝会使得消耗的资源是很大的。</li><li> 能监听端口的数量有限，单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上为3264），当然我们可以对宏FD_SETSIZE进行修改，然后重新编译内核，但是性能可能会受到影响，一般该数和系统内存关系很大，具体数目可以<code>cat /proc/sys/fs/file-max</code>察看。32位机默认1024个，64位默认2048。 </li></ul><blockquote><p>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p></blockquote><ul><li>  对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发）</li></ul><blockquote><p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p></blockquote><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</p><h4 id="poll函数接口"><a href="#poll函数接口" class="headerlink" title="poll函数接口"></a>poll函数接口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;                         <span class="comment">// 需要监视的文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;                   <span class="comment">// 需要内核监视的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents;                  <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd fds[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="poll使用示例"><a href="#poll使用示例" class="headerlink" title="poll使用示例"></a>poll使用示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先宏定义长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_POLLFD_LEN 4096  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 在这里进行一些初始化的操作，</span></span><br><span class="line"><span class="comment">   * 比如初始化数据和socket等。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nfds = <span class="number">0</span>;</span><br><span class="line">  pollfd fds[MAX_POLLFD_LEN];</span><br><span class="line">  <span class="built_in">memset</span>(fds, <span class="number">0</span>, <span class="keyword">sizeof</span>(fds));</span><br><span class="line">  fds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">  fds[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line">  <span class="keyword">int</span> max  = <span class="number">0</span>;  <span class="comment">// 队列的实际长度，是一个随时更新的，也可以自定义其他的</span></span><br><span class="line">  <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> current_size = max;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="comment">// 每次需要把fd从用户态拷贝到内核态</span></span><br><span class="line">    nfds = poll(fds, max+<span class="number">1</span>, timeout);</span><br><span class="line">    <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123;</span><br><span class="line">        <span class="comment">// 这里处理accept事件</span></span><br><span class="line">        connfd = accept(listenfd);</span><br><span class="line">        <span class="comment">//将新的描述符添加到读描述符集合中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次需要遍历所有fd，判断有无读写事件发生</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; max; ++i) &#123;     </span><br><span class="line">      <span class="keyword">if</span> (fds[i].revents &amp; POLLRDNORM) &#123; </span><br><span class="line">         sockfd = fds[i].fd</span><br><span class="line">         <span class="keyword">if</span> ((n = read(sockfd, buf, MAXLINE)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里处理read事件</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                close(sockfd);</span><br><span class="line">                fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 这里处理write事件     </span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (--nfds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;       </span><br><span class="line">         &#125;   </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="poll缺点"><a href="#poll缺点" class="headerlink" title="poll缺点"></a>poll缺点</h4><p><strong>它没有最大连接数的限制</strong>，原因是它是基于链表来存储的，但是同样有缺点：</p><ul><li><p>  每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；</p></li><li><p>  对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时）</p></li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p><h4 id="epoll函数接口"><a href="#epoll函数接口" class="headerlink" title="epoll函数接口"></a>epoll函数接口</h4><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="comment">// 每一个epoll对象都有一个独立的eventpoll结构体</span></span><br><span class="line"><span class="comment">// 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件</span></span><br><span class="line"><span class="comment">// epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; <span class="comment">// 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>; <span class="comment">// epoll_ctl 负责把 socket 增加、删除到内核红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;<span class="comment">// epoll_wait 负责检测可读队列，没有可读 socket 则阻塞进程</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为红黑树元素个数)。</p><p>而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p><p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p><pre><code>struct epitem&#123;    struct rb_node  rbn;//红黑树节点    struct list_head    rdllink;//双向链表节点    struct epoll_filefd  ffd;//事件句柄信息    struct eventpoll *ep;//指向其所属的eventpoll对象    struct epoll_event event;//期待发生的事件类型&#125;</code></pre><p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514174104753.png" alt="image-20220514174104753"><strong>从上面的讲解可知：通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。</strong>讲解完了Epoll的机理，我们便能很容易掌握epoll的用法了。一句话描述就是：三步曲。</p><ul><li><p>  第一步：epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。</p></li><li><p>  第二步：epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。</p></li><li><p>  第三部：epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。</p></li></ul><h4 id="epoll使用示例"><a href="#epoll使用示例" class="headerlink" title="epoll使用示例"></a>epoll使用示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 在这里进行一些初始化的操作，</span></span><br><span class="line"><span class="comment">   * 比如初始化数据和socket等。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核中创建ep对象</span></span><br><span class="line">    epfd=epoll_create(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">// 需要监听的socket放到ep中</span></span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&amp;ev);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 阻塞获取</span></span><br><span class="line">      nfds = epoll_wait(epfd,events,<span class="number">20</span>,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i) &#123;</span><br><span class="line">          <span class="keyword">if</span>(events[i].data.fd==listenfd) &#123;</span><br><span class="line">              <span class="comment">// 这里处理accept事件</span></span><br><span class="line">              connfd = accept(listenfd);</span><br><span class="line">              <span class="comment">// 接收新连接写到内核对象中</span></span><br><span class="line">              epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev);</span><br><span class="line">          &#125; elseif (events[i].events&amp;EPOLLIN) &#123;</span><br><span class="line">              <span class="comment">// 这里处理read事件</span></span><br><span class="line">              read(sockfd, BUF, MAXLINE);</span><br><span class="line">              <span class="comment">//读完后准备写</span></span><br><span class="line">              epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">          &#125; elseif(events[i].events&amp;EPOLLOUT) &#123;</span><br><span class="line">              <span class="comment">// 这里处理write事件</span></span><br><span class="line">              write(sockfd, BUF, n);</span><br><span class="line">              <span class="comment">//写完后准备读</span></span><br><span class="line">              epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="epoll的优点"><a href="#epoll的优点" class="headerlink" title="epoll的优点"></a>epoll的优点</h4><ul><li><p>  没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；</p></li><li><p>  效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll；</p></li><li><p>  内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p></li></ul><h4 id="epoll缺点"><a href="#epoll缺点" class="headerlink" title="epoll缺点"></a>epoll缺点</h4><ul><li>  epoll只能工作在 linux 下</li></ul><h4 id="epoll-LT-与-ET-模式的区别"><a href="#epoll-LT-与-ET-模式的区别" class="headerlink" title="epoll LT 与 ET 模式的区别"></a>epoll LT 与 ET 模式的区别</h4><p>epoll 有 EPOLLLT 和 EPOLLET 两种触发模式，LT 是默认的模式，ET 是 “高速” 模式。</p><ul><li><p>  LT 模式下，只要这个 fd 还有数据可读，每次 epoll_wait 都会返回它的事件，提醒用户程序去操作；</p></li><li><p>  ET 模式下，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论 fd 中是否还有数据可读。所以在 ET 模式下，read 一个 fd 的时候一定要把它的 buffer 读完，或者遇到 EAGIN 错误。</p></li></ul><p>epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><h3 id="select-poll-epoll之间的区别"><a href="#select-poll-epoll之间的区别" class="headerlink" title="select/poll/epoll之间的区别"></a>select/poll/epoll之间的区别</h3><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514174341258.png" alt="image-20220514174341258"></p><p>epoll是Linux目前大规模网络并发程序开发的首选模型。在绝大多数情况下性能远超select和poll。目前流行的高性能web服务器Nginx正式依赖于epoll提供的高效网络套接字轮询服务。但是，在并发连接不高的情况下，多线程+阻塞I/O方式可能性能更好。</p><h4 id="支持一个进程所能打开的最大连接数"><a href="#支持一个进程所能打开的最大连接数" class="headerlink" title="支持一个进程所能打开的最大连接数"></a>支持一个进程所能打开的最大连接数</h4><ul><li><p>  select：单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32_32，同理64位机器上FD_SETSIZE为32_64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p></li><li><p>  poll：poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p></li><li><p>  epoll：虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接。</p></li></ul><h4 id="FD剧增后带来的IO效率问题"><a href="#FD剧增后带来的IO效率问题" class="headerlink" title="FD剧增后带来的IO效率问题"></a>FD剧增后带来的IO效率问题</h4><ul><li><p>  select：因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</p></li><li><p>  poll：同上</p></li><li><p>  epoll：因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</p></li></ul><h4 id="消息传递方式"><a href="#消息传递方式" class="headerlink" title="消息传递方式"></a>消息传递方式</h4><ul><li><p>  select：内核需要将消息传递到用户空间，都需要内核拷贝动作</p></li><li><p>  poll：同上</p></li><li><p>  epoll：epoll通过内核和用户空间共享一块内存来实现的。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><h2 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h2><h3 id="nginx-redis-所使用的IO模型是什么？"><a href="#nginx-redis-所使用的IO模型是什么？" class="headerlink" title="nginx/redis 所使用的IO模型是什么？"></a>nginx/redis 所使用的IO模型是什么？</h3><h4 id="Nginx的IO模型"><a href="#Nginx的IO模型" class="headerlink" title="Nginx的IO模型"></a>Nginx的IO模型</h4><p>Nginx 支持多种并发模型，并发模型的具体实现根据系统平台而有所不同。</p><p>在支持多种并发模型的平台上，nginx 自动选择最高效的模型。但我们也可以使用 use 指令在配置文件中显式地定义某个并发模型。</p><p><strong>NGINX中支持的并发模型：</strong></p><h5 id="1、select"><a href="#1、select" class="headerlink" title="1、select"></a>1、select</h5><p>IO多路复用、标准并发模型。在编译 nginx 时，如果所使用的系统平台没有更高效的并发模型，select 模块将被自动编译。configure 脚本的选项：–with-select_module 和 –without-select_module 可被用来强制性地开启或禁止 select 模块的编译</p><h5 id="2、poll"><a href="#2、poll" class="headerlink" title="2、poll"></a>2、poll</h5><p>IO多路复用、标准并发模型。与 select 类似，在编译 nginx 时，如果所使用的系统平台没有更高效的并发模型，poll 模块将被自动编译。configure 脚本的选项：–with-poll_module 和 –without-poll_module 可用于强制性地开启或禁止 poll 模块的编译</p><h5 id="3、epoll"><a href="#3、epoll" class="headerlink" title="3、epoll"></a>3、epoll</h5><p>IO多路复用、高效并发模型，可在 Linux 2.6+ 及以上内核可以使用</p><h5 id="4、kqueue"><a href="#4、kqueue" class="headerlink" title="4、kqueue"></a>4、kqueue</h5><p>IO多路复用、高效并发模型，可在 FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0, and Mac OS X 平台中使用</p><h5 id="5、-dev-poll"><a href="#5、-dev-poll" class="headerlink" title="5、/dev/poll"></a>5、/dev/poll</h5><p>高效并发模型，可在 Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+, and Tru64 UNIX 5.1A+ 平台使用</p><h5 id="6、eventport"><a href="#6、eventport" class="headerlink" title="6、eventport"></a>6、eventport</h5><p>高效并发模型，可用于 Solaris 10 平台，PS：由于一些已知的问题，建议 使用/dev/poll替代。</p><h4 id="Redis-IO多路复用技术"><a href="#Redis-IO多路复用技术" class="headerlink" title="Redis IO多路复用技术"></a>Redis IO多路复用技术</h4><p>redis 是一个单线程却性能非常好的内存数据库， 主要用来作为缓存系统。redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。</p><p><strong>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</strong></p><p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 <strong>I/O 多路复用</strong> 就是为了解决这个问题而出现的。</p><p>redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。</p><h3 id="epoll-水平触发（LT）与-边缘触发（ET）的区别？"><a href="#epoll-水平触发（LT）与-边缘触发（ET）的区别？" class="headerlink" title="epoll 水平触发（LT）与 边缘触发（ET）的区别？"></a>epoll 水平触发（LT）与 边缘触发（ET）的区别？</h3><p>EPOLL事件有两种模型：</p><ul><li><p>  Edge Triggered (ET) 边缘触发只有数据到来,才触发,不管缓存区中是否还有数据。</p></li><li><p>  Level Triggered (LT) 水平触发只要有数据都会触发。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IO-多路复用实现机制&quot;&gt;&lt;a href=&quot;#IO-多路复用实现机制&quot; class=&quot;headerlink&quot; title=&quot;IO 多路复用实现机制&quot;&gt;&lt;/a&gt;IO 多路复用实现机制&lt;/h1&gt;&lt;h2 id=&quot;概念说明&quot;&gt;&lt;a href=&quot;#概念说明&quot; class=&quot;</summary>
      
    
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>01.IO多路复用基础</title>
    <link href="https://leslieaibin.github.io/2022/05/10/Netty/01.%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
    <id>https://leslieaibin.github.io/2022/05/10/Netty/01.%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-10T01:15:42.000Z</published>
    <updated>2022-07-09T13:59:39.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-O-五种IO模型"><a href="#I-O-五种IO模型" class="headerlink" title="I/O 五种IO模型"></a>I/O 五种IO模型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了加深对 <strong>I/O多路复用机制</strong> 的理解，以及了解到多路复用也有局限性，在这里我们先回顾下 <strong>Unix网络编程中的五种IO模型</strong>。</p><ul><li><p>  <strong>Blocking IO - 阻塞IO</strong></p></li><li><p>  <strong>NoneBlocking IO - 非阻塞IO</strong></p></li><li><p>  <strong>IO multiplexing - IO多路复用</strong></p></li><li><p>  <strong>signal driven IO - 信号驱动IO</strong></p></li><li><p>  <strong>asynchronous IO - 异步IO</strong></p></li></ul><h2 id="Unix网络编程中的五种IO模型"><a href="#Unix网络编程中的五种IO模型" class="headerlink" title="Unix网络编程中的五种IO模型"></a>Unix网络编程中的五种IO模型</h2><h3 id="阻塞IO-Blocking-IO"><a href="#阻塞IO-Blocking-IO" class="headerlink" title="阻塞IO - Blocking IO"></a>阻塞IO - Blocking IO</h3><p>最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。</p><p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p><p>也许有人会说，可以采用多线程+ 阻塞IO 来解决效率问题，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</p><h3 id="非阻塞IO-NoneBlocking-IO"><a href="#非阻塞IO-NoneBlocking-IO" class="headerlink" title="非阻塞IO - NoneBlocking IO"></a>非阻塞IO - NoneBlocking IO</h3><p>当用户线程发起一个 IO 操作后，并不需要等待，而是马上就得到一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 IO 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p><p>在非阻塞IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p><blockquote><p>对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514163555308.png" alt="image-20220514163555308"></p><ul><li><p>  非阻塞式主要体现在用户进程发起recvfrom系统调用的时候,这个时候系统内核还没有接收到数据报,直接返回错误给用户进程,告诉“当前还没有数据报可达,晚点再来”</p></li><li><p>  用户进程接收到信息,但是用户进程不知道什么时候数据报可达,于是就开始不断轮询(polling)向系统内核发起recvfrom的系统调用“询问数据来了没”,如果没有则继续返回错误</p></li><li><p>  用户进程轮询发起recvfrom系统调用直至数据报可达,这个时候需要等待系统内核复制数据报到用户进程的缓冲区,复制完成之后将返回成功提示</p></li></ul><h3 id="IO多路复用-IO-multiplexing"><a href="#IO多路复用-IO-multiplexing" class="headerlink" title="IO多路复用 - IO multiplexing"></a>IO多路复用 - IO multiplexing</h3><p>所谓 I/O 多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要 <code>select</code> 、 <code>poll</code> 、 <code>epoll</code> 来配合。</p><p>在多路复用IO模型中，会有一个内核线程不断地去轮询多个 socket 的状态，只有当真正读写事件发送时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有真正有读写事件进行时，才会使用IO资源，所以它大大减少来资源占用。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514163854576.png" alt="image-20220514163854576"></p><ul><li><p>  IO复用模式是使用select或者poll函数向系统内核发起调用，阻塞在这两个系统函数调用，而不是真正阻塞于实际的IO操作(recvfrom调用才是实际阻塞IO操作的系统调用)</p></li><li><p>  阻塞于select函数的调用,等待数据报套接字变为可读状态</p></li><li><p>  当select套接字返回可读状态的时候,就可以发起recvfrom调用把数据报复制到用户空间的缓冲区</p></li></ul><h3 id="信号驱动IO-signal-driven-IO"><a href="#信号驱动IO-signal-driven-IO" class="headerlink" title="信号驱动IO - signal driven IO"></a>信号驱动IO - signal driven IO</h3><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。这个一般用于UDP中，对TCP套接字几乎没用，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么请求。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514164305315.png" alt="image-20220514164305315"></p><p>用户进程可以使用信号方式，当系统内核描述符就绪时将会发送SIGNO给到用户空间，这个时候再发起recvfrom的系统调用等待返回成功提示，流程如下：</p><ul><li><p>  先开启套接字的信号IO启动功能，并通过一个内置安装信号处理函数的signaction系统调用，当发起调用之后会直接返回；</p></li><li><p>  其次，等待内核从网络中接收数据报之后，向用户空间发送当前数据可达的信号给信号处理函数；</p></li><li><p>  信号处理函数接收到信息就发起recvfrom系统调用等待内核数据复制数据报到用户空间的缓冲区；</p></li><li><p>  接收到复制完成的返回成功提示之后，应用进程就可以开始从网络中读取数据。</p></li></ul><h3 id="异步IO-asynchronous-IO"><a href="#异步IO-asynchronous-IO" class="headerlink" title="异步IO - asynchronous IO"></a>异步IO - asynchronous IO</h3><p>前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514164743871.png" alt="image-20220514164743871"></p><ul><li><p>  由POSIX规范定义，告知系统内核启动某个操作，并让内核在整个操作包含数据等待以及数据复制过程的完成之后通知用户进程数据已经准备完成，可以进行读取数据；</p></li><li><p>  与上述的信号IO模型区分在于异步是通知我们何时IO操作完成,而信号IO是通知我们何时可以启动一个IO操作</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现代计算机服务器操作系统大部分都是基于linxu实现,为处理高并发而采取NIO的模型,对于支持异步IO模型的系统持有不确定因素。</p><h4 id="同步与异步的定义"><a href="#同步与异步的定义" class="headerlink" title="同步与异步的定义"></a>同步与异步的定义</h4><ul><li><p>  同步:发起一个fn的调用,需要等待调用结果返回,该调用结果要么是期望的结果要么是异常抛出的结果,可以说是原子性操作(要么成功要么失败返回)</p></li><li><p>  异步: 发起一个fn调用,无需等待结果就直接返回,只有当被调用者执行处理程序之后通过“唤醒”手段通知调用方获取结果(唤醒的方式有回调,事件通知等)</p></li><li><p>  <strong>小结: 同步和异步关注的是程序之间的通信</strong></p></li></ul><h4 id="阻塞与非阻塞的定义"><a href="#阻塞与非阻塞的定义" class="headerlink" title="阻塞与非阻塞的定义"></a>阻塞与非阻塞的定义</h4><ul><li><p>  阻塞: 类比线程阻塞来说明,在并发多线程争抢资源的竞态条件下,如果有一个线程已持有锁,那么当前线程将无法获取锁而被挂起,处于等待状态</p></li><li><p>  非阻塞: 一旦线程释放锁,其他线程将会进入就绪状态,具备争抢锁的资格</p></li><li><p>  <strong>小结: 阻塞与非阻塞更关注是程序等待结果的状态</strong></p></li><li><p>  由此可知,同步异步与阻塞非阻塞之间不存在关联,关注的目标是不一样的</p></li></ul><h4 id="同步IO与异步IO-基于POSIX规范"><a href="#同步IO与异步IO-基于POSIX规范" class="headerlink" title="同步IO与异步IO(基于POSIX规范)"></a>同步IO与异步IO(基于POSIX规范)</h4><ul><li><p>  同步IO: 表示应用进程发起真实的IO操作请求(recvfrom)导致进程一直处于等待状态,这时候进程被阻塞,直到IO操作完成返回成功提示</p></li><li><p>  异步IO: 表示应用进程发起真实的IO操作请求(recvfrom)导致进程将直接返回一个错误信息,<strong>“相当于告诉进程还没有处理好,好了会通知你”</strong></p></li><li><p>  阻塞IO: 主要是体现发起IO操作请求通知内核并且内核接收到信号之后如果让进程等待,那么就是阻塞</p></li><li><p>  非阻塞IO: 发起IO操作请求的时候不论结果直接告诉进程“<strong>不用等待,晚点再来</strong>”,那就是非阻塞</p></li></ul><h4 id="IO模型对比"><a href="#IO模型对比" class="headerlink" title="IO模型对比"></a>IO模型对比</h4><p><strong><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://mmbiz.qpic.cn/mmbiz_png/x0aJCHEALOVINn8dZh1a2Ytw6UHicKK4giaXf9TBYJ7Kes5jnGHAkULmDUria9Dx7gSE7kxMsU0eI072s2lEIbhxQ/640?wx_fmt=png"></strong></p><ul><li><p>  根基上述的同步与异步IO定义并结合上述的模型可知,只有异步IO模型符合POSIX规范的异步IO,其他IO模型都存在recvfrom系统调用被内核阻塞,属于同步IO操作</p></li><li><p>  由此可知,阻塞IO与非阻塞IO可总结如下:</p></li><li><p>  也就是说,要么称为同步与异步IO,要么称为上述5种模型的IO说法,注意上述的同步与异步的概念</p></li><li><p>  大部分操作系统都是基于同步IO的方式实现,对于支持异步IO模型的操作系统还不确定,在实际工作我们经常会说Blocking-IO(阻塞IO)和Non-Blocking-IO(非阻塞IO),极少称同步IO与异步IO</p></li><li><p>  <strong>小结: 同步与异步针对通信机制,阻塞与非阻塞针对程序调用等待结果的状态</strong></p></li></ul><p><strong>一句话总结</strong>：</p><ul><li>  阻塞IO与非阻塞IO</li></ul><blockquote><p>这是最简单的模型，一般配合多线程来实现。</p></blockquote><ul><li>  多路复用(select/poll/epoll)</li></ul><blockquote><p>一个线程解决多连接的问题</p></blockquote><ul><li>  信号驱动IO模型</li></ul><blockquote><p>一种同步IO，更加灵活</p></blockquote><ul><li>  异步IO模型</li></ul><blockquote><p>高效主流的模型，效率很高。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;I-O-五种IO模型&quot;&gt;&lt;a href=&quot;#I-O-五种IO模型&quot; class=&quot;headerlink&quot; title=&quot;I/O 五种IO模型&quot;&gt;&lt;/a&gt;I/O 五种IO模型&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>02.RocketMQ部署</title>
    <link href="https://leslieaibin.github.io/2022/03/17/RocketMq/02.RocketMq%E9%83%A8%E7%BD%B2/"/>
    <id>https://leslieaibin.github.io/2022/03/17/RocketMq/02.RocketMq%E9%83%A8%E7%BD%B2/</id>
    <published>2022-03-17T11:15:42.000Z</published>
    <updated>2022-05-14T08:56:43.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h1><p>部署条件：</p><ul><li><strong>JDK 1.8.0_322</strong></li><li><strong>Maven Apache Maven 3.5.4</strong></li></ul><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>打开 <a href="http://rocketmq.apache.org/release_notes/">RocketMQ release_notes</a> 页面，我们可以看到 RocketMQ 所有的发布版本。这里，我们选择最新的 <a href="http://rocketmq.apache.org/release_notes/release-notes-4.6.0/">RocketMQ 4.6.0</a> 版本。点击进入该版本的发布页面后，我们可以看到两种发布版本：</p><ul><li>Source: <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.6.0/rocketmq-all-4.6.0-source-release.zip">rocketmq-all-4.6.0-source-release.zip</a></li><li>Binary: <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.6.0/rocketmq-all-4.6.0-bin-release.zip">rocketmq-all-4.6.0-bin-release.zip</a></li></ul><p>一般情况下，我们可以直接使用 Binary 版本，它是 RocketMQ 已经编译好，可以直接使用的 RocketMQ 软件包。</p><p>这里，我们想带着胖友们编译一次 RocketMQ 源码，所以使用 Source 版本。下面，我们开始下载 RocketMQ 4.6.0 Source 源码。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget wget http://mirror.bit.edu.cn/apache/rocketmq/4.9.3/rocketmq-all-4.9.3-source-release.zip</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> unzip rocketmq-all-4.9.3-source-release.zip</span></span><br></pre></td></tr></table></figure><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><p>使用 Maven 编译 RocketMQ 源码。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 RocketMQ 源码目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> rocketmq-all-4.9.3-source-release</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Maven 编译 RocketMQ ，并跳过测试。耐心等待...</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mvn -Prelease-all -DskipTests clean install -U</span></span><br></pre></td></tr></table></figure><p>编译完成，在我们进入 distribution 目录下，就可以看到 RocketMQ 的发布包了。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 distribution 目录下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> distribution/target/rocketmq-4.9.3/rocketmq-4.9.3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">40 -rwxr-xr-x   1 yunai  staff  17336 Nov 19 20:59 LICENSE</span><br><span class="line"> 8 -rwxr-xr-x   1 yunai  staff   1338 Nov 19 20:59 NOTICE</span><br><span class="line">16 -rwxr-xr-x   1 yunai  staff   4225 Nov 19 20:59 README.md</span><br><span class="line"> 0 drwxr-xr-x   6 yunai  staff    192 Dec  3 12:48 benchmark # 性能基准测试</span><br><span class="line"> 0 drwxr-xr-x  30 yunai  staff    960 Nov 19 20:59 bin # 执行脚本</span><br><span class="line"> 0 drwxr-xr-x  12 yunai  staff    384 Nov 19 20:59 conf # 配置文件</span><br><span class="line"> 0 drwxr-xr-x  36 yunai  staff   1152 Dec  3 12:48 lib # RocketMQ jar 包</span><br></pre></td></tr></table></figure><h2 id="启动Namesrv"><a href="#启动Namesrv" class="headerlink" title="启动Namesrv"></a>启动Namesrv</h2><p>启动一个 RocketMQ Namesrv 服务。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure><p>启动完成后，查看日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 Namesrv 日志。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tail -f ~/logs/rocketmqlogs/namesrv.log</span></span><br><span class="line"></span><br><span class="line">2019-12-03 12:58:04 INFO main - The Name Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure><ul><li>默认情况下，Namesrv 日志文件所在地址为 <code>~/logs/rocketmqlogs/namesrv.log</code> 。如果想要自定义，可以通过 <code>conf/logback_namesrv.xml</code> 配置文件来进行修改。</li></ul><p>本人是Mac m1 芯片可能会出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动RocketMQ报错：Please set the JAVA_HOME variable in your environment, We need java <span class="number">64</span></span><br></pre></td></tr></table></figure><p>解决方法：</p><p><a href="https://blog.csdn.net/suiyu_eran/article/details/104432164">https://blog.csdn.net/suiyu_eran/article/details/104432164</a></p><h2 id="启动-Broker"><a href="#启动-Broker" class="headerlink" title="启动 Broker"></a>启动 Broker</h2><p>在 <code>conf</code> 目录下，RocketMQ 提供了多种 Broker 的配置文件：</p><ul><li><code>broker.conf</code> ：单主，异步刷盘。</li><li><code>2m/</code> ：双主，异步刷盘。</li><li><code>2m-2s-async/</code> ：两主两从，异步复制，异步刷盘。</li><li><code>2m-2s-sync/</code> ：两主两从，同步复制，异步刷盘。</li><li><code>dledger/</code> ：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/dledger/deploy_guide.md">Dledger 集群</a>，至少三节点。</li></ul><p>这里，我们只启动一个 RocketMQ Broker 服务，所以使用 <code>broker.conf</code> 配置文件。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -c conf/broker.conf  -n 127.0.0.1:9876 &amp;</span><br></pre></td></tr></table></figure><ul><li><p>通过 <code>-c</code> 参数，配置读取的主 Broker 配置。</p></li><li><p>通过 <code>-n</code> 参数，设置 RocketMQ Namesrv 地址。</p></li><li><p>如果胖友的服务器的存相对小，可以修改下 <code>bin/runbroker.sh</code> 脚本，将 Broker JVM 内存调小。如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g&quot;</span><br></pre></td></tr></table></figure></li></ul><p>启动完成后，查看日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br><span class="line"></span><br><span class="line">2019-12-03 14:27:07 INFO main - The broker[broker-a, 192.168.3.44:10911] boot success. serializeType=JSON and name server is 127.0.0.1:9876</span><br></pre></td></tr></table></figure><ul><li>默认情况下，Broker 日志文件所在地址为 <code>~/logs/rocketmqlogs/broker.log</code> 。如果想要自定义，可以通过 <code>conf/logback_broker.xml</code> 配置文件来进行修改。</li></ul><h2 id="测试发送消息"><a href="#测试发送消息" class="headerlink" title="测试发送消息"></a>测试发送消息</h2><p>通过使用 <code>bin/tools.sh</code> 工具类，实现测试发送消息。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//查看broker配置</span><br><span class="line">sh ./bin/mqbroker -m</span><br><span class="line"></span><br><span class="line">//关闭broker</span><br><span class="line">sh bin/mqshutdown broker</span><br><span class="line"></span><br><span class="line">//将本机远程ip写入配置文件中</span><br><span class="line">echo &#x27;brokerIP1=111.231.XX.XX&#x27; &gt; conf/broker.properties </span><br><span class="line"></span><br><span class="line">//重新启动broker  最好用这个命令</span><br><span class="line">nohup sh bin/mqbroker -n 111.231.XX.XX:9876 -c conf/broker.conf autoCreateTopicEnable=true &amp;</span><br></pre></td></tr></table></figure><p>如果发送成功，我们会看到大量成功的发送日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SendResult [sendStatus=SEND_OK, msgId=FE800000000000004F2B5386138462F500000D7163610D67E7F100F4, offsetMsgId=C0A8032C00002A9F000000000000D7EE, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=0], queueOffset=61]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=FE800000000000004F2B5386138462F500000D7163610D67E7F200F5, offsetMsgId=C0A8032C00002A9F000000000000D8D1, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=1], queueOffset=61]</span><br></pre></td></tr></table></figure><ul><li>通过发送结果为 <code>sendStatus=SEND_OK</code> 状态，说明消息都发送成功了。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 发送的启动地址</span></span><br><span class="line">/Users/leslie/rocketmq-all-4.9.3/distribution/target/rocketmq-4.9.3/rocketmq-4.9.3</span><br></pre></td></tr></table></figure><h2 id="测试消费消息"><a href="#测试消费消息" class="headerlink" title="测试消费消息"></a>测试消费消息</h2><p>通过使用 <code>bin/tools.sh</code> 工具类，实现测试消费消息。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置 Namesrv 服务器的地址</span></span><br><span class="line">export NAMESRV_ADDR=127.0.0.1:9876</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行消费者 Consumer 消费测试消息</span></span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure><p>如果消费成功，我们会看到大量成功的消费日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConsumeMessageThread_4 Receive New Messages: [MessageExt [queueId=2, storeSize=227, queueOffset=131, sysFlag=0, bornTimestamp=1575354513732, bornHost=/192.168.3.44:55510, storeTimestamp=1575354513733, storeHost=/192.168.3.44:10911, msgId=C0A8032C00002A9F000000000001D1FC, commitLogOffset=119292, bodyCRC=1549304357, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=&#x27;TopicTest&#x27;, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=145, CONSUME_START_TIME=1575354867104, UNIQ_KEY=FE800000000000004F2B5386138462F500000D7163610D67E944020E, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 53, 50, 54], transactionId=&#x27;null&#x27;&#125;]]</span><br><span class="line">ConsumeMessageThread_3 Receive New Messages: [MessageExt [queueId=2, storeSize=227, queueOffset=130, sysFlag=0, bornTimestamp=1575354513729, bornHost=/192.168.3.44:55510, storeTimestamp=1575354513729, storeHost=/192.168.3.44:10911, msgId=C0A8032C00002A9F000000000001CE70, commitLogOffset=118384, bodyCRC=1530218044, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=&#x27;TopicTest&#x27;, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=145, CONSUME_START_TIME=1575354867103, UNIQ_KEY=FE800000000000004F2B5386138462F500000D7163610D67E941020A, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 53, 50, 50], transactionId=&#x27;null&#x27;&#125;]]</span><br></pre></td></tr></table></figure><ul><li>通过 <code>ConsumeMessageThread_4</code> 和 <code>ConsumeMessageThread_3</code> 线程名，我们可以看出，目前是进行并发消费消息。</li></ul><h1 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h1><h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建 DefaultMQProduer 对象</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;Please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 设置RocketMQ Namesrv的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 启动producer 生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 4. 创建 Message消息</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                        <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                        (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 5. 同步message发送消息</span></span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">                <span class="comment">// 6. 打印发送的结果</span></span><br><span class="line">                System.out.println(sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7. 关闭 producer 生产者</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化一个 Producer 生产者。</p><ul><li>1处，创建 DefaultMQProducer 对象，这里设置的生产者分组是 <code>&quot;please_rename_unique_group_name&quot;</code> 。</li><li>2处，设置 设置 <code>producer</code> 的 RocketMQ Namesrv 地址。这里，是艿艿额外添加的代码。</li><li>3处，启动 <code>producer</code> 生产者。</li></ul><p>使用 Producer 发送 1000 条消息。</p><ul><li><p>4处，创建 Message 消息。这里设置了其 Topic 为 <code>&quot;TopicTest&quot;</code>，Tag 为 <code>TagA</code>、消息体 Body 为 <code>&quot;Hello RocketMQ&quot;</code> 的二进制数组。</p></li><li><p>5 处，调用生产者的 <code>#send(Message msg)</code> 方法，<strong>同步</strong>发送消息，等待发送结果。RocketMQ Producer 一共有三种发送消息的方式，除了我们这里看到的同步发送消息之外，还有<strong>异步</strong>发送消息(可见 <a href="https://github.com/apache/rocketmq/blob/master/example/src/main/java/org/apache/rocketmq/example/simple/AsyncProducer.java">AsyncProducer</a> 示例)，和 <strong>Oneway</strong> 发送消息。</p></li><li><p>6处，打印发送结果。</p></li><li><p>7处，关闭 <code>producer</code> 生产者。</p></li></ul><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建DefaultMQPushConsumer 对象</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;Please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 设置RocketMQ Namesrv 地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 设置消费进度， 从Topic最初位置开始</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// 4. 订阅TopicTest主题</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 添加消息监听器</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="comment">// 返回成功</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//6. 启动producer 消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 打印 Consumer 启动完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>1 处，创建 DefaultMQPushConsumer 对象，这里设置的消费者分组是 <code>&quot;please_rename_unique_group_name&quot;</code> 。注意，消费者分组的概念：</p><blockquote><p>FROM <a href="https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md">概念(Concept)</a></p><p>同一类 Consumer 的集合，这类 Consumer 通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。</p><p>要注意的是，消费者组的消费者实例必须订阅完全相同的 Topic 。</p><p>RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p><ul><li>在集群消费下，同一条消息<strong>只</strong>会被<strong>相同</strong>消费者分组的<strong>一个</strong>消费者所消费。</li><li>在广播消费下，同一条消息会被<strong>相同</strong>消费者分组的<strong>所有</strong>消费者所消费。</li><li>在当前示例里，我们采用的是 DefaultMQPushConsumer 的默认消费方式，集群消费。</li></ul></blockquote></li><li><p>2处，设置 <code>consumer</code> 的 RocketMQ Namesrv 地址。这里，是艿艿额外添加的代码。</p></li><li><p>3处，设置一个新的消费集群，初始的消费进度。目前有三个选项：</p><ul><li><code>CONSUME_FROM_FIRST_OFFSET</code> ：每个 Topic 队列的第一条消息。</li><li><code>CONSUME_FROM_LAST_OFFSET</code> ：每个 Topic 队列的最后一条消息。</li><li><code>CONSUME_FROM_TIMESTAMP</code> ：每个 Topic 队列的指定时间开始的消息。</li><li>注意，只针对<strong>新的</strong>消费集群。如果一个集群每个 Topic 已经有消费进度，则继续使用该消费进度。仔细理解一下哈~</li></ul></li><li><p>4处，设置订阅 <code>&quot;TopicTest&quot;</code> 主题的消息。有一定一定要注意！！！<strong>消费者组的消费者实例必须订阅完全相同的 Topic + Tag</strong> 。</p></li><li><p>5处，添加消息监听器。这里我们采用的是 <a href="https://github.com/apache/rocketmq/blob/master/client/src/main/java/org/apache/rocketmq/client/consumer/listener/MessageListenerConcurrently.java">MessageListenerConcurrently</a> <strong>并发</strong>消费消息的监听器。如果胖友需要实现<strong>顺序</strong>消费消息，需要使用 <a href="https://github.com/apache/rocketmq/blob/master/client/src/main/java/org/apache/rocketmq/client/consumer/listener/MessageListenerOrderly.java">MessageListenerOrderly</a> <strong>顺序</strong>消费的监听器。</p></li><li><p>6处，启动 <code>consumer</code> 消费者。此时，Consumer 就开始正式的消费消息啦。。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单机部署&quot;&gt;&lt;a href=&quot;#单机部署&quot; class=&quot;headerlink&quot; title=&quot;单机部署&quot;&gt;&lt;/a&gt;单机部署&lt;/h1&gt;&lt;p&gt;部署条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JDK 1.8.0_322&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;st</summary>
      
    
    
    
    <category term="RocketMQ" scheme="https://leslieaibin.github.io/categories/RocketMQ/"/>
    
    
    <category term="RocketMQ" scheme="https://leslieaibin.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>01.RocketMQ概述</title>
    <link href="https://leslieaibin.github.io/2022/03/17/RocketMq/01.RocketMq%E5%85%A5%E9%97%A8/"/>
    <id>https://leslieaibin.github.io/2022/03/17/RocketMq/01.RocketMq%E5%85%A5%E9%97%A8/</id>
    <published>2022-03-17T01:15:42.000Z</published>
    <updated>2022-05-14T08:56:38.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>阿里巴巴消息中间件起源于 2001 年的五彩石项目， Notify 在这期间应运而生，用于交易核心消息的流转 。</p><ul><li><p>2010 年， B2B 开始大规模使用 ActiveMQ 作为消息内核，随着阿里业务的快速发展，急需一款支持顺序消息，拥有海量消息堆积能力的消息中间件， MetaQ 1.0 在 2011年诞生 。</p></li><li><p>2012年， MetaQ已经发展到了3.0版本，并抽象出了通用的消息引擎 RocketMQ。 随后，对 RocketMQ 进行了开源 ，阿里的消息中间件正式走人了 公众视野 。</p></li><li><p>2015年， RocketMQ已经经历了多年双十一的洗礼，在可用性、 可靠性以 及稳定性等方面都有出色的表现。与此同时 ，云计算大行其道， 阿里消息中间 件基于 RocketMQ推出了 Aliware MQ 1.0，开始为阿里云上成千上万家企业提 供消息服务 。</p></li><li><p>2016 年， MetaQ 在双十一期间承载了万亿级消息的流转，跨越了一个新的里程碑 ，同时 RocketMQ 进入Apache 孵化 。</p></li><li><p>2016年11月，阿里巴巴正式将RocketMQ捐献给Apache基金会，</p></li><li><p>2017年9月从Apache社区正式毕业，成为Apache的顶级开源项目。毕业之后RocketMQ受到了更为广泛的关注，除中国之外、日本、新加坡、泰国、俄罗斯、德国、美国、加拿大等国家也在关注RocketMQ。</p></li><li><p>2017年10月，我们提出OpenMessaging，OpenMessaging是一个消息标准，最初阿里有许多消息中间件，中间存在几个问题：</p><ul><li>面对不同的消息中间件，用户学习成本较高。</li><li>迁移成本非常高，且结果不统一。</li></ul></li><li><p>2018年我们提出RocketMQ 5.0，可能会做一些架构计算分离，包括协议可插拔，支持IoT的一些场景，目前我们正在演进该版本。</p></li></ul><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220317145623986.png" alt="image-20220317145623986"></p><p><strong>产生原因：</strong></p><p>淘宝内部的交易系统使用了淘宝自主研发的 Notify 消息中间件，使用 MySQL 作为消息存储媒介，可完全水平扩容。</p><p>为了进一步降低成本，我们认为存储部分可以进一步优化。2011 年初，Linkin 开源了 Kafka 这个优秀的消息中间件，淘宝中间件团队在对 Kafka 做过充分 Review 之后， Kafka 无限消息堆积，高效的持久化速度吸引了我们。</p><p>但是，同时发现这个消息系统主要定位于日志传输，对于使用在淘宝交易、订单、充值等场景下还有诸多特性不满足，为此我们重新用 Java 语言编写了 RocketMQ ，定位于非日志的可靠消息传输（日志场景也 OK）。</p><p>目前 RocketMQ 在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理， binglog 分发等场景。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="消息模型（Message-Model）"><a href="#消息模型（Message-Model）" class="headerlink" title="消息模型（Message Model）"></a>消息模型（Message Model）</h2><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p><h2 id="消息生产者（Producer）"><a href="#消息生产者（Producer）" class="headerlink" title="消息生产者（Producer）"></a>消息生产者（Producer）</h2><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p><h2 id="消息消费者（Consumer）"><a href="#消息消费者（Consumer）" class="headerlink" title="消息消费者（Consumer）"></a>消息消费者（Consumer）</h2><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p><h2 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）"></a>主题（Topic）</h2><p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p><h2 id="代理服务器（Broker-Server）"><a href="#代理服务器（Broker-Server）" class="headerlink" title="代理服务器（Broker Server）"></a>代理服务器（Broker Server）</h2><p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p><h2 id="名字服务（Name-Server）"><a href="#名字服务（Name-Server）" class="headerlink" title="名字服务（Name Server）"></a>名字服务（Name Server）</h2><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p><h2 id="拉取式消费（Pull-Consumer）"><a href="#拉取式消费（Pull-Consumer）" class="headerlink" title="拉取式消费（Pull Consumer）"></a>拉取式消费（Pull Consumer）</h2><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p><h2 id="推动式消费（Push-Consumer）"><a href="#推动式消费（Push-Consumer）" class="headerlink" title="推动式消费（Push Consumer）"></a>推动式消费（Push Consumer）</h2><p>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p><h2 id="生产者组（Producer-Group）"><a href="#生产者组（Producer-Group）" class="headerlink" title="生产者组（Producer Group）"></a>生产者组（Producer Group）</h2><p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p><h2 id="消费者组（Consumer-Group）"><a href="#消费者组（Consumer-Group）" class="headerlink" title="消费者组（Consumer Group）"></a>消费者组（Consumer Group）</h2><p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p><h2 id="集群消费（Clustering）"><a href="#集群消费（Clustering）" class="headerlink" title="集群消费（Clustering）"></a>集群消费（Clustering）</h2><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p><h2 id="广播消费（Broadcasting）"><a href="#广播消费（Broadcasting）" class="headerlink" title="广播消费（Broadcasting）"></a>广播消费（Broadcasting）</h2><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p><h2 id="普通顺序消息（Normal-Ordered-Message）"><a href="#普通顺序消息（Normal-Ordered-Message）" class="headerlink" title="普通顺序消息（Normal Ordered Message）"></a>普通顺序消息（Normal Ordered Message）</h2><p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p><h2 id="严格顺序消息（Strictly-Ordered-Message）"><a href="#严格顺序消息（Strictly-Ordered-Message）" class="headerlink" title="严格顺序消息（Strictly Ordered Message）"></a>严格顺序消息（Strictly Ordered Message）</h2><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p><h2 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）"></a>消息（Message）</h2><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p><h2 id="标签（Tag）"><a href="#标签（Tag）" class="headerlink" title="标签（Tag）"></a>标签（Tag）</h2><p>为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p><h1 id="相关特性"><a href="#相关特性" class="headerlink" title="相关特性"></a>相关特性</h1><h2 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h2><p>消息的发布是指某个生产者向某个topic发送消息；消息的订阅是指某个消费者关注了某个topic中带有某些tag的消息，进而从该topic消费数据。</p><h2 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h2><p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ可以严格的保证消息有序。</p><p>顺序消息分为全局顺序消息与分区顺序消息，全局顺序是指某个Topic下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</p><ul><li>全局顺序 对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。 适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</li><li>分区顺序 对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。 Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。 适用场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</li></ul><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>RocketMQ的消费者可以根据Tag进行消息过滤，也支持自定义属性过滤。消息过滤目前是在Broker端实现的，优点是减少了对于Consumer无用消息的网络传输，缺点是增加了Broker的负担、而且实现相对复杂。</p><h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><p>RocketMQ支持消息的高可靠，影响消息可靠性的几种情况：</p><ol><li>Broker非正常关闭</li><li>Broker异常Crash</li><li>OS Crash</li><li>机器掉电，但是能立即恢复供电情况</li><li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</li><li>磁盘设备损坏</li></ol><p>1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p><p>5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。</p><h2 id="至少一次"><a href="#至少一次" class="headerlink" title="至少一次"></a>至少一次</h2><p>至少一次(At least Once)指每个消息必须投递一次。Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。</p><h2 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h2><p>回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ支持按照时间回溯消费，时间维度精确到毫秒。</p><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>RocketMQ事务消息（Transactional Message）是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ的事务消息提供类似 X/Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致。</p><h2 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h2><p>定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。 broker有配置项messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。可以配置自定义messageDelayLevel。注意，messageDelayLevel是broker的属性，不属于某个topic。发消息时，设置delayLevel等级即可：msg.setDelayLevel(level)。level有以下三种情况：</p><ul><li>level == 0，消息为非延迟消息</li><li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1s</li><li>level &gt; maxLevel，则level== maxLevel，例如level==20，延迟2h</li></ul><p>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p><p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p><h2 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h2><p>Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p><ul><li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。</li><li>由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</li></ul><p>RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p><h2 id="消息重投"><a href="#消息重投" class="headerlink" title="消息重投"></a>消息重投</h2><p>生产者在发送消息时，同步消息失败会重投，异步消息有重试，oneway没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在RocketMQ中是无法避免的问题。消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer负载变化也会导致重复消息。如下方法可以设置消息重试策略：</p><ul><li>retryTimesWhenSendFailed:同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed + 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。</li><li>retryTimesWhenSendAsyncFailed:异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</li><li>retryAnotherBrokerWhenNotStoreOK:消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。十分重要消息可以开启。</li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>生产者流控，因为broker处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</p><p>生产者流控：</p><ul><li>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认为1000ms，返回流控。</li><li>如果开启transientStorePoolEnable == true，且broker为异步刷盘的主机，且transientStorePool中资源不足，拒绝当前send请求，返回流控。</li><li>broker每隔10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsInSendQueue，默认200ms，拒绝当前send请求，返回流控。</li><li>broker通过拒绝send 请求方式实现流量控制。</li></ul><p>注意，生产者流控，不会尝试消息重投。</p><p>消费者流控：</p><ul><li>消费者本地缓存消息数超过pullThresholdForQueue时，默认1000。</li><li>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB。</li><li>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认2000。</li></ul><p>消费者流控的结果是降低拉取频率。</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p><p>RocketMQ将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。在RocketMQ中，可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p> <img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220317152620545.png" alt="image-20220317152620545"></p><ul><li>生产者（Producer）：负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。</li><li>消费者（Consumer）：负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。</li><li>消息服务器（Broker）：是消息存储中心，主要作用是接收来自 Producer 的消息并存储， Consumer 从这里取得消息。</li><li>名称服务器（NameServer）：用来保存 Broker 相关 Topic 等元信息并给 Producer ，提供 Consumer 查找 Broker 信息。</li></ul><h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220317152958574.png" alt="image-20220317152958574"></p><p>1、启动 <strong>Namesrver</strong>，Namesrver起来后监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心。</p><p>2、<strong>Broker</strong> 启动，跟所有的 Namesrver 保持长连接，定时发送心跳包。</p><blockquote><p>心跳包中，包含当前 Broker 信息(IP+端口等)以及存储所有 Topic 信息。 注册成功后，Namesrver 集群中就有 Topic 跟 Broker 的映射关系。</p></blockquote><p>3、收发消息前，先创建 Topic 。创建 Topic 时，需要指定该 Topic 要存储在哪些 Broker上。也可以在发送消息时自动创建Topic。</p><p>4、<strong>Producer</strong> 发送消息。</p><blockquote><p>启动时，先跟 Namesrver 集群中的其中一台建立长连接，并从Namesrver 中获取当前发送的 Topic 存在哪些 Broker 上，然后跟对应的 Broker 建立长连接，直接向 Broker 发消息。</p></blockquote><p>5、<strong>Consumer</strong> 消费消息。</p><blockquote><p>Consumer 跟 Producer 类似。跟其中一台 Namesrv 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始消费消息。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>目前 RocketMQ 4 的中文文档很少，所以英文不太好的胖友，后续推荐看看如下资料：</p><ul><li><a href="http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408164726/RocketMQ_userguide.pdf">《RocketMQ 用户指南》</a> 基于 RocketMQ 3 的版本。</li><li><a href="http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408165024/RocketMQ_design.pdf">《RocketMQ 原理简介》</a> 基于 RocketMQ 3 的版本。</li><li><a href="http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408164929/RocketMQ_experience.pdf">《RocketMQ 最佳实践》</a> 基于 RocketMQ 3 的版本。</li><li><a href="https://github.com/apache/rocketmq/tree/master/docs/cn">《RocketMQ 开发者指南》</a> 基于 RocketMQ 4 的版本。</li><li><a href="https://help.aliyun.com/product/29530.html?spm=a2c4g.11186623.6.540.68cc5b3aZYDU2Y">《阿里云 —— 消息队列 MQ》</a> 阿里云的消息队列，就是 RocketMQ 的云服务。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;阿里巴巴消息中间件起源于 2001 年的五彩石项目， Notify 在这期间应运而生，用于交易核心消息的流转 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="RocketMQ" scheme="https://leslieaibin.github.io/categories/RocketMQ/"/>
    
    
    <category term="RocketMQ" scheme="https://leslieaibin.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>8.select poll epoll 区别</title>
    <link href="https://leslieaibin.github.io/2022/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.select%20poll%20%E5%92%8C%20epoll%E5%8C%BA%E5%88%AB/"/>
    <id>https://leslieaibin.github.io/2022/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.select%20poll%20%E5%92%8C%20epoll%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-10T16:15:42.000Z</published>
    <updated>2022-05-14T09:03:08.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="select、poll和epoll区别"><a href="#select、poll和epoll区别" class="headerlink" title="select、poll和epoll区别"></a>select、poll和epoll区别</h1><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic2.zhimg.com/v2-3c486898d786b26259c6abd6854794f5_b.jpg"></p><p>select单个进程可监视的fd数量受到限制，epoll和select都可实现同时监听多个I/O事件的状态。</p><ul><li>  select 基于轮训机制</li><li>  epoll基于操作系统支持的I/O通知机制 epoll支持水平触发和边沿触发两种模式。</li></ul><h2 id="1-select"><a href="#1-select" class="headerlink" title="1 select"></a>1 select</h2><p>select本质上是通过设置或检查存放fd标志位的数据结构进行下一步处理。 这带来缺点：</p><ul><li>  单个进程可监视的fd数量被限制，即能监听端口的数量有限 单个进程所能打开的最大连接数有<code>FD_SETSIZE</code>宏定义，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上FD_SETSIZE为3264），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试 一般该数和系统内存关系很大，具体数目可以<code>cat /proc/sys/fs/file-max</code>察看。32位机默认1024个，64位默认2048。</li></ul><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-62bedee13b5fa6c4022ade31c942316c_b.png"></p><ul><li>  对socket是线性扫描，即轮询，效率较低： 仅知道有I/O事件发生，却不知是哪几个流，只会无差异轮询所有流，找出能读数据或写数据的流进行操作。同时处理的流越多，无差别轮询时间越长 - O(n)。</li></ul><p>当socket较多时，每次select都要通过遍历<code>FD_SETSIZE</code>个socket，不管是否活跃，这会浪费很多CPU时间。如果能给 socket 注册某个回调函数，当他们活跃时，自动完成相关操作，即可避免轮询，这就是<strong>epoll</strong>与<strong>kqueue</strong>。</p><h2 id="1-1-调用过程"><a href="#1-1-调用过程" class="headerlink" title="1.1 调用过程"></a>1.1 调用过程</h2><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-7a9905f316445b3d7f7287d80a6fe460_b.jpg"></p><pre><code>asmlinkage long sys_poll(struct pollfd * ufds, unsigned int nfds, long timeout)&#123;    int i, j, fdcount, err;    struct pollfd **fds;    struct poll_wqueues table, *wait;    int nchunks, nleft;    /* Do a sanity check on nfds ... */    if (nfds &gt; NR_OPEN)        return -EINVAL;    if (timeout) &#123;        /* Careful about overflow in the intermediate values */        if ((unsigned long) timeout &lt; MAX_SCHEDULE_TIMEOUT / HZ)            timeout = (unsigned long)(timeout*HZ+999)/1000+1;        else /* Negative or overflow */            timeout = MAX_SCHEDULE_TIMEOUT;    &#125;    // 2. 注册回调函数__pollwait    poll_initwait(&amp;table);    wait = &amp;table;    if (!timeout)        wait = NULL;    err = -ENOMEM;    fds = NULL;    if (nfds != 0) &#123;        fds = (struct pollfd **)kmalloc(            (1 + (nfds - 1) / POLLFD_PER_PAGE) * sizeof(struct pollfd *),            GFP_KERNEL);        if (fds == NULL)            goto out;    &#125;    nchunks = 0;    nleft = nfds;    while (nleft &gt; POLLFD_PER_PAGE) &#123; /* allocate complete PAGE_SIZE chunks */        fds[nchunks] = (struct pollfd *)__get_free_page(GFP_KERNEL);        if (fds[nchunks] == NULL)            goto out_fds;        nchunks++;        nleft -= POLLFD_PER_PAGE;    &#125;    if (nleft) &#123; /* allocate last PAGE_SIZE chunk, only nleft elements used */        fds[nchunks] = (struct pollfd *)__get_free_page(GFP_KERNEL);        if (fds[nchunks] == NULL)            goto out_fds;    &#125;    err = -EFAULT;    for (i=0; i &lt; nchunks; i++)        //         if (copy_from_user(fds[i], ufds + i*POLLFD_PER_PAGE, PAGE_SIZE))            goto out_fds1;    if (nleft) &#123;        if (copy_from_user(fds[nchunks], ufds + nchunks*POLLFD_PER_PAGE,                 nleft * sizeof(struct pollfd)))            goto out_fds1;    &#125;    fdcount = do_poll(nfds, nchunks, nleft, fds, wait, timeout);    /* OK, now copy the revents fields back to user space. */    for(i=0; i &lt; nchunks; i++)        for (j=0; j &lt; POLLFD_PER_PAGE; j++, ufds++)            __put_user((fds[i] + j)-&gt;revents, &amp;ufds-&gt;revents);    if (nleft)        for (j=0; j &lt; nleft; j++, ufds++)            __put_user((fds[nchunks] + j)-&gt;revents, &amp;ufds-&gt;revents);    err = fdcount;    if (!fdcount &amp;&amp; signal_pending(current))        err = -EINTR;out_fds1:    if (nleft)        free_page((unsigned long)(fds[nchunks]));out_fds:    for (i=0; i &lt; nchunks; i++)        free_page((unsigned long)(fds[i]));    if (nfds != 0)        kfree(fds);out:    poll_freewait(&amp;table);    return err;&#125;static int do_poll(unsigned int nfds, unsigned int nchunks, unsigned int nleft,     struct pollfd *fds[], struct poll_wqueues *wait, long timeout)&#123;    int count;    poll_table* pt = &amp;wait-&gt;pt;    for (;;) &#123;        unsigned int i;        set_current_state(TASK_INTERRUPTIBLE);        count = 0;        for (i=0; i &lt; nchunks; i++)            do_pollfd(POLLFD_PER_PAGE, fds[i], &amp;pt, &amp;count);        if (nleft)            do_pollfd(nleft, fds[nchunks], &amp;pt, &amp;count);        pt = NULL;        if (count || !timeout || signal_pending(current))            break;        count = wait-&gt;error;        if (count)            break;        timeout = schedule_timeout(timeout);    &#125;    current-&gt;state = TASK_RUNNING;    return count;&#125;</code></pre><ol><li> 使用copy_from_user从用户空间拷贝fd_set到内核空间</li><li> 注册回调函数<code>__pollwait</code></li></ol><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-d4a98237f706b112ab6c6a6a94b6539c_b.jpg"></p><ol><li><p> 遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll，udp_poll或datagram_poll）</p></li><li><p> 以tcp_poll为例，核心实现就是<code>__pollwait</code>，即上面注册的回调函数</p></li><li><p> <code>__pollwait</code>，就是把current（当前进程）挂到设备的等待队列，不同设备有不同等待队列，如tcp_poll的等待队列是sk-&gt;sk_sleep（把进程挂到等待队列中并不代表进程已睡眠）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒。</p></li><li><p> poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值</p></li><li><p> 若遍历完所有fd，还没返回一个可读写的mask掩码，则调schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。若超过一定超时时间（schedule_timeout指定），还没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有无就绪的fd</p></li><li><p> 把fd_set从内核空间拷贝到用户空间</p></li></ol><h2 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 缺点</h2><p>内核需要将消息传递到用户空间，都需要内核拷贝动作。需要维护一个用来存放大量fd的数据结构，使得用户空间和内核空间在传递该结构时复制开销大。</p><ul><li>  每次调用select，都需把fd集合从用户态拷贝到内核态，fd很多时开销就很大</li><li>  同时每次调用select都需在内核遍历传递进来的所有fd，fd很多时开销就很大</li><li>  select支持的文件描述符数量太小了，默认最大支持1024个</li><li>  主动轮询效率很低</li></ul><h2 id="2-poll"><a href="#2-poll" class="headerlink" title="2 poll"></a>2 poll</h2><p>和select类似，只是描述fd集合的方式不同，poll使用<code>pollfd</code>结构而非select的<code>fd_set</code>结构。 管理多个描述符也是进行轮询，根据描述符的状态进行处理，但<strong>poll没有最大文件描述符数量的限制</strong>。</p><p>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><ul><li><p>  它将用户传入的数组拷贝到内核空间</p></li><li><p>  然后查询每个fd对应的设备状态：</p></li><li><p>  如果设备就绪 在设备等待队列中加入一项继续遍历</p></li><li><p>  若遍历完所有fd后，都没发现就绪的设备 挂起当前进程，直到设备就绪或主动超时，被唤醒后它又再次遍历fd。这个过程经历多次无意义的遍历。</p></li></ul><p>没有最大连接数限制，因其基于链表存储，其缺点：</p><ul><li>  大量fd数组被整体复制于用户态和内核地址空间间，而不管是否有意义</li><li>  如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd</li></ul><p>所以又有了epoll模型。</p><h2 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3 epoll"></a>3 epoll</h2><p>epoll模型修改主动轮询为被动通知，当有事件发生时，被动接收通知。所以epoll模型注册套接字后，主程序可做其他事情，当事件发生时，接收到通知后再去处理。</p><p>可理解为<strong>event poll</strong>，epoll会把哪个流发生哪种I/O事件通知我们。所以epoll是事件驱动（每个事件关联fd），此时我们对这些流的操作都是有意义的。复杂度也降到O(1)。</p><pre><code>asmlinkage int sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)&#123;    int error;    struct file *file, *tfile;    struct eventpoll *ep;    struct epitem *epi;    struct epoll_event epds;    error = -EFAULT;    if (copy_from_user(&amp;epds, event, sizeof(struct epoll_event)))        goto eexit_1;    /* Get the &quot;struct file *&quot; for the eventpoll file */    error = -EBADF;    file = fget(epfd);    if (!file)        goto eexit_1;    /* Get the &quot;struct file *&quot; for the target file */    tfile = fget(fd);    if (!tfile)        goto eexit_2;    /* The target file descriptor must support poll */    error = -EPERM;    if (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)        goto eexit_3;    /*     * We have to check that the file structure underneath the file descriptor     * the user passed to us _is_ an eventpoll file. And also we do not permit     * adding an epoll file descriptor inside itself.     */    error = -EINVAL;    if (file == tfile || !IS_FILE_EPOLL(file))        goto eexit_3;    /*     * At this point it is safe to assume that the &quot;private_data&quot; contains     * our own data structure.     */    ep = file-&gt;private_data;    /*     * Try to lookup the file inside our hash table. When an item is found     * ep_find() increases the usage count of the item so that it won&#39;t     * desappear underneath us. The only thing that might happen, if someone     * tries very hard, is a double insertion of the same file descriptor.     * This does not rapresent a problem though and we don&#39;t really want     * to put an extra syncronization object to deal with this harmless condition.     */    epi = ep_find(ep, tfile);    error = -EINVAL;    switch (op) &#123;    case EPOLL_CTL_ADD:        if (!epi) &#123;            epds.events |= POLLERR | POLLHUP;            error = ep_insert(ep, &amp;epds, tfile);        &#125; else            error = -EEXIST;        break;    case EPOLL_CTL_DEL:        if (epi)            error = ep_remove(ep, epi);        else            error = -ENOENT;        break;    case EPOLL_CTL_MOD:        if (epi) &#123;            epds.events |= POLLERR | POLLHUP;            error = ep_modify(ep, epi, &amp;epds);        &#125; else            error = -ENOENT;        break;    &#125;    /*     * The function ep_find() increments the usage count of the structure     * so, if this is not NULL, we need to release it.     */    if (epi)        ep_release_epitem(epi);eexit_3:    fput(tfile);eexit_2:    fput(file);eexit_1:    DNPRINTK(3, (KERN_INFO &quot;[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %u) = %d\n&quot;,             current, epfd, op, fd, event-&gt;events, error));    return error;&#125;</code></pre><p>​    </p><h2 id="3-1-触发模式"><a href="#3-1-触发模式" class="headerlink" title="3.1 触发模式"></a>3.1 触发模式</h2><p><strong>EPOLLLT</strong>和<strong>EPOLLET</strong>两种：</p><ul><li>  LT，默认的模式（水平触发） 只要该fd还有数据可读，每次 <code>epoll_wait</code> 都会返回它的事件，提醒用户程序去操作，</li><li>  ET是“高速”模式（边缘触发）</li></ul><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic2.zhimg.com/v2-310cc7857eabd42e324c109b5ca85b1d_b.png"></p><p>只会提示一次，直到下次再有数据流入之前都不会再提示，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读完，即读到read返回值小于请求值或遇到EAGAIN错误</p><p>epoll使用“事件”的就绪通知方式，通过<code>epoll_ctl</code>注册fd，一旦该fd就绪，内核就会采用类似回调机制激活该fd，<code>epoll_wait</code>便可收到通知。</p><h3 id="EPOLLET触发模式的意义"><a href="#EPOLLET触发模式的意义" class="headerlink" title="EPOLLET触发模式的意义"></a>EPOLLET触发模式的意义</h3><p>若用<code>EPOLLLT</code>，系统中一旦有大量无需读写的就绪文件描述符，它们每次调用<code>epoll_wait</code>都会返回，这大大降低处理程序检索自己关心的就绪文件描述符的效率。 而采用<code>EPOLLET</code>，当被监控的文件描述符上有可读写事件发生时，<code>epoll_wait</code>会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用<code>epoll_wait</code>时，它不会通知你，即只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。这比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。</p><h2 id="3-2-优点"><a href="#3-2-优点" class="headerlink" title="3.2 优点"></a>3.2 优点</h2><ul><li>  没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</li><li>  效率提升，不是轮询，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数 即Epoll最大的优点就在于它只关心“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll</li><li>  内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li><li>  epoll通过内核和用户空间共享一块内存来实现的</li></ul><p>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现。</p><p>select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p><ul><li>  对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</li><li>  对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。</li><li>  对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>select，poll，epoll都是IO多路复用机制，即可以监视多个描述符，一旦某个描述符就绪（读或写就绪），能够通知程序进行相应读写操作。 但select，poll，epoll本质上都是<strong>同步I/O</strong>，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><ul><li>  select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</li><li>  select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;select、poll和epoll区别&quot;&gt;&lt;a href=&quot;#select、poll和epoll区别&quot; class=&quot;headerlink&quot; title=&quot;select、poll和epoll区别&quot;&gt;&lt;/a&gt;select、poll和epoll区别&lt;/h1&gt;&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Ping的原理</title>
    <link href="https://leslieaibin.github.io/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.Ping%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.Ping%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2022-03-08T01:15:42.000Z</published>
    <updated>2022-03-08T02:37:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ping-的工作原理"><a href="#ping-的工作原理" class="headerlink" title="ping 的工作原理"></a>ping 的工作原理</h1><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="IP协议的助手-——-ICMP-协议"><a href="#IP协议的助手-——-ICMP-协议" class="headerlink" title="IP协议的助手 —— ICMP 协议"></a>IP协议的助手 —— ICMP 协议</h3><p>ping 是基于 <code>ICMP</code> 协议工作的，所以要明白 ping 的工作，首先我们先来熟悉 <strong>ICMP 协议</strong>。</p><blockquote><p>ICMP 是什么？</p></blockquote><p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。</p><p>里面有个关键词 —— <strong>控制</strong>，如何控制的呢？</p><p>网络包在复杂的网络传输环境里，常常会遇到各种问题。当遇到问题的时候，总不能死的不明不白，没头没脑的作风不是计算机网络的风格。所以需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。</p><blockquote><p>ICMP 功能都有啥？</p></blockquote><p><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/4.jpg" title="ICMP 目标不可达消息"></p><p>ICMP 目标不可达消息</p><p>如上图例子，主机 <code>A</code> 向主机 <code>B</code> 发送了数据包，由于某种原因，途中的路由器 <code>2</code> 未能发现主机 <code>B</code> 的存在，这时，路由器 <code>2</code> 就会向主机 <code>A</code> 发送一个 <code>ICMP</code> 目标不可达数据包，说明发往主机 <code>B</code> 的包未能成功。</p><p>ICMP 的这种通知消息会使用 <code>IP</code> 进行发送 。</p><p>因此，从路由器 <code>2</code> 返回的 ICMP 包会按照往常的路由控制先经过路由器 <code>1</code> 再转发给主机 <code>A</code> 。收到该 ICMP 包的主机 <code>A</code> 则分解 ICMP 的首部和数据域以后得知具体发生问题的原因。</p><blockquote><p>ICMP 包头格式</p></blockquote><p>ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/5.jpg" title="ICMP 报文">ICMP 报文</p><p>ICMP 包头的<strong>类型</strong>字段，大致可以分为两大类：</p><ul><li>  一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>  另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/6.jpg" title="常见的 ICMP 类型">常见的 ICMP 类型</p><h3 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h3><blockquote><p>回送消息 —— 类型 <code>0</code> 和 <code>8</code></p></blockquote><p><strong>回送消息</strong>用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，<code>ping</code> 命令就是利用这个消息实现的。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/7.jpg" title="ICMP 回送消息">ICMP 回送消息</p><p>可以向对端主机发送<strong>回送请求</strong>的消息（<code>ICMP Echo Request Message</code>，类型 <code>8</code>），也可以接收对端主机发回来的<strong>回送应答</strong>消息（<code>ICMP Echo Reply Message</code>，类型 <code>0</code>）。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/8.jpg" title="ICMP 回送请求和回送应答报文">ICMP 回送请求和回送应答报文</p><p>相比原生的 ICMP，这里多了两个字段：</p><ul><li>  <strong>标识符</strong>：用以区分是哪个应用程序发 ICMP 包，比如用进程 <code>PID</code> 作为标识符；</li><li>  <strong>序号</strong>：序列号从 <code>0</code> 开始，每发送一次新的回送请求就会加 <code>1</code>， 可以用来确认网络包是否有丢失。</li></ul><p>在<strong>选项数据</strong>中，<code>ping</code> 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。</p><h3 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h3><p>接下来，说明几个常用的 ICMP 差错报文的例子：</p><ul><li>  目标不可达消息 —— 类型 为 <code>3</code></li><li>  原点抑制消息 —— 类型 <code>4</code></li><li>  重定向消息 —— 类型 <code>5</code></li><li>  超时消息 —— 类型 <code>11</code></li></ul><blockquote><p>目标不可达消息（Destination Unreachable Message） —— 类型为 <code>3</code></p></blockquote><p>IP 路由器无法将 IP 数据包发送给目标地址时，会给发送端主机返回一个<strong>目标不可达</strong>的 ICMP 消息，并在这个消息中显示不可达的具体原因，原因记录在 ICMP 包头的<strong>代码</strong>字段。</p><p>由此，根据 ICMP 不可达的具体消息，发送端主机也就可以了解此次发送<strong>不可达的具体原因</strong>。</p><p>举例 6 种常见的目标不可达类型的<strong>代码</strong>：</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/9.jpg" title="目标不可达类型的常见代码号">目标不可达类型的常见代码号</p><ul><li>  网络不可达代码为 <code>0</code></li><li>  主机不可达代码为 <code>1</code></li><li>  协议不可达代码为 <code>2</code></li><li>  端口不可达代码为 <code>3</code></li><li>  需要进行分片但设置了不分片位代码为 <code>4</code></li></ul><p>为了给大家说清楚上面的目标不可达的原因，<strong>小林牺牲自己给大家送 5 次外卖。</strong></p><p>为什么要送外卖？别问，问就是为 <code>35</code> 岁的老林做准备 …</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/10.jpg" title="外卖员 —— 小林">外卖员 —— 小林</p><h6 id="a-网络不可达代码为-0"><a href="#a-网络不可达代码为-0" class="headerlink" title="a. 网络不可达代码为 0"></a>a. 网络不可达代码为 0</h6><p><em>外卖版本：</em></p><p>小林第一次送外卖时，小区里只有 A 和 B 区两栋楼，但送餐地址写的是 C 区楼，小林表示头上很多问号，压根就没这个地方。</p><p><em>正常版本：</em></p><p>IP 地址是分为网络号和主机号的，所以当路由器中的路由器表匹配不到接收方 IP 的网络号，就通过 ICMP 协议以<strong>网络不可达</strong>（<code>Network Unreachable</code>）的原因告知主机。</p><p>自从不再有网络分类以后，网络不可达也渐渐不再使用了。</p><h6 id="b-主机不可达代码为-1"><a href="#b-主机不可达代码为-1" class="headerlink" title="b. 主机不可达代码为 1"></a>b. 主机不可达代码为 1</h6><p><em>外卖版本：</em></p><p>小林第二次送外卖时，这次小区有 5 层楼高的 C 区楼了，找到地方了，但送餐地址写的是 C 区楼 601 号房 ，说明找不到这个房间。</p><p><em>正常版本：</em></p><p>当路由表中没有该主机的信息，或者该主机没有连接到网络，那么会通过 ICMP 协议以<strong>主机不可达</strong>（<code>Host Unreachable</code>）的原因告知主机。</p><h6 id="c-协议不可达代码为-2"><a href="#c-协议不可达代码为-2" class="headerlink" title="c. 协议不可达代码为 2"></a>c. 协议不可达代码为 2</h6><p><em>外卖版本：</em></p><p>小林第三次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，但是一开门人家是外国人说的是英语，我说的是中文！语言不通，外卖送达失败~</p><p><em>正常版本：</em></p><p>当主机使用 TCP 协议访问对端主机时，能找到对端的主机了，可是对端主机的防火墙已经禁止 TCP 协议访问，那么会通过 ICMP 协议以<strong>协议不可达</strong>的原因告知主机。</p><h6 id="d-端口不可达代码为-3"><a href="#d-端口不可达代码为-3" class="headerlink" title="d. 端口不可达代码为 3"></a>d. 端口不可达代码为 3</h6><p><em>外卖版本：</em></p><p>小林第四次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，房间里的人也是说中文的人了，但是人家说他要的不是外卖，而是快递。。。</p><p><em>正常版本：</em></p><p>当主机访问对端主机 8080 端口时，这次能找到对端主机了，防火墙也没有限制，可是发现对端主机没有进程监听 8080 端口，那么会通过 ICMP 协议以<strong>端口不可达</strong>的原因告知主机。</p><h6 id="e-需要进行分片但设置了不分片位代码为-4"><a href="#e-需要进行分片但设置了不分片位代码为-4" class="headerlink" title="e. 需要进行分片但设置了不分片位代码为 4"></a>e. 需要进行分片但设置了不分片位代码为 4</h6><p><em>外卖版本：</em></p><p>小林第五次送外卖时，这次是个吃播博主点了 100 份外卖，但是吃播博主要求一次性要把全部外卖送达，小林的一台电动车装不下呀，这样就没办法送达了。</p><p><em>正常版本：</em></p><p>发送端主机发送 IP 数据报时，将 IP 首部的<strong>分片禁止标志位</strong>设置为<code>1</code>。根据这个标志位，途中的路由器遇到超过 MTU 大小的数据包时，不会进行分片，而是直接抛弃。</p><p>随后，通过一个 ICMP 的不可达消息类型，<strong>代码为 4</strong> 的报文，告知发送端主机。</p><blockquote><p>原点抑制消息（ICMP Source Quench Message） —— 类型 <code>4</code></p></blockquote><p>在使用低速广域线路的情况下，连接 WAN 的路由器可能会遇到网络拥堵的问题。</p><p><code>ICMP</code> 原点抑制消息的目的就是<strong>为了缓和这种拥堵情况</strong>。</p><p>当路由器向低速线路发送数据时，其发送队列的缓存变为零而无法发送出去时，可以向 IP 包的源地址发送一个 ICMP <strong>原点抑制消息</strong>。</p><p>收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况，从而增大 IP 包的传输间隔，减少网络拥堵的情况。</p><p>然而，由于这种 ICMP 可能会引起不公平的网络通信，一般不被使用。</p><blockquote><p>重定向消息（ICMP Redirect Message） —— 类型 <code>5</code></p></blockquote><p>如果路由器发现发送端主机使用了「不是最优」的路径发送数据，那么它会返回一个 ICMP <strong>重定向消息</strong>给这个主机。</p><p>在这个消息中包含了<strong>最合适的路由信息和源数据</strong>。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息告知发送端，让它下次发给另外一个路由器。</p><p>好比，小林本可以过条马路就能到的地方，但小林不知道，所以绕了一圈才到，后面小林知道后，下次小林就不会那么<strong>傻</strong>再绕一圈了。</p><blockquote><p>超时消息（ICMP Time Exceeded Message） —— 类型 <code>11</code></p></blockquote><p>IP 包中有一个字段叫做 <code>TTL</code> （<code>Time To Live</code>，生存周期），它的<strong>值随着每经过一次路由器就会减 1，直到减到 0 时该 IP 包会被丢弃。</strong></p><p>此时，路由器将会发送一个 ICMP <strong>超时消息</strong>给发送端主机，并通知该包已被丢弃。</p><p>设置 IP 包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免 IP 包无休止地在网络上被转发。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/11.jpg" title="ICMP 时间超过消息">ICMP 时间超过消息</p><p>此外，有时可以用 TTL 控制包的到达范围，例如设置一个<strong>较小的 TTL 值</strong>。</p><hr><h3 id="ping-——-查询报文类型的使用"><a href="#ping-——-查询报文类型的使用" class="headerlink" title="ping —— 查询报文类型的使用"></a>ping —— 查询报文类型的使用</h3><p>接下来，我们重点来看 <code>ping</code> 的<strong>发送和接收过程</strong>。</p><p>同个子网下的主机 A 和 主机 B，主机 A 执行<code>ping</code> 主机 B 后，我们来看看其间发送了什么？</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/12.jpg" title="主机 A ping 主机 B">主机 A ping 主机 B</p><p>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包。</p><p>ICMP 数据包内包含多个字段，最重要的是两个：</p><ul><li>  第一个是<strong>类型</strong>，对于回送请求消息而言该字段为 <code>8</code>；</li><li>  另外一个是<strong>序号</strong>，主要用于区分连续 ping 的时候发出的多个数据包。</li></ul><p>每发出一个请求数据包，序号会自动加 <code>1</code>。为了能够计算往返时间 <code>RTT</code>，它会在报文的数据部分插入发送时间。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/13.jpg" title="主机 A 的 ICMP 回送请求报文">主机 A 的 ICMP 回送请求报文</p><p>然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为<strong>目的地址</strong>，本机 IP 地址作为<strong>源地址</strong>，<strong>协议</strong>字段设置为 <code>1</code> 表示是 <code>ICMP</code> 协议，再加上一些其他控制信息，构建一个 <code>IP</code> 数据包。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/14.jpg" title="主机 A 的 IP 层数据包">主机 A 的 IP 层数据包</p><p>接下来，需要加入 <code>MAC</code> 头。如果在本地 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 <code>ARP</code> 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/15.jpg" title="主机 A 的 MAC 层数据包">主机 A 的 MAC 层数据包</p><p>主机 <code>B</code> 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。</p><p>接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p><p>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去给主机 A。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/16.jpg" title="主机 B 的 ICMP 回送响应报文">主机 B 的 ICMP 回送响应报文</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</p><p>此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p>针对上面发送的事情，总结成了如下图：</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/17.png" title="主机 A ping 主机 B 期间发送的事情">主机 A ping 主机 B 期间发送的事情</p><p>当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。</p><p>但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据目标 IP 地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址。</p><p>说了这么多，可以看出 ping 这个程序是<strong>使用了 ICMP 里面的 ECHO REQUEST（类型为 8 ） 和 ECHO REPLY （类型为 0）</strong>。</p><h3 id="traceroute-——-差错报文类型的使用"><a href="#traceroute-——-差错报文类型的使用" class="headerlink" title="traceroute —— 差错报文类型的使用"></a>traceroute —— 差错报文类型的使用</h3><p>有一款充分利用 ICMP <strong>差错报文类型</strong>的应用叫做 <code>traceroute</code>（在UNIX、MacOS中是这个命令，而在Windows中对等的命令叫做 tracert ）。</p><p><em>1. traceroute 作用一</em></p><p>traceroute 的第一个作用就是<strong>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</strong></p><p>traceroute 的参数指向某个<strong>目的 IP 地址</strong>：</p><pre><code>traceroute 192.168.1.100</code></pre><blockquote><p>这个作用是如何工作的呢？</p></blockquote><p>它的原理就是利用 IP 包的<strong>生存期限</strong> 从 <code>1</code> 开始按照顺序递增的同时发送 <strong>UDP 包</strong>，强制接收 <strong>ICMP 超时消息</strong>的一种方法。</p><p>比如，将 TTL 设置 为 <code>1</code>，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是<strong>时间超时</strong>。</p><p>接下来将 TTL 设置为 <code>2</code>，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。</p><p>这样的过程，traceroute 就可以拿到了所有的路由器 IP。</p><p>当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。</p><blockquote><p>发送方如何知道发出的 UDP 包是否到达了目的主机呢？</p></blockquote><p>traceroute 在发送 <code>UDP</code> 包时，会填入一个<strong>不可能的端口号</strong>值作为 UDP 目标端口号（大于 <code>3000</code> ）。当目的主机，收到 UDP 包后，会返回 ICMP 差错报文消息，但这个差错报文消息的类型是「<strong>端口不可达</strong>」。</p><p>所以，<strong>当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。</strong></p><p><em>2. traceroute 作用二</em></p><p>traceroute 还有一个作用是<strong>故意设置不分片，从而确定路径的 MTU</strong>。</p><blockquote><p>这么做是为了什么？</p></blockquote><p>这样做的目的是为了<strong>路径MTU发现</strong>。</p><p>因为有的时候我们并不知道路由器的 <code>MTU</code> 大小，以太网的数据链路上的 <code>MTU</code> 通常是 <code>1500</code> 字节，但是非以外网的 <code>MTU</code> 值就不一样了，所以我们要知道 <code>MTU</code> 的大小，从而控制发送的包大小。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/18.jpg" title="MTU 路径发现（UDP的情况下）">MTU 路径发现（UDP的情况下）</p><p>它的工作原理如下：</p><p>首先在发送端主机发送 <code>IP</code> 数据报时，将 <code>IP</code> 包首部的<strong>分片禁止标志位设置为 1</strong>。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。</p><p>随后，通过一个 ICMP 的不可达消息将<strong>数据链路上 MTU 的值</strong>一起给发送主机，不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」。</p><p>发送主机端每次收到 ICMP 差错报文时就<strong>减少</strong>包的大小，以此来定位一个合适的 <code>MTU</code> 值，以便能到达目标主机。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ping-的工作原理&quot;&gt;&lt;a href=&quot;#ping-的工作原理&quot; class=&quot;headerlink&quot; title=&quot;ping 的工作原理&quot;&gt;&lt;/a&gt;ping 的工作原理&lt;/h1&gt;&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP/IP" scheme="https://leslieaibin.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leslieaibin.github.io/2022/02/13/MySQL/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <id>https://leslieaibin.github.io/2022/02/13/MySQL/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</id>
    <published>2022-02-13T03:07:36.272Z</published>
    <updated>2022-07-19T15:22:50.043Z</updated>
    
    <content type="html"><![CDATA[<p>(129条消息) 深入理解 MySQL ….md</p><h1 id="数据库优化和查询优化方案"><a href="#数据库优化和查询优化方案" class="headerlink" title="数据库优化和查询优化方案"></a>数据库优化和查询优化方案</h1><h3 id="数据库优化方案"><a href="#数据库优化方案" class="headerlink" title="数据库优化方案"></a>数据库优化方案</h3><ol><li> 优化索引，sql语句，分析慢查询</li><li> 设计表的时候严格按照数据库设计规范来设计数据库</li><li> 使用缓存，把经常访问并且不需要经常变化的数据放在缓存中，能够节约磁盘IO</li><li> 优化硬件，采用ssd，使用磁盘队列技术（RAID0， RAID1，RAID5）</li><li> 采用mysql自带的表分区技术，把数据分析分成不同文件，能够磁盘的读写效率</li><li> 垂直分表，把一些不经常读的数据放在一张表当中，节约磁盘IO</li><li> 主从分离读写，采用主从复制把数据库的读操作和写操作分离开来</li><li> 分库分表分机器，数据量特别大的时候，主要的原理是数据路由</li><li> 选择合适的表引擎，参数上的优化</li><li> 进行架构级别的缓存，静态化和分布式</li><li> 不采用全文检索</li><li> 采用更快的存储方恨少，例如nosql存储经常访问的数据</li></ol><h3 id="优化数据库的查询效率"><a href="#优化数据库的查询效率" class="headerlink" title="优化数据库的查询效率"></a>优化数据库的查询效率</h3><ol><li> 存储引擎的选择，如果数据表需要事务处理，应该考虑Innodb，因为它完全符合ACID的特性，如果不需要食物处理，使用默认存储引擎MyISAM是比较明智的</li><li> 分表分库主从</li><li> 对查询进行优化，要尽量避免全表扫描，首先应考虑在shere以及orderby涉及的列上建立索引</li><li> 应尽量避免在where子句当中使用，不等于或者大于小于操作符，否则将导致引擎放弃使用索引而进行全表扫描</li><li> 应尽量避免在where子句当中使用null值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li> 应尽量避免在where子句当中使用or的判断，如果一个字段有索引，一个字段没有索引，将会导致引擎放弃使用索引而进行全表扫描</li><li> update语句如果只改一两个字段，不要update全部字段，否则频繁调用，会引起明显的性能消耗，同时带来的大量的日志</li><li> 对于多张数据量的表进行join，要先分页在做join，否则逻辑读写高，性能差</li></ol><hr><p>详细的优化方案</p><ul><li><p>1）数据库设计方面：</p><ul><li><p>  a. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p></li><li><p>  b. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0</p></li><li><p>  c. 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p></li><li><p>  d. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p></li><li><p>  e. 应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引。</p></li><li><p>  f. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p></li><li><p>  g. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p></li><li><p>  h. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p></li><li><p>  i. 避免频繁创建和删除临时表，以减少系统表资源的消耗。</p></li><li><p>  j. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p></li><li><p>  k. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p></li><li><p>  l. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p></li></ul></li></ul><ul><li><p>2)SQL语句方面：</p><ul><li><p>  a. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p></li><li><p>  b. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p></li></ul></li></ul><p><code>select id from t where num=10 or num=20</code></p><p>可以这样查询：</p><p><code>select id from t where num=10 union all select id from t where num=20</code></p><pre><code>- c. in 和 not in 也要慎用，否则会导致全表扫描，如： </code></pre><p><code>select id from t where num in(1,2,3)</code></p><p>对于连续的数值，能用 between 就不要用 in 了：</p><p><code>select id from t where num between 1 and 3</code></p><pre><code>- d. 下面的查询也将导致全表扫描： </code></pre><p><code>select id from t where name like ‘%abc%’</code></p><pre><code>- e. 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。</code></pre><p>然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><p><code>select id from t where num=@num</code></p><p>可以改为强制查询使用索引：</p><p><code>select id from t with(index(索引名)) where num=@num</code></p><pre><code>- f. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： </code></pre><p><code>select id from t where num/2=100</code></p><p>应改为:</p><p><code>select id from t where num=100*2</code></p><pre><code>- g. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： </code></pre><p><code>select id from t where substring(name,1,3)=’abc’</code></p><p>–name以abc开头的id</p><p><code>select id from t where datediff(day,createdate,’2005-11-30′)=0</code></p><p>–‘2005-11-30’生成的id</p><p>应改为:</p><p><code>select id from t where name like ‘abc%’ select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′</code></p><pre><code>- h. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。- i. 不要写一些没有意义的查询，如需要生成一个空表结构： </code></pre><p><code>select col1,col2 into #t from t where 1=0</code></p><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p><p>create table #t(…)</p><pre><code>- j. 很多时候用 exists 代替 in 是一个好的选择： </code></pre><p><code>select num from a where num in(select num from b)</code></p><p>用下面的语句替换：</p><p><code>select num from a where exists(select 1 from b where num=a.num)</code></p><pre><code>- k. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。- l. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。- m. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。- n. 尽量避免大事务操作，提高系统并发能力。</code></pre><ul><li><p>3)java方面：重点内容</p><ul><li><p>  a.尽可能的少造对象。</p></li><li><p>  b.合理摆正系统设计的位置。大量数据操作，和少量数据操作一定是分开的。大量的数据操作，肯定不是ORM框架搞定的。，</p></li><li><p>  c.使用jDBC链接数据库操作数据</p></li><li><p>  d.控制好内存，让数据流起来，而不是全部读到内存再处理，而是边读取边处理；</p></li><li><p>  e.合理利用内存，有的数据要缓存</p></li></ul></li></ul><p>如何优化数据库，如何提高数据库的性能?</p><p>1） 硬件调整性能 </p><p>最有可能影响性能的是磁盘和网络吞吐量,解决办法扩大虚拟内存，并保证有足够可以扩充的空间；把数据库服务器上的不必要服务关闭掉；把数据库服务器和主域服务器分开；把SQL数据库服务器的吞吐量调为最大；在具有一个以上处理器的机器上运行SQL。</p><p>2）调整数据库</p><p>若对该表的查询频率比较高，则建立索引；建立索引时，想尽对该表的所有查询搜索操作， 按照where选择条件建立索引，尽量为整型键建立为有且只有一个簇集索引，数据在物理上按顺序在数据页上，缩短查找范围，为在查询经常使用的全部列建立非簇集索引，能最大地覆盖查询；但是索引不可太多，执行UPDATE DELETE INSERT语句需要用于维护这些索引的开销量急剧增加；避免在索引中有太多的索引键；避免使用大型数据类型的列为索引；保证每个索引键值有少数行。</p><p>3）使用存储过程</p><p>应用程序的实现过程中，能够采用存储过程实现的对数据库的操作尽量通过存储过程来实现，因为存储过程是存放在数据库服务器上的一次性被设计、编码、测试，并被再次使用，需要执行该任务的应用可以简单地执行存储过程，并且只返回结果集或者数值，这样不仅可以使程序模块化，同时提高响应速度，减少网络流量，并且通过输入参数接受输入，使得在应用中完成逻辑的一致性实现。</p><p>4）应用程序结构和算法</p><p>建立查询条件索引仅仅是提高速度的前提条件，响应速度的提高还依赖于对索引的使用。因为人们在使用SQL时往往会陷入一个误区，即太关注于所得的结果是否正确，特别是对数据量不是特别大的数据库操作时，是否建立索引和使用索引的好坏对程序的响应速度并不大，因此程序员在书写程序时就忽略了不同的实现方法之间可能存在的性能差异，这种性能差异在数据量特别大时或者大型的或是复杂的数据库环境中（如联机事务处理OLTP或决策支持系统DSS）中表现得尤为明显。在工作实践中发现，不良的SQL往往来自于不恰当的索引设计、不充份的连接条件和不可优化的where子句。在对它们进行适当的优化后，其运行速度有了明显地提高！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;(129条消息) 深入理解 MySQL ….md&lt;/p&gt;
&lt;h1 id=&quot;数据库优化和查询优化方案&quot;&gt;&lt;a href=&quot;#数据库优化和查询优化方案&quot; class=&quot;headerlink&quot; title=&quot;数据库优化和查询优化方案&quot;&gt;&lt;/a&gt;数据库优化和查询优化方案&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://leslieaibin.github.io/2021/12/23/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://leslieaibin.github.io/2021/12/23/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-12-22T16:15:42.000Z</published>
    <updated>2022-02-18T08:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p><p>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p>如何解决：将这些算法封装成一个一个的类，任意地替换。</p><p>关键代码：实现同一个接口。</p><p>应用实例： </p><ul><li><p>诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 </p></li><li><p>旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 </p></li><li><p>JAVA AWT 中的 LayoutManager。</p><p>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p></li></ul><p>使用场景： </p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </li><li>一个系统需要动态地在几种算法中选择一种。 </li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li></ul><p>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><p>实现：</p><p>首先创建一个接口用于运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运算接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有4个实现类分别是加减乘除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationDivision</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 / num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我需要一个类来封装这个接口以及具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());</span><br><span class="line">System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());</span><br><span class="line">System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());</span><br><span class="line">System.out.println(<span class="string">&quot;10 * 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationDivision());</span><br><span class="line">System.out.println(<span class="string">&quot;10 / 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><p>1、知道OO基础，并不足以让你设计出良好的））系统。</p><p>2、良好的OO设计必须具备可复用、可扩充、可维护三个特性。</p><p>3、模式可以让我们建造出具有良好OO设计质量的系统。</p><p>4、模式被认为是历经验证的OO设计经验。</p><p>5、模式不是代码，而是针对设计问题的通用解决方案。你可把它们应该到特定的应用中！</p><p>6、模式不是被发明、而是被发现。</p><p>7、大多数的模式和原则，都着眼于软件变化的主题。</p><p>8、大多数的模式都允许系统局部改变独立于其他部分。</p><p>9、我们常把系统中会变化的部分抽出来封装。</p><p>10、模式让开发人员之间有共享的语言，能够最大化沟通的价值。</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式定义了对象之间的一对多依赖，这样一来当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p><p>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p>何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p><p>如何解决：使用面向对象技术，可以将这种依赖关系弱化。</p><p>关键代码：在抽象类里有一个 ArrayList 存放观察者们。</p><p>应用实例： </p><ul><li><p>拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 </p></li><li><p>西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p><p>优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p><p>缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p></li></ul><p>使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p><p>注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p><p>实现：</p><p>首先创建观察者接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 观察者，所有的观察者都需要实现update方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzf</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer left,Integer right)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">   主题模式接口：</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 主题接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzf</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 用于注册观察者</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 删除观察者</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 当状态更新时这个方法会被调用通知所有观察者</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">      &#125;</span><br><span class="line">      主题实现类，里面存放了一个维护Observer(观察者)的列表：</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 主题的实现类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzf</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationData</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ArrayList&lt;Observer&gt; observersList=<span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">   <span class="keyword">private</span> Integer left;</span><br><span class="line">   <span class="keyword">private</span> Integer right;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   observersList.add(o);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   <span class="keyword">int</span> i=observersList.indexOf(o);</span><br><span class="line">   <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">   observersList.remove(i);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   <span class="keyword">for</span>(Observer o:observersList)</span><br><span class="line">   o.update(left, right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 当状态改变时调用notifyObserver，执行观察者方法</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Changed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      notifyObserver();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">(Integer left,Integer right)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.left=left;</span><br><span class="line">   <span class="keyword">this</span>.right=right;</span><br><span class="line">   Changed();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面实现三个Observer的实现类分别实现加减乘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 观察者实现类并将自身注册入Subject</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @author zzf </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @date 2018年10月17日 上午8:57:05 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer left;</span><br><span class="line">  <span class="keyword">private</span> Integer right;</span><br><span class="line">  <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AddDisplay</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subject=subject;</span><br><span class="line">  subject.registerObserver(<span class="keyword">this</span>);<span class="comment">//将自身注册入主题</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer left, Integer right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">this</span>.left=left;</span><br><span class="line">  <span class="keyword">this</span>.right=right;</span><br><span class="line">  display();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Add:&quot;</span>+(left+right));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @author zzf </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @date 2018年10月17日 上午9:04:19 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubstractDisplay</span>  <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer left;</span><br><span class="line">  <span class="keyword">private</span> Integer right;</span><br><span class="line">  <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubstractDisplay</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subject=subject;</span><br><span class="line">  subject.registerObserver(<span class="keyword">this</span>);<span class="comment">//将自身注册入主题</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer left, Integer right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">this</span>.left=left;</span><br><span class="line">  <span class="keyword">this</span>.right=right;</span><br><span class="line">  display();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Substract:&quot;</span>+(left-right));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *观察者的实现类（乘法）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @author zzf </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @date 2018年10月17日 上午9:11:32 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiplyDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer left;</span><br><span class="line">  <span class="keyword">private</span> Integer right;</span><br><span class="line">  <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MultiplyDisplay</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subject=subject;</span><br><span class="line">  subject.registerObserver(<span class="keyword">this</span>);<span class="comment">//将自身注册入主题</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer left, Integer right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">this</span>.left=left;</span><br><span class="line">  <span class="keyword">this</span>.right=right;</span><br><span class="line">  display();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Multiply:&quot;</span>+(left*right));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面创建一个测试类，将三个观察者的实现类注册入主题模式：</p><ul><li><pre><code class="java">/* * @author zzf * @date 2018年10月17日 上午9:05:48   */  public class Operation &#123;  public static void main(String[] args) &#123;      //创建主题      OperationData operationData=new OperationData();</code></pre></li></ul><pre><code>//将观察者的实现类注册入主题AddDisplay addDisplay=new AddDisplay(operationData);SubstractDisplay substractDisplay=new SubstractDisplay(operationData);MultiplyDisplay multiplyDisplay=new MultiplyDisplay(operationData);operationData.setChanged(5,5);operationData.setChanged(10, 3);&#125;&#125;</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.通过Java API里面的java.util包内自带的Observer接口和Observable类实现观察者模式（详细请阅读源码实现原理很简单）</span><br><span class="line"></span><br><span class="line">首先通过继承java.util.Observable来实现主题的实现类</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">import java.util.Observable;</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line"></span><br><span class="line">* @author zzf </span><br><span class="line"></span><br><span class="line">* @date 2018年10月17日 下午2:26:34 </span><br><span class="line">  *&#x2F;</span><br><span class="line">  public class OperationData extends Observable&#123;</span><br><span class="line"></span><br><span class="line">  private Integer left;</span><br><span class="line">  private Integer right;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line"></span><br><span class="line">   * 当状态改变时调用notifyObserver，执行观察者方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">     public void Changed() &#123;</span><br><span class="line">     setChanged();&#x2F;&#x2F;将changed设置为true</span><br><span class="line">     notifyObservers();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  public void setChanged(Integer left,Integer right) &#123;</span><br><span class="line">  this.left&#x3D;left;</span><br><span class="line">  this.right&#x3D;right;</span><br><span class="line">  Changed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Integer getLeft() &#123;</span><br><span class="line">  return left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setLeft(Integer left) &#123;</span><br><span class="line">  this.left &#x3D; left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Integer getRight() &#123;</span><br><span class="line">  return right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setRight(Integer right) &#123;</span><br><span class="line">  this.right &#x3D; right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过实现java.util.Observer来实现观察类：</p><pre><code>private Integer left;private Integer right;private Observable observable;public MultiplyDisplay(Observable observable) &#123;    this.observable=observable;    observable.addObserver(this);//将自身注册入主题&#125;@Overridepublic void update(Observable o, Object arg) &#123;    // TODO Auto-generated method stub    if(o instanceof OperationData) &#123;        OperationData operationData = (OperationData)o;        this.left=operationData.getLeft();        this.right=operationData.getRight();        display();    &#125;&#125;public void display() &#123;    System.out.println(&quot;Multiply:&quot;+(left*right));&#125;</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @author zzf </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @date 2018年10月17日 下午2:31:37 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer left;</span><br><span class="line">  <span class="keyword">private</span> Integer right;</span><br><span class="line">  <span class="keyword">private</span> Observable observable;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AddDisplay</span><span class="params">(Observable observable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.observable=observable;</span><br><span class="line">  observable.addObserver(<span class="keyword">this</span>);<span class="comment">//将自身注册入主题</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">if</span>(o <span class="keyword">instanceof</span> OperationData) &#123;</span><br><span class="line">  OperationData operationData = (OperationData)o;</span><br><span class="line">  <span class="keyword">this</span>.left=operationData.getLeft();</span><br><span class="line">  <span class="keyword">this</span>.right=operationData.getRight();</span><br><span class="line">  display();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Add:&quot;</span>+(left+right));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><p>1、观察者模式定义了对象之间一对多的关系。</p><p>2、主题（可观察者）用一个共同的接口来更新观察者。</p><p>3、观察者和可观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</p><p>4、使用哦此模式时，你可从被观察者处推或拉数据。</p><p>5、有多个观察者模式时，不可以依赖特定的通知次序。</p><p>6、要注意java.util.Observable实现上带来的一些问题（是一个类非接口，违反了针对接口编程）。</p><p>7、如果有必要，可以实现自己的Observable。</p><p>8、Swing中运用了大量观察者模式，许多GUI框架也是如此。</p><p>参考：<a href="https://www.w3cschool.cn/shejimoshi/strategy-pattern.html">https://www.w3cschool.cn/shejimoshi/strategy-pattern.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h1&gt;&lt;p&gt;策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。&lt;/p&gt;
&lt;p&gt;意图：定</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>海量数据处理</title>
    <link href="https://leslieaibin.github.io/2021/12/19/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2021/12/19/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2021-12-18T16:15:42.000Z</published>
    <updated>2022-02-13T08:08:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="海量数据处理的问题总结"><a href="#海量数据处理的问题总结" class="headerlink" title="海量数据处理的问题总结"></a>海量数据处理的问题总结</h1><p>所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。</p><p>解决办法呢？针对时间，需要采用巧妙的算法配合合适的数据结构，如<code>Bloom filter</code>/<code>Hash</code>/<code>bit-map</code>/<code>堆</code>/<code>数据库</code>或<code>倒排索引</code>/<code>trie</code>树。针对空间，大而化小，分而治之（<code>hash</code>映射可以做到）。</p><p>至于所谓的单机及集群问题，单机就是处理装载数据的机器有限(只要考虑CPU、内存、硬盘间的数据交互)。而集群，机器有多台，适合分布式处理、并行计算(更多考虑节点和节点间的数据交互)。</p><h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p><h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。</p><pre><code>5,000,000,000 * 64B ≈ 5GB * 64 = 320GB</code></pre><p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用分治策略，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p>思路如下：</p><p>首先遍历文件 a，对遍历到的 URL 求<code>hash(URL) % 1000</code>，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p><p>接着遍历<code>ai (i∈[0,999])</code>，把 URL 存储到一个<code>HashSet</code>集合中。然后遍历 bi 中每个 URL，看在<code>HashSet</code>集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p><p>方法总结</p><ul><li>  分而治之，进行哈希取余；</li><li>  对每个子文件进行<code>HashSet</code>统计。</li></ul><h1 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p><h2 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h2><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用分治策略，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p><p>思路如下：</p><p>首先遍历大文件，对遍历到的每个词x，执行<code>hash(x) % 5000</code>，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p><p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用<code>HashMap</code>来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 map.put(x, 1)；若存在，则执行<code>map.put(x, map.get(x) + 1)</code>，将该词频数加 1。</p><p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个小顶堆来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个小顶堆，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为小顶堆，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p><h2 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h2><ul><li>  分而治之，进行哈希取余；</li><li>  使用<code>HashMap</code>统计频数；</li><li>  求解最大的<code>TopN</code>个，用小顶堆；求解最小的<code>TopN</code>个，用大顶堆。</li></ul><h1 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。</p><h2 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h2><p>这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用<code>HashMap</code>统计重复 IP 的次数，最后计算出重复次数最多的 IP。</p><p>注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。</p><h2 id="方法总结-1"><a href="#方法总结-1" class="headerlink" title="方法总结"></a>方法总结</h2><ul><li>  分而治之，进行哈希取余；</li><li>  使用<code>HashMap</code>统计频数；</li><li>  求解最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。</li></ul><h1 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p><h2 id="解答思路-3"><a href="#解答思路-3" class="headerlink" title="解答思路"></a>解答思路</h2><h3 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h3><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用<code>HashSet</code>/<code>HashMap</code>找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p><h3 id="方法二：位图法"><a href="#方法二：位图法" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h3><p>位图，就是用一个或多个<code>bit</code>来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p><p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p><p>假设我们要对 [0,7] 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p><pre><code>0 0 0 0 0 0 0 0</code></pre><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p><pre><code>0 0 0 0 1 0 1 0</code></pre><p>依次遍历，结束后，位数组是这样的：</p><pre><code>0 1 1 0 1 1 1 0</code></pre><p>每个为 1 的位，它的下标都表示了一个数：</p><pre><code>for i in range(8):    if bits[i] == 1:        print(i)</code></pre><p>这样我们其实就已经实现了排序。</p><p>对于整数相关的算法的求解，位图法是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 2^32。</p><p>那么对于这道题，我们用 2 个 bit 来表示各个数字的状态：</p><ul><li>  00 表示这个数字没出现过；</li><li>  01 表示这个数字出现过一次（即为题目所找的不重复整数）；</li><li>  10 表示这个数字出现了多次。</li></ul><p>那么这 2^32 个整数，总共所需内存为 2^32*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p><p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p><h2 id="方法总结-2"><a href="#方法总结-2" class="headerlink" title="方法总结"></a>方法总结</h2><p>判断数字是否重复的问题，位图法是一种非常高效的方法。</p><h1 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 40 亿个不重复的没排过序的<code>unsigned int</code>型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？</p><h2 id="解答思路-4"><a href="#解答思路-4" class="headerlink" title="解答思路"></a>解答思路</h2><h3 id="方法一：分治法-1"><a href="#方法一：分治法-1" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h3><p>依然可以用分治法解决，方法与前面类似，就不再次赘述了。</p><h3 id="方法二：位图法-1"><a href="#方法二：位图法-1" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h3><p>40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b ≈ 512M。</p><p>我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。</p><h2 id="方法总结-3"><a href="#方法总结-3" class="headerlink" title="方法总结"></a>方法总结</h2><p>判断数字是否存在、判断数字是否重复的问题，位图法是一种非常高效的方法。</p><h1 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询床的长度不超过 255 字节。</p><p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p><h2 id="解答思路-5"><a href="#解答思路-5" class="headerlink" title="解答思路"></a>解答思路</h2><p>每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。</p><h3 id="方法一：分治法-2"><a href="#方法一：分治法-2" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h3><p>分治法依然是一个非常实用的方法。</p><p>划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。</p><p>方法可行，但不是最好，下面介绍其他方法。</p><h3 id="方法二：HashMap-法"><a href="#方法二：HashMap-法" class="headerlink" title="方法二：HashMap 法"></a>方法二：HashMap 法</h3><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个<code>HashMap</code>中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。</p><p>思路如下：</p><p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 O(N)。</p><p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p><p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 O(Nlog10)。</p><h3 id="方法三：前缀树法"><a href="#方法三：前缀树法" class="headerlink" title="方法三：前缀树法"></a>方法三：前缀树法</h3><p>方法二使用了<code>HashMap</code>来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p><p>思路如下：</p><p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p><p>最后依然使用小顶堆来对字符串的出现次数进行排序。</p><h2 id="方法总结-4"><a href="#方法总结-4" class="headerlink" title="方法总结"></a>方法总结</h2><p>前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。</p><h1 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。</p><h2 id="解答思路-6"><a href="#解答思路-6" class="headerlink" title="解答思路"></a>解答思路</h2><p>这道题本质还是求解数据重复的问题，对于这类问题，一般首先考虑位图法。</p><p>对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。</p><p>思路如下：</p><p>申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。</p><h2 id="方法总结-5"><a href="#方法总结-5" class="headerlink" title="方法总结"></a>方法总结</h2><p>求解数据重复问题，记得考虑位图法。</p><h1 id="题目8"><a href="#题目8" class="headerlink" title="题目8"></a>题目8</h1><p>题目描述 从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 (N+1)/2 个数；当样本数为偶数时，中位数为 第 N/2 个数与第 1+N/2 个数的均值。</p><h2 id="解答思路-7"><a href="#解答思路-7" class="headerlink" title="解答思路"></a>解答思路</h2><p>如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 O(NlogN)。这里使用其他方法。</p><h3 id="方法一：双堆法"><a href="#方法一：双堆法" class="headerlink" title="方法一：双堆法"></a>方法一：双堆法</h3><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。</p><p>若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。</p><p>以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法适用于数据量较小的情况。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。</p><h3 id="方法二：分治法"><a href="#方法二：分治法" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h3><p>分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。</p><p>对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。</p><p>划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。</p><p>提示，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。 对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。</p><p>注意，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。</p><h2 id="方法总结-6"><a href="#方法总结-6" class="headerlink" title="方法总结"></a>方法总结</h2><p>分治法，真香！</p><h1 id="题目9"><a href="#题目9" class="headerlink" title="题目9"></a>题目9</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。</p><h2 id="解答思路-8"><a href="#解答思路-8" class="headerlink" title="解答思路"></a>解答思路</h2><p>如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。</p><h3 id="方法一：HashMap法"><a href="#方法一：HashMap法" class="headerlink" title="方法一：HashMap法"></a>方法一：<code>HashMap</code>法</h3><p>如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的<code>HashMap</code>中。接着就可以按照 query 出现的次数进行排序。</p><h3 id="方法二：分治法-1"><a href="#方法二：分治法-1" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h3><p>分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 hash(query) % 10 把这些 query 划分到 10 个小文件中。之后对每个小文件使用<code>HashMap</code>统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。</p><p>接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。</p><h2 id="方法总结-7"><a href="#方法总结-7" class="headerlink" title="方法总结"></a>方法总结</h2><ul><li>  内存若够，直接读入进行排序；</li><li>  内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。</li></ul><h1 id="题目10"><a href="#题目10" class="headerlink" title="题目10"></a>题目10</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？</p><h2 id="解答思路-9"><a href="#解答思路-9" class="headerlink" title="解答思路"></a>解答思路</h2><p>对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：</p><p>首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。</p><p>接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。</p><p>重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。</p><p>为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。</p><h2 id="方法总结-8"><a href="#方法总结-8" class="headerlink" title="方法总结"></a>方法总结</h2><p>求 TopK，不妨考虑一下堆排序？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;海量数据处理的问题总结&quot;&gt;&lt;a href=&quot;#海量数据处理的问题总结&quot; class=&quot;headerlink&quot; title=&quot;海量数据处理的问题总结&quot;&gt;&lt;/a&gt;海量数据处理的问题总结&lt;/h1&gt;&lt;p&gt;所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>面试杂谈2</title>
    <link href="https://leslieaibin.github.io/2021/12/19/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E6%9D%82%E8%B0%882/"/>
    <id>https://leslieaibin.github.io/2021/12/19/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95%E6%9D%82%E8%B0%882/</id>
    <published>2021-12-18T16:15:42.000Z</published>
    <updated>2022-07-18T15:41:29.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经1"><a href="#面经1" class="headerlink" title="面经1"></a>面经1</h1><h2 id="1-JVM内存分区"><a href="#1-JVM内存分区" class="headerlink" title="1.JVM内存分区"></a>1.JVM内存分区</h2><p><a href="https://leslieaibin.github.io/2020/11/10/JVM/1.Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B/">https://leslieaibin.github.io/2020/11/10/JVM/1.Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B/</a></p><h2 id="2-对象加载在哪里，一定不能在栈上吗，为什么不直接在栈上。"><a href="#2-对象加载在哪里，一定不能在栈上吗，为什么不直接在栈上。" class="headerlink" title="2.对象加载在哪里，一定不能在栈上吗，为什么不直接在栈上。"></a>2.对象加载在哪里，一定不能在栈上吗，为什么不直接在栈上。</h2><p>1、功能和作用：</p><p>（1）栈，可以看成是方法的运行模型，所有方法的调用都是通过栈帧来进行的，JVM会为每个线程都分配一个栈区，JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作。当线程进入一个Java方法函数的时候，就会在当前线程的栈里压入一个栈帧，用于保存当前线程的状态（参数、局部变量、中间计算过程和其他数据），当退出函数方法时，修改栈指针就可以把栈中的内容销毁。</p><p>（2）堆，唯一的目的就是用于存放对象实例，每个Java应用都唯一对应一个JVM实例，每个JVM实例都唯一对应一个堆，并由堆内存被应用所有的线程共享。</p><p>所以，从功能和作用来通俗的比较，堆主要用来存放对象的，栈主要是用来执行程序的。</p><p>2、性能与存储要求：</p><p>（1）栈的性能比堆要快，仅次于位于CPU中的寄存器。但是，在分配内存的时候，存放在栈中的数据大小与生存周期必须在编译时是确定的，缺乏灵活性。</p><p>（2）堆可以动态分配内存大小，编译器不必知道要从堆里分配多少存储空间，生存周期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据，因此可以得到更大的灵活性。但是，由于要在运行时动态分配内存和销毁对象时都需要占用时间，所以效率低。由于面向对象的多态性，堆内存分配是必不可少的，因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定。当然，为达到这种灵活性，必然会付出一定的代价。</p><p>不一定，随着JIT编译器的发展，在编译期间，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。就像我们前面看到的一样，在开启逃逸分析之后，也并不是所有User对象都没有在堆上分配。</p><ul><li><p>heap是堆，stack是栈。</p></li><li><p>stack的空间由操作系统自动分配和释放，heap的空间是手动申请和释放的，heap常用new关键字来分配。</p></li><li><p>stack空间有限，heap的空间是很大的自由区。在Java中，若只是声明一个对象，则先在栈内存中为其分配地址空间，若再new一下，实例化它，则在堆内存中为其分配地址。</p></li><li><p>举例：数据类型 变量名；这样定义的东西在栈区。如：Object a =null; 只在栈内存中分配空间new 数据类型();或者malloc(长度); 这样定义的东西就在堆区如：<code>Object b =new Object();</code> 则在堆内存中分配空间</p></li></ul><h2 id="3-线程池构造参数"><a href="#3-线程池构造参数" class="headerlink" title="3.线程池构造参数"></a>3.线程池构造参数</h2><p><a href="https://leslieaibin.github.io/2021/04/29/Thread/5.%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/">https://leslieaibin.github.io/2021/04/29/Thread/5.%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor&#123;</span><br><span class="line">    <span class="keyword">int</span> corePoolSize, <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">int</span> maximumPoolSize, <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="keyword">long</span> keepAliveTime, <span class="comment">// 空闲线程的存活时间</span></span><br><span class="line">    TimeUnit unit, <span class="comment">// keepAliveTime的时间单位</span></span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 阻塞队列</span></span><br><span class="line">    ThreadFactory threadFactory, <span class="comment">// 线程工厂，用于创建线程</span></span><br><span class="line">    RejectedExecutionHandler handler); <span class="comment">// 饱和策略</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16417a1fd6acc8f4" alt="线程方法状态转换"></p><h2 id="4-自旋锁，读写锁，公平锁，可重入锁。"><a href="#4-自旋锁，读写锁，公平锁，可重入锁。" class="headerlink" title="4.自旋锁，读写锁，公平锁，可重入锁。"></a>4.自旋锁，读写锁，公平锁，可重入锁。</h2><p><a href="https://leslieaibin.github.io/2021/05/03/Thread/6.java%E4%B8%AD%E7%9A%84%E9%94%81/">https://leslieaibin.github.io/2021/05/03/Thread/6.java%E4%B8%AD%E7%9A%84%E9%94%81/</a></p><h2 id="5-进程，线程通信方式"><a href="#5-进程，线程通信方式" class="headerlink" title="5.进程，线程通信方式"></a>5.进程，线程通信方式</h2><p><a href="https://leslieaibin.github.io/2022/07/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">https://leslieaibin.github.io/2022/07/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</a></p><h2 id="6-tcp-timewait，服务器很多timewait怎么办"><a href="#6-tcp-timewait，服务器很多timewait怎么办" class="headerlink" title="6.tcp timewait，服务器很多timewait怎么办"></a>6.tcp timewait，服务器很多timewait怎么办</h2><p><a href="https://leslieaibin.github.io/2021/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">https://leslieaibin.github.io/2021/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</a></p><h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><p>　　表示客户端主动关闭socket。</p><p>　　<strong>原因：</strong></p><ul><li>大量的短连接存在</li><li>特别是 HTTP 请求中，如果 connection 头部取值被设置为 close 时，基本都由服务端发起主动关闭连接</li><li>TCP 四次挥手关闭连接机制中，为了保证 ACK 重发和丢弃延迟数据，设置 time_wait 为 2 倍的 MSL(报文最大存活时间)</li></ul><p>　　<strong>后果：</strong>　　</p><ul><li>TCP 连接中，「主动发起关闭连接」的一端，会进入 time_wait 状态</li><li>time_wait 状态，默认会持续 2 MSL(报文的最大生存时间)，一般是 2x2 mins</li><li>time_wait 状态下，TCP 连接占用的端口，无法被再次使用；TCP 端口数量，上限是 6.5w(65535，16 bit)</li><li>大量 time_wait 状态存在，会导致新建 TCP 连接会出错，address already in use : connect 异常</li><li>占用内存，但内存占用并不大，1万条TIME_WAIT的连接，也就多消耗1M</li><li>耗CPU，每次找到一个随机端口，需要遍历一遍bound ports的吧，这必然需要一些CPU时间，但也还好，无需太担忧</li></ul><p>　　解决：</p><ul><li>服务器端允许 time_wait 状态的 socket 被重用</li><li>缩减 time_wait 时间，设置为 1 MSL</li><li>修改内核参数：<ul><li>net.ipv4.tcp_tw_recycle = 1</li><li>net.ipv4.tcp_tw_reuse = 1</li><li>net.ipv4.tcp_timestamps = 1</li><li><a href="https://zhuanlan.zhihu.com/p/40013724">https://zhuanlan.zhihu.com/p/40013724</a></li></ul></li></ul><h4 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h4><p>　　表示服务端被动关闭socket。</p><p>　　根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。</p><p>　　原因：应用程序写的有问题，没有合适的关闭socket；要么是服务器CPU处理不过来（CPU太忙）或者应用程序一直睡眠到其它地方(锁，或者文件I/O等等)，应用程序获得不到合适的调度时间，造成程序没法真正的执行close操作。</p><p>　　后果：出现大量的CLOSE_WAIT后，服务无法继续正常服务，端口无法被复用，socket资源被耗尽。因为Linux分配给一个用户的文件句柄是有限的，而如果一直被保持，则文件句柄也就不能close，导致句柄资源达到上线，接着就会出现大量Too Many Open Files错误。</p><h2 id="7-MySQL联合索引，怎么保证一定走索引，幻读"><a href="#7-MySQL联合索引，怎么保证一定走索引，幻读" class="headerlink" title="7.MySQL联合索引，怎么保证一定走索引，幻读"></a>7.MySQL联合索引，怎么保证一定走索引，幻读</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(1)    <span class="keyword">select</span> * <span class="keyword">from</span> myTest  <span class="keyword">where</span> a=<span class="number">3</span> <span class="keyword">and</span> b=<span class="number">5</span> <span class="keyword">and</span> c=<span class="number">4</span>;   <span class="comment">----  abc顺序</span></span><br><span class="line">abc三个索引都在where条件里面用到了，而且都发挥了作用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(2)    <span class="keyword">select</span> * <span class="keyword">from</span> myTest  <span class="keyword">where</span>  c=<span class="number">4</span> <span class="keyword">and</span> b=<span class="number">6</span> <span class="keyword">and</span> a=<span class="number">3</span>;</span><br><span class="line">where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(3)    <span class="keyword">select</span> * <span class="keyword">from</span> myTest  <span class="keyword">where</span> a=<span class="number">3</span> <span class="keyword">and</span> c=<span class="number">7</span>;</span><br><span class="line">a用到索引，b没有用，所以c是没有用到索引效果的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(4)    <span class="keyword">select</span> * <span class="keyword">from</span> myTest  <span class="keyword">where</span> a=<span class="number">3</span> <span class="keyword">and</span> b&gt;<span class="number">7</span> <span class="keyword">and</span> c=<span class="number">3</span>;     <span class="comment">---- b范围值，断点，阻塞了c的索引</span></span><br><span class="line">a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(5)    <span class="keyword">select</span> * <span class="keyword">from</span> myTest  <span class="keyword">where</span> b=<span class="number">3</span> <span class="keyword">and</span> c=<span class="number">4</span>;   <span class="comment">--- 联合索引必须按照顺序使用，并且需要全部使用</span></span><br><span class="line">因为a索引没有使用，所以这里 bc都没有用上索引效果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(6)    <span class="keyword">select</span> * <span class="keyword">from</span> myTest  <span class="keyword">where</span> a&gt;<span class="number">4</span> <span class="keyword">and</span> b=<span class="number">7</span> <span class="keyword">and</span> c=<span class="number">9</span>;</span><br><span class="line">a用到了  b没有使用，c没有使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(7)    <span class="keyword">select</span> * <span class="keyword">from</span> myTest  <span class="keyword">where</span> a=<span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> b;</span><br><span class="line">a用到了索引，b在结果排序中也用到了索引的效果，a下面任意一段的b是排好序的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(8)    <span class="keyword">select</span> * <span class="keyword">from</span> myTest  <span class="keyword">where</span> a=<span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> c;</span><br><span class="line">a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了，使用 <span class="keyword">explain</span> 可以看到 filesort</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">9</span>)    <span class="keyword">select</span> * <span class="keyword">from</span> mytable <span class="keyword">where</span> b=<span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> a;</span><br><span class="line">b没有用到索引，排序中a也没有发挥索引效果</span><br><span class="line"></span><br><span class="line">2.索引失效的条件</span><br><span class="line">不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</span><br><span class="line">存储引擎不能使用索引范围条件右边的列</span><br><span class="line">尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少<span class="keyword">select</span> *</span><br><span class="line">mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</span><br><span class="line"></span><br><span class="line"><span class="keyword">is</span> <span class="literal">null</span>,<span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>也无法使用索引   <span class="comment">----  此处存在疑问，经测试确实可以使用，ref和const等级，并不是all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">like</span>以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。问题：解决<span class="keyword">like</span>‘%字符串%’时索引不被使用的方法？</span><br></pre></td></tr></table></figure><h2 id="8-怎么杀死一个进程"><a href="#8-怎么杀死一个进程" class="headerlink" title="8.怎么杀死一个进程"></a>8.怎么杀死一个进程</h2><p><a href="https://blog.csdn.net/lechengyuyuan/article/details/16337233">https://blog.csdn.net/lechengyuyuan/article/details/16337233</a></p><h2 id="9-为什么说B-树比B树更适合数据库索引？"><a href="#9-为什么说B-树比B树更适合数据库索引？" class="headerlink" title="9.为什么说B+树比B树更适合数据库索引？"></a>9.为什么说B+树比B树更适合数据库索引？</h2><ul><li>二叉查找树(BST):解决了排序的基本问题,但是由于无法保证平衡,可能退化为链表</li><li>平衡二叉树(AVⅥL):通过旋转解决了平衡的问题,但是旋转操作效率太低</li><li>红黑树:通过舍弃严格的平衡和引入红黑节点,解决了AⅥ旋转效率过低的问题,但是在磁盘等场景下,树仍然太高,IO次数太多</li><li>B树:通过将二叉树改为多路平衡查找树,解决了树过高的问题</li><li>B+树:在B树的基础上,将非叶节点改造为不存储数据的纯索引节点,进一步降低了树的高度;此外将叶节点使用指针连接成链表,范围查询更加高效。</li></ul><p>1、 <strong>B+树的磁盘读写代价更低</strong>：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p><p>2、<strong>B+树的查询效率更加稳定</strong>：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><p>3、<strong>方便范围查询，</strong>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p><h2 id="10-单例模式"><a href="#10-单例模式" class="headerlink" title="10.单例模式"></a>10.单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这种实现最大的问题就是不支持多线程</span></span><br></pre></td></tr></table></figure><p><strong>懒汉式，线程安全</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">必须加锁 <span class="keyword">synchronized</span> 才能保证单例，但加锁会影响效率。</span><br></pre></td></tr></table></figure><p><strong>饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">这种方式比较常用，但容易产生垃圾对象。</span><br></pre></td></tr></table></figure><p><strong>双检查</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</span><br></pre></td></tr></table></figure><h2 id="11-MySql-和redis的区别"><a href="#11-MySql-和redis的区别" class="headerlink" title="11.MySql 和redis的区别"></a>11.MySql 和redis的区别</h2><p><strong>Redis 和 Mysql 的区别:</strong></p><p>​    Mysql 是关系型数据库, 持久化存储, 存放在磁盘里, 功能强大. 检索的话, 会涉及到一定 IO , 数据访问也就慢;<br>​    Redis 是内存数据库,也是<a href="https://so.csdn.net/so/search?q=%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">非关系型数据库</a> 数据保存在内存中, 速度快;</p><p>Redis 的优点:</p><pre><code>读写性能优异支持数据持久化, 支持 AOF 和 RDB 两种持久化方式支持主从复制, 主机会自动将数据同步到从机, 可以进行读写分离.数据结构丰富 : 除了支持 string 类型的value 外还支持string, hash, set, stortset, list 等数据结构.</code></pre><h2 id="12-反射"><a href="#12-反射" class="headerlink" title="12.反射"></a>12.反射</h2><p>反射就是在运行的时候知道自己是什么类，并能直接操作程序的内部属性和方法。</p><ul><li><p>如何反射获取 Class 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.通过字符串获取Class对象，这个字符串必须带上完整路径名</span></span><br><span class="line">Class studentClass = Class.forName(<span class="string">&quot;com.test.reflection.Student&quot;</span>);</span><br><span class="line"><span class="comment">// 2.通过类的class属性</span></span><br><span class="line">Class studentClass2 = Student.class;</span><br><span class="line"><span class="comment">// 3.通过对象的getClass()函数</span></span><br><span class="line">Student studentObject = <span class="keyword">new</span> Student();</span><br><span class="line">Class studentClass3 = studentObject.getClass();</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>如何反射获取类中的所有字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取所有声明的字段</span></span><br><span class="line">Field[] declaredFieldList = studentClass.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field declaredField : declaredFieldList) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;declared Field: &quot;</span> + declaredField);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.获取所有公有的字段</span></span><br><span class="line">Field[] fieldList = studentClass.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fieldList) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;field: &quot;</span> + field);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>如何反射获取类中的所有构造方法</p></li><li><p>如何反射获取类中的所有非构造方法</p></li></ul><h3 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h3><p>一个代理类只能实现一种抽象主题角色，在程序运行之前，代理类.class文件就已经被创建，代理类和委托类的关系在运行前就确定。</p><h3 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h3><p>一个代理类通过反射机制，可以实现多种不类型的抽象主题角色。动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。以下为动态代理概括图</p><h2 id="13-Spring框架"><a href="#13-Spring框架" class="headerlink" title="13.Spring框架"></a>13.Spring框架</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>​    <strong>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/261421378318292.jpg" alt="img"></p><p>​    <strong>即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</strong></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p><p>　　●<strong>谁依赖于谁：</strong>当然是<strong>应用程序依赖于IoC容器</strong>；</p><p>　　●<strong>为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源</strong>；</p><p>　　●<strong>谁注入谁：</strong>很明显是<strong>IoC容器注入应用程序某个对象，应用程序依赖的对象</strong>；</p><p>　　<strong>●注入了什么：</strong>就是<strong>注入某个对象所需要的外部资源（包括对象、资源、常量数据）</strong>。</p><p>动态代理</p><p>一起看看，动态代理到底是解决什么问题？</p><p>首先，它是一个<strong>代理机制</strong>。如果熟悉设计模式中的代理模式，我们会知道，代理可以看做是对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是通过代理完成。</p><p>JDK Proxy的优势：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK本身的支持，可能比cglib更加可靠。</li><li>平滑进行JDK版本升级，而字节码类库通常需要进行更新以保证在新版Java上能够使用。</li><li>代码实现简单。</li></ul><p>基于类似cglib框架的优势：</p><ul><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的时间，类似cglib动态代理就没有这种限制。</li><li>只操作我们关心的类，而不必为其它相关类增加工作量。</li><li>高性能。</li></ul><h2 id="14-接口与抽象类的区别"><a href="#14-接口与抽象类的区别" class="headerlink" title="14.接口与抽象类的区别"></a>14.接口与抽象类的区别</h2><p><strong>抽象类</strong>：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点：</p><p>a、抽象类不能被实例化只能被继承；</p><p>b、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；</p><p>c、抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；</p><p>d、一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；</p><p>e、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。</p><p><strong><em>接口\</em>：</strong>Java中接口使用interface关键字修饰，特点为:</p><p>a、接口可以包含变量、方法；变量被隐士指定为public static final，方法被隐士指定为public abstract（JDK1.8之前）；</p><p>b、接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</p><p>c、一个类可以实现多个接口；</p><p><strong>相同点</strong></p><p>（1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p><p><strong>不同点</strong></p><p>（1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</p><p>（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</p><p>（3）接口强调特定功能的实现，而抽象类强调所属关系。</p><p>（4）接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</p><h2 id="15-threadlocl"><a href="#15-threadlocl" class="headerlink" title="15.threadlocl"></a>15.threadlocl</h2><p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。</p><p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p><p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p><p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构。</p><p>我们还要注意<code>Entry</code>， 它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code> ，继承自<code>WeakReference</code>， 也就是我们常说的弱引用类型。</p><h2 id="16-重载重写"><a href="#16-重载重写" class="headerlink" title="16.重载重写"></a>16.重载重写</h2><h4 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a><strong>重写(Override)</strong></h4><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p><p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p><p><strong>重写规则：</strong></p><ul><li>参数列表与被重写方法的参数列表必须完全相同。</li><li>声明为 final 的方法不能被重写。 </li><li>声明为 static 的方法不能被重写，但是能够被再次声明。 </li><li>如果不能继承一个类，则不能重写该类的方法。        </li></ul><h4 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h4><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>最常用的地方就是构造器的重载。</p><p><strong>重载规则:</strong></p><ul><li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。 </li><li>无法以返回值类型作为重载函数的区分标准。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面经1&quot;&gt;&lt;a href=&quot;#面经1&quot; class=&quot;headerlink&quot; title=&quot;面经1&quot;&gt;&lt;/a&gt;面经1&lt;/h1&gt;&lt;h2 id=&quot;1-JVM内存分区&quot;&gt;&lt;a href=&quot;#1-JVM内存分区&quot; class=&quot;headerlink&quot; title=&quot;1.J</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
