<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Ai</title>
  
  <subtitle>春暖花开去见你</subtitle>
  <link href="https://leslieaibin.github.io/atom.xml" rel="self"/>
  
  <link href="https://leslieaibin.github.io/"/>
  <updated>2021-09-24T01:17:20.365Z</updated>
  <id>https://leslieaibin.github.io/</id>
  
  <author>
    <name>Leslie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://leslieaibin.github.io/2021/09/24/Thread/12.ThreadLocal%E7%9A%84hash%E5%86%B2%E7%AA%81%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://leslieaibin.github.io/2021/09/24/Thread/12.ThreadLocal%E7%9A%84hash%E5%86%B2%E7%AA%81%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2021-09-24T00:49:36.667Z</published>
    <updated>2021-09-24T01:17:20.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal-hash冲突与内存泄漏"><a href="#ThreadLocal-hash冲突与内存泄漏" class="headerlink" title="ThreadLocal-hash冲突与内存泄漏"></a>ThreadLocal-hash冲突与内存泄漏</h1><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。</p><p><strong>ThreadLocal的内部结构图</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83NDMyNjA0LWFkMmZmNTgxMTI3YmE4Y2MuanBnP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvODA2" alt="img"></p><p>ThreadLocal结构内部</p><p>从上面的结构图，我们已经窥见ThreadLocal的核心机制：</p><ul><li>每个Thread线程内部都有一个map</li><li>Map里面存储线程本地对象（key）和线程的变量副本（value)</li><li>但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值</li></ul><p>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</p><p>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现。</p><p>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"> </span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。</p><p>ThreadLocalMap的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">     * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of entries in the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hash冲突怎么解决"><a href="#Hash冲突怎么解决" class="headerlink" title="Hash冲突怎么解决"></a>Hash冲突怎么解决</h2><p><strong>和HashMap的最大的不同在于，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用线性探测的方式。</strong> 所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，<strong>如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。</strong></p><p>ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increment i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decrement i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然ThreadLocalMap采用线性探测的方式解决Hash冲突的效率很低，如果有大量不同的ThreadLocal对象放入map中时发送冲突，或者发生二次冲突，则效率很低。</p><p>所以这里引出的良好建议是：每个线程只存一个变量，这样的话所有的线程存放到map中的Key都是相同的ThreadLocal，如果一个线程要保存多个变量，就需要创建多个ThreadLocal，多个ThreadLocal放入Map中时会极大的增加Hash冲突的可能。</p><h2 id="ThreadLocalMap的问题"><a href="#ThreadLocalMap的问题" class="headerlink" title="ThreadLocalMap的问题"></a>ThreadLocalMap的问题</h2><p>ThreadLocal在ThreadLocalMap中是以一个弱引用身份被Entry中的Key引用的</p><p>由于Entry的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><h3 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h3><ul><li>key使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏</li><li>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。</li><li>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</li></ul><h3 id="如何避免泄漏"><a href="#如何避免泄漏" class="headerlink" title="如何避免泄漏"></a>如何避免泄漏</h3><p>既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。</p><p>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Session&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Session&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(<span class="keyword">new</span> Session(<span class="number">1</span>, <span class="string">&quot;Misout的博客&quot;</span>));</span><br><span class="line">    <span class="comment">// 其它业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。</li><li>ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ThreadLocal-hash冲突与内存泄漏&quot;&gt;&lt;a href=&quot;#ThreadLocal-hash冲突与内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal-hash冲突与内存泄漏&quot;&gt;&lt;/a&gt;ThreadLocal-hash冲</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>06.MySQL的主从复制</title>
    <link href="https://leslieaibin.github.io/2021/09/21/MySQL/06.MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://leslieaibin.github.io/2021/09/21/MySQL/06.MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2021-09-21T12:17:42.000Z</published>
    <updated>2021-09-21T08:38:02.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-BinLog"><a href="#MySQL-BinLog" class="headerlink" title="MySQL BinLog"></a>MySQL BinLog</h1><p>MySQL 的 Binlog 日志是一种二进制格式的日志，Binlog记录所有的DDL和DML语句（除了数据查询语句Select， show 等），以Event的形式记录，同时记录语句执行时间。</p><p>BInlog的 主要作用有两种：</p><ul><li><p>数据恢复：</p><p>因为Binlog详细记录所有修改数据的SQL，当某一个时刻的数据误操作而导致出问题，或者数据库当局数据丢失，那么可以根据binlog回放历史数据</p></li><li><p>主从复制</p><p>想做多级备份的业务，可以去监听当前写库的Binlog日志，同步写库的所有更改</p></li></ul><p>Binlog包括两类文件</p><ul><li>二进制日志索引文件（.index）：记录所有的二进制文件</li><li>二进制日志文件(.00000*)：记录所有DDL和DML语句事件</li></ul><p>Binlog日志功能默认是开启的，线上情况下的Binlog日志的增长速度是很快的，在MySQL配置文件<code>my.cnf</code> 中提供一些参数来对 Binlog 进行设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">设置此参数表示启用binlog功能，并制定二进制日志的存储目录</span><br><span class="line">log-<span class="built_in">bin</span>=/home/mysql/binlog/</span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql-bin.*日志文件最大字节（单位：字节）</span></span><br><span class="line"><span class="comment">#设置最大100MB</span></span><br><span class="line">max_binlog_size=<span class="number">104857600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置了只保留7天BINLOG（单位：天）</span></span><br><span class="line">expire_logs_days = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#binlog日志只记录指定库的更新</span></span><br><span class="line"><span class="comment">#binlog-do-db=db_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#binlog日志不记录指定库的更新</span></span><br><span class="line"><span class="comment">#binlog-ignore-db=db_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写缓冲多少次，刷一次磁盘，默认0</span></span><br><span class="line">sync_binlog=<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>max_binlog_size</strong> ：Binlog 最大和默认值是 1G，该设置并不能严格控制 Binlog 的大小，尤其是 Binlog 比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性不可能做切换日志的动作，只能将该事务的所有 SQL 都记录进当前日志直到事务结束。所以真实文件有时候会大于 max_binlog_size 设定值。</p><p><strong>expire_logs_days</strong> ：Binlog 过期删除不是服务定时执行，是需要借助事件触发才执行，事件包括：</p><ul><li>服务器重启</li><li>服务器被更新</li><li>日志达到了最大日志长度 <code>max_binlog_size</code></li><li>日志被刷新</li></ul><p>二进制日志由配置文件的 <code>log-bin</code> 选项负责启用，MySQL 服务器将在数据根目录创建两个新文件<code>mysql-bin.000001</code> 和 <code>mysql-bin.index</code>，若配置选项没有给出文件名，MySQL 将使用主机名称命名这两个文件，其中 <code>.index</code> 文件包含一份全体日志文件的清单。</p><p><strong>sync_binlog</strong>：这个参数决定了 Binlog 日志的更新频率。默认 0 ，表示该操作由操作系统根据自身负载自行决定多久写一次磁盘。</p><p>sync_binlog = 1 表示每一条事务提交都会立刻写盘。sync_binlog=n 表示 n 个事务提交才会写盘。</p><p>根据 MySQL 文档，写 Binlog 的时机是：SQL transaction 执行完，但任何相关的 Locks 还未释放或事务还未最终 commit 前。这样保证了 Binlog 记录的操作时序与数据库实际的数据变更顺序一致。</p><h1 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h1><p>Binlog 日志主要作用是数据恢复和主从复制。本身就是二进制格式的日志文件，网络传输无需进行协议转换。MySQL集群的高可用，负载均衡，读写分类等功能都是基于Binlog来实现的</p><h2 id="MySQL主从复制主流架构模型"><a href="#MySQL主从复制主流架构模型" class="headerlink" title="MySQL主从复制主流架构模型"></a>MySQL主从复制主流架构模型</h2><p>我们基于 Binlog 可以复制出一台 MySQL 服务器，也可以复制出多台，取决于我们想实现什么功能。主流的系统架构有如下几种方式：</p><h3 id="一主一从-一主多从"><a href="#一主一从-一主多从" class="headerlink" title="一主一从 / 一主多从"></a>一主一从 / 一主多从</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/007S8ZIlgy1gjx1mx9n5wj30lu0mwgne.jpg" alt="1"></p><p>一主一从和一主多从是最常见的主从架构方式，一般实现主从配置或者读写分离都可以采用这种架构。</p><p>如果是一主多从的模式，当 Slave 增加到一定数量时，Slave 对 Master 的负载以及网络带宽都会成为一个严重的问题。</p><h3 id="多主一从"><a href="#多主一从" class="headerlink" title="多主一从"></a>多主一从</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/007S8ZIlgy1gjx1mt1km7j30m80l4407.jpg" alt="1"></p><p>MySQL 5.7 开始支持多主一从的模式，将多个库的数据备份到一个库中存储。</p><h3 id="双主复制"><a href="#双主复制" class="headerlink" title="双主复制"></a>双主复制</h3><p>理论上跟主从一样，但是两个MySQL服务器互做对方的从，任何一方有变更，都会复制对方的数据到自己的数据库。双主适用于写压力比较大的业务场景，或者 DBA 做维护需要主从切换的场景，通过双主架构避免了重复搭建从库的麻烦。（主从相互授权连接，读取对方binlog日志并更新到本地数据库的过程；只要对方数据改变，自己就跟着改变）</p><h3 id="级联复制"><a href="#级联复制" class="headerlink" title="级联复制"></a>级联复制</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/007S8ZIlgy1gjx1mr6mxzj30z60hg40u.jpg" alt="1"></p><p>级联模式下因为涉及到的 slave 节点很多，所以如果都连在 master 上对主服务器的压力肯定是不小的。所以部分 slave 节点连接到它上一级的从节点上。这样就缓解了主服务器的压力。</p><p>级联复制解决了一主多从场景下多个从库复制对主库的压力，带来的弊端就是数据同步延迟比较大。</p><h2 id="MySQL-主从复制原理"><a href="#MySQL-主从复制原理" class="headerlink" title="MySQL 主从复制原理"></a>MySQL 主从复制原理</h2><p>MySQL 主从复制涉及到三个线程：</p><ul><li>一个在主节点的线程：<code>log dump thread</code></li><li>从库会生成两个线程：一个 I/O 线程，一个 SQL 线程</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/007S8ZIlgy1gjx1ms5ezhj312s0imtb5.jpg" alt="4"></p><p>主库会生成一个 log dump 线程,用来给从库 I/O 线程传 Binlog 数据。</p><p>从库的 I/O 线程会去请求主库的 Binlog，并将得到的 Binlog 写到本地的 relay log (中继日志)文件中。</p><p>SQL 线程,会读取 relay log 文件中的日志，并解析成 SQL 语句逐一执行。</p><h5 id="主节点-log-dump-线程"><a href="#主节点-log-dump-线程" class="headerlink" title="主节点 log dump 线程"></a>主节点 log dump 线程</h5><p>当从节点连接主节点时，主节点会为其创建一个 log dump 线程，用于发送和读取 Binlog 的内容。在读取 Binlog 中的操作时，log dump 线程会对主节点上的 Binlog 加锁；当读取完成发送给从节点之前，锁会被释放。<strong>主节点会为自己的每一个从节点创建一个 log dump 线程</strong>。</p><h5 id="从节点I-O线程"><a href="#从节点I-O线程" class="headerlink" title="从节点I/O线程"></a>从节点I/O线程</h5><p>当从节点上执行<code>start slave</code>命令之后，从节点会创建一个 I/O 线程用来连接主节点，请求主库中更新的Binlog。I/O 线程接收到主节点的 log dump 进程发来的更新之后，保存在本地 relay-log（中继日志）中。</p><h5 id="relay-log"><a href="#relay-log" class="headerlink" title="relay log"></a>relay log</h5><p>这里又引申出一个新的日志概念。MySQL 进行主主复制或主从复制的时候会在要复制的服务器下面产生相应的 relay log。</p><p>relay log 是怎么产生的呢？</p><p>从服务器 I/O 线程将主服务器的 Binlog 日志读取过来，解析到各类 Events 之后记录到从服务器本地文件，这个文件就被称为 relay log。然后 SQL 线程会读取 relay log 日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致。中继日志充当缓冲区，这样 master 就不必等待 slave 执行完成才发送下一个事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  show variables like &#39;%relay%&#39;;</span><br><span class="line">+---------------------------+------------------------------------------------------------+</span><br><span class="line">| Variable_name             | Value                                                      |</span><br><span class="line">+---------------------------+------------------------------------------------------------+</span><br><span class="line">| max_relay_log_size        | 0                                                          |</span><br><span class="line">| relay_log                 | yangyuedeMacBook-Pro-relay-bin                             |</span><br><span class="line">| relay_log_basename        | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;yangyuedeMacBook-Pro-relay-bin       |</span><br><span class="line">| relay_log_index           | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;yangyuedeMacBook-Pro-relay-bin.index |</span><br><span class="line">| relay_log_info_file       | relay-log.info                                             |</span><br><span class="line">| relay_log_info_repository | TABLE                                                      |</span><br><span class="line">| relay_log_purge           | ON                                                         |</span><br><span class="line">| relay_log_recovery        | OFF                                                        |</span><br><span class="line">| relay_log_space_limit     | 0                                                          |</span><br><span class="line">| sync_relay_log            | 10000                                                      |</span><br><span class="line">| sync_relay_log_info       | 10000                                                      |</span><br><span class="line">+---------------------------+------------------------------------------------------------+</span><br><span class="line">11 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><p><strong>max_relay_log_size</strong></p><p>标记 relay log 允许的最大值，如果该值为 0，则默认值为 max_binlog_size(1G)；如果不为 0，则max_relay_log_size 则为最大的 relay_log 文件大小。</p><p><strong>relay_log_purge</strong></p><p>是否自动清空不再需要中继日志时。默认值为1(启用)。</p><p><strong>relay_log_recovery</strong></p><p>当 slave 从库宕机后，假如 relay log 损坏了，导致一部分中继日志没有处理，则自动放弃所有未执行的 relay log，并且重新从 master 上获取日志，这样就保证了 relay log 的完整性。默认情况下该功能是关闭的，将 relay_log_recovery 的值设置为 1 时，可在 slave 从库上开启该功能，建议开启。</p><p><strong>relay_log_space_limit</strong></p><p>防止中继日志写满磁盘，这里设置中继日志最大限额。但此设置存在主库崩溃，从库中继日志不全的情况，不到万不得已，<strong>不推荐使用。</strong></p><p><strong>sync_relay_log</strong></p><p>这个参数和 Binlog 中的 <code>sync_binlog</code>作用相同。当设置为 1 时，slave 的 I/O 线程每次接收到 master 发送过来的 Binlog 日志都要写入系统缓冲区，然后刷入 relay log 中继日志里，这样是最安全的，因为在崩溃的时候，你最多会丢失一个事务，但会造成磁盘的大量 I/O。</p><p>当设置为 0 时，并不是马上就刷入中继日志里，而是由操作系统决定何时来写入，虽然安全性降低了，但减少了大量的磁盘 I/O 操作。这个值默认是 0，可动态修改，建议采用默认值。</p><p><strong>sync_relay_log_info</strong></p><p>当设置为 1 时，slave 的 I/O 线程每次接收到 master 发送过来的 Binlog 日志都要写入系统缓冲区，然后刷入 relay-log.info 里，这样是最安全的，因为在崩溃的时候，你最多会丢失一个事务，但会造成磁盘的大量 I/O。当设置为 0 时，并不是马上就刷入 relay-log.info 里，而是由操作系统决定何时来写入，虽然安全性降低了，但减少了大量的磁盘 I/O 操作。这个值默认是0，可动态修改，建议采用默认值。</p><h5 id="从节点-SQL-线程"><a href="#从节点-SQL-线程" class="headerlink" title="从节点 SQL 线程"></a>从节点 SQL 线程</h5><p>SQL 线程负责读取 relay log 中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</p><p>对于每一个主从连接，都需要这三个进程来完成。当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个 log dump 进程，而每个从节点都有自己的 I/O 进程，SQL 进程。</p><p>从节点用两个线程将从主库拉取更新和执行分成独立的任务，这样在执行同步数据任务的时候，不会降低读操作的性能。比如，如果从节点没有运行，此时 I/O 进程可以很快从主节点获取更新，尽管 SQL 进程还没有执行。如果在 SQL 进程执行之前从节点服务停止，至少 I/O 进程已经从主节点拉取到了最新的变更并且保存在本地 relay log 中，当服务再次起来之后就可以完成数据的同步。</p><p>要实施复制，首先必须打开 Master 端的 Binlog 功能，否则无法实现。</p><p>因为整个复制过程实际上就是 Slave 从 Master 端获取该日志然后再在自己身上完全顺序的执行日志中所记录的各种操作。如下图所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/007S8ZIlgy1gjx1mvsnp5j31040iyad2.jpg" alt="5"></p><h5 id="复制的基本过程"><a href="#复制的基本过程" class="headerlink" title="复制的基本过程"></a>复制的基本过程</h5><ol><li>在从节点上执行 <code>sart slave</code> 命令开启主从复制开关，开始进行主从复制。从节点上的 I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容。</li><li>主节点接收到来自从节点的 I/O 请求后，通过负责复制的 I/O 进程（log Dump Thread）根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的 Binlog file 以及 Binlog position（Binlog 下一个数据读取位置）。</li><li>从节点的 I/O 进程接收到主节点发送过来的日志内容、日志文件及位置点后，将接收到的日志内容更新到本机的 relay log 文件（Mysql-relay-bin.xxx）的最末端，并将读取到的 Binlog文件名和位置保存到<code>master-info</code> 文件中，以便在下一次读取的时候能够清楚的告诉 Master ：“ 我需要从哪个 Binlog 的哪个位置开始往后的日志内容，请发给我”。</li><li>Slave 的 SQL 线程检测到relay log 中新增加了内容后，会将 relay log 的内容解析成在能够执行 SQL 语句，然后在本数据库中按照解析出来的顺序执行，并在 <code>relay log.info</code> 中记录当前应用中继日志的文件名和位置点。</li></ol><h2 id="MySQL-基于-Binlog-主从复制的模式介绍"><a href="#MySQL-基于-Binlog-主从复制的模式介绍" class="headerlink" title="MySQL 基于 Binlog 主从复制的模式介绍"></a>MySQL 基于 Binlog 主从复制的模式介绍</h2><p>MySQL 主从复制默认是 <strong>异步的模式</strong>。MySQL增删改操作会全部记录在 Binlog 中，当 slave 节点连接 master 时，会主动从 master 处获取最新的 Binlog 文件。并把 Binlog 存储到本地的 relay log 中，然后去执行 relay log 的更新内容。</p><h3 id="异步模式-async-mode"><a href="#异步模式-async-mode" class="headerlink" title="异步模式 (async-mode)"></a>异步模式 (async-mode)</h3><p>异步模式如下图所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/007S8ZIlgy1gjx1mu02wbj31160kk0vj.jpg" alt="6"></p><p>这种模式下，主节点不会主动推送数据到从节点，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主节点如果崩溃掉了，此时主节点上已经提交的事务可能并没有传到从节点上，如果此时，强行将从提升为主，可能导致新主节点上的数据不完整。</p><h3 id="全同步模式"><a href="#全同步模式" class="headerlink" title="全同步模式"></a>全同步模式</h3><p>指当主库执行完一个事务，然后所有的从库都复制了该事务并成功执行完才返回成功信息给客户端。因为需要等待所有从库执行完该事务才能返回成功信息，所以全同步复制的性能必然会收到严重的影响。</p><h3 id="半同步模式-semi-sync"><a href="#半同步模式-semi-sync" class="headerlink" title="半同步模式(semi-sync)"></a>半同步模式(semi-sync)</h3><p>介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到 relay log 中才返回成功信息给客户端（只能保证主库的 Binlog 至少传输到了一个从节点上），否则需要等待直到超时时间然后切换成异步模式再提交。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/007S8ZIlgy1gjx1muypwdj31420jg41q.jpg" alt="7"></p><p>相对于异步复制，半同步复制提高了数据的安全性，一定程度的保证了数据能成功备份到从库，同时它也造成了一定程度的延迟，但是比全同步模式延迟要低，这个延迟最少是一个 TCP/IP 往返的时间。所以，半同步复制最好在低延时的网络中使用。</p><p>半同步模式不是 MySQL 内置的，从 MySQL 5.5 开始集成，需要 master 和 slave 安装插件开启半同步模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL-BinLog&quot;&gt;&lt;a href=&quot;#MySQL-BinLog&quot; class=&quot;headerlink&quot; title=&quot;MySQL BinLog&quot;&gt;&lt;/a&gt;MySQL BinLog&lt;/h1&gt;&lt;p&gt;MySQL 的 Binlog 日志是一种二进制格式的日志，B</summary>
      
    
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>10.Java内存模型</title>
    <link href="https://leslieaibin.github.io/2021/09/15/Thread/11.Java%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM)/"/>
    <id>https://leslieaibin.github.io/2021/09/15/Thread/11.Java%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM)/</id>
    <published>2021-09-15T02:15:42.000Z</published>
    <updated>2021-09-15T13:57:21.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h1><p>JVM内存模型指的是JVM的内存分区；而java内存模型是一种虚拟机规范</p><p>JMM就是Java内存模型（Java Mermory Model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。<strong>所以Java内存模型（JMM）屏蔽掉各种硬件和和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果</strong></p><p>Java内存模型规定所有的变量存储在主内存中，包括 实例变量，静态变量，但是不包括局部变量和方法参数，每个线程都有自己的工作内存，线程的工作内存保存了该线程用的到变量和主内存的副本拷贝，线程对变量的操作 都在工作内存中进行。线程不能直接读写主内存中的变量。</p><p>不同的线程之间也无法访问对方工作内存中的变量，线程之间变量值的传递均需要通过主内存来完成</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-f36f366c07a6188ea3fdefc794ba021a_720w.jpg" alt="img"></p><p>每个线程的工作内存都是独立的，线程操作数据只能在工作内存中进行，然后刷会主存，这是JMM的线程基本工作方式</p><h2 id="JMM定义了什么"><a href="#JMM定义了什么" class="headerlink" title="JMM定义了什么"></a>JMM定义了什么</h2><p>整个Java内存模型实际上是围绕着三个特征建立起来的。分别是：原子性(Atomicity)，可见性（Visibility），有序性（Ordering）。这三个特征可谓是整个Java并发的基础</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性指的是一个操作是不可分割，不可中断的，一个线程在执行时不会被其他线程干扰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line">i++;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>第一句是基本类型赋值操作，必定是原子性操作。</p><p>第二句先读取i的值，再赋值到j，两步操作，不能保证原子性。</p><p>第三和第四句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</p><p>JMM只能保证基本的原子性，如果要保证一个代码块的原子性，提供了monitorenter 和 moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性指当一个线程修改共享变量的值，其他线程能够立即知道被修改了。Java是利用Volatile关键字来提供可见性的。当变量被volatile修饰时，这个变量被修改后会立即刷新到主内存，当其他线程需要读取该变量时，会去至内存中读取新值。而普通变量则不能保证这一点</p><p>除了volatile关键字之外，final和synchronized也能实现可见性。</p><p>synchronized的原理是，在执行完，进入unlock之前，必须将共享变量同步到主内存中。</p><p>final修饰的字段，一旦初始化完成，如果没有对象逸出（指对象为初始化完成就可以被别的线程使用），那么对于其他线程都是可见的。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>在Java中，可以使用synchronized或者volatile保证多线程之间操作的有序性。实现原理有些区别：</p><p>volatile关键字是使用内存屏障达到禁止指令重排序，以保证有序性。</p><p>synchronized的原理是，一个线程lock之后，必须unlock后，其他线程才可以重新lock，使得被synchronized包住的代码块在多线程之间是串行执行的。</p><h2 id="八种内存交互操作"><a href="#八种内存交互操作" class="headerlink" title="八种内存交互操作"></a>八种内存交互操作</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210915214648182.png" alt="image-20210915214648182"></p><ul><li>lock(锁定)，作用于<strong>主内存</strong>中的变量，把变量标识为线程独占的状态。</li><li>read(读取)，作用于<strong>主内存</strong>的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。</li><li>load(加载)，作用于<strong>工作内存</strong>的变量，把read操作主存的变量放入到工作内存的变量副本中。</li><li>use(使用)，作用于<strong>工作内存</strong>的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign(赋值)，作用于<strong>工作内存</strong>的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li><li>store(存储)，作用于<strong>工作内存</strong>的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li><li>write(写入)：作用于<strong>主内存</strong>中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li><li>unlock(解锁)：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ul><p>再补充一下JMM对8种内存交互操作制定的规则吧：</p><ul><li>不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。</li><li>不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。</li><li>不允许线程将没有assign的数据从工作内存同步到主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。</li><li>一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。</li><li>一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。</li></ul><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><ul><li>保证线程间变量的可见性</li><li>禁止CPU进行指令重排</li></ul><h2 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h2><p>volatile修饰的变量，当一个线程改变了该变量的值，其他线程是立即可见的。普通变量则需要重新读取才能获得最新值。</p><p>volatile保证可见性的流程大概就是这个一个过程：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-2ce112590b4b81cdb02b8839d9d8b686_720w.jpg" alt="img"></p><h2 id="volatile一定能保证线程安全吗"><a href="#volatile一定能保证线程安全吗" class="headerlink" title="volatile一定能保证线程安全吗"></a>volatile一定能保证线程安全吗</h2><p>先说结论吧，volatile不能一定能保证线程安全。</p><p>怎么证明呢，我们看下面一段代码的运行结果就知道了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author Ye Hongzhi 公众号：java技术爱好者</span><br><span class="line"> **/</span><br><span class="line">public class VolatileTest extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Vector&lt;Thread&gt; threads = new Vector&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            VolatileTest thread = new VolatileTest();</span><br><span class="line">            threads.add(thread);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        //等待子线程全部完成</span><br><span class="line">        for (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        //输出结果，正确结果应该是1000，实际却是984</span><br><span class="line">        System.out.println(count);//984</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //休眠500毫秒</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么volatile不能保证线程安全？</p><p>很简单呀，可见性不能保证操作的原子性，前面说过了count++不是原子性操作，会当做三步，先读取count的值，然后+1，最后赋值回去count变量。需要保证线程安全的话，需要使用synchronized关键字或者lock锁，给count++这段代码上锁：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static synchronized void add() &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h2><p>首先要讲一下as-if-serial语义，不管怎么重排序，（单线程）程序的执行结果不能被改变。</p><p>为了使指令更加符合CPU的执行特性，最大限度的发挥机器的性能，提高程序的执行效率，只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做<strong>指令的重排序</strong>。</p><p>重排序的种类分为三种，分别是：编译器重排序，指令级并行的重排序，内存系统重排序。整个过程如下所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210915215020235.png" alt="image-20210915215020235"></p><p>指令重排序在单线程是没有问题的，不会影响执行结果，而且还提高了性能。但是在多线程的环境下就不能保证一定不会影响执行结果了。</p><p><strong>所以在多线程环境下，就需要禁止指令重排序</strong>。</p><p>volatile关键字禁止指令重排序有两层意思：</p><ul><li>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行。</li><li>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</li></ul><p>下面举个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static int a;//非volatile修饰变量</span><br><span class="line">private static int b;//非volatile修饰变量</span><br><span class="line">private static volatile int k;//volatile修饰变量</span><br><span class="line"></span><br><span class="line">private void hello() &#123;</span><br><span class="line">    a = 1;  //语句1</span><br><span class="line">    b = 2;  //语句2</span><br><span class="line">    k = 3;  //语句3</span><br><span class="line">    a = 4;  //语句4</span><br><span class="line">    b = 5;  //语句5</span><br><span class="line">    //以下省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量a，b是非volatile修饰的变量，k则使用volatile修饰。所以语句3不能放在语句1、2前，也不能放在语句4、5后。但是语句1、2的顺序是不能保证的，同理，语句4、5也不能保证顺序。</p><p>并且，执行到语句3的时候，语句1，2是肯定执行完毕的，而且语句1,2的执行结果对于语句3,4,5是可见的。</p><h2 id="volatile禁止指令重排序的原理是什么"><a href="#volatile禁止指令重排序的原理是什么" class="headerlink" title="volatile禁止指令重排序的原理是什么"></a>volatile禁止指令重排序的原理是什么</h2><p>首先要讲一下内存屏障，内存屏障可以分为以下几类：</p><ul><li>LoadLoad 屏障：对于这样的语句Load1，LoadLoad，Load2。在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1， StoreStore， Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore 屏障：对于这样的语句Load1， LoadStore，Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad 屏障：对于这样的语句Store1， StoreLoad，Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li></ul><p>在每个volatile读操作后插入LoadLoad屏障，在读操作后插入LoadStore屏障。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210915215154275.png" alt="image-20210915215154275"></p><p>在每个volatile写操作的前面插入一个StoreStore屏障，后面插入一个SotreLoad屏障。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210915215209621.png" alt="image-20210915215209621"></p><p>大概的原理就是这样。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java内存模型（JMM）&quot;&gt;&lt;a href=&quot;#Java内存模型（JMM）&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型（JMM）&quot;&gt;&lt;/a&gt;Java内存模型（JMM）&lt;/h1&gt;&lt;p&gt;JVM内存模型指的是JVM的内存分区；而java内存</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>05.分布式锁</title>
    <link href="https://leslieaibin.github.io/2021/09/11/MySQL/05.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>https://leslieaibin.github.io/2021/09/11/MySQL/05.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2021-09-11T12:17:42.000Z</published>
    <updated>2021-09-11T02:31:35.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h2><ul><li>在单线程的系统中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行消除并发修改变量</li><li>而同步的本质是通过锁实现的。为了实现多个线程在一个时刻同一代码块只能有一个线程可执行，那么需要在某个地方做个标记，这个必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。这个标记可以理解为锁。</li><li>不同地方实现锁的方式也不一样，只要能满足所有线程都能看到标记即可。如java中synchroniuze是 在对象头设置标记，Lock接口的实现类基本上都只是某一个volitile修饰的int型变量其保证每个线程都能拥有对该int的可见性和原子性修改，linux内核中也是利用互斥量或信号量等内存数据标记</li><li>除了利用内存数据做锁其他任何互斥的都能做锁（只考虑互斥情况），如流水表中流水号与实践结合做幂等校验可以看作是一个不会释放的锁，或者使用某个文件是否存在作为锁等。只需要满足在对标记进行修改能保证原子性和内存可见性即可。</li></ul><h2 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h2><p>分布式的CAP理论告诉我们：</p><p>任何一个分布式系统都无法同时满足一致性（Consistency）、 可用性（Avaiability）和分区容错性（Partition tolerance)，最多只能同时满足两项。</p><p>目前很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。基于CAP理论，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性</p><h2 id="分布式场景"><a href="#分布式场景" class="headerlink" title="分布式场景"></a>分布式场景</h2><p>在许多的场景中，我们为了保证数据的最终一致性，需要很多技术方案来支持，比如分布式事务，分布式锁等。很多时候我们需要保证一个方法在同一时间只能被同一线程执行。在单机环境中，通过java提供的并发API我们可以解决，但是在分布式环境下，就没有那么简单。</p><ul><li>分布式与单机情况下最大的不同在于其不是多线程而是多进程</li><li>多线程由于共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一物理机上，因此需要将标记存储在一个所有进程都能看到的地方</li></ul><h2 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h2><ul><li>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数</li><li>与单机模型下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。</li><li>分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行</li></ul><h2 id="我们需要怎样的分布式锁"><a href="#我们需要怎样的分布式锁" class="headerlink" title="我们需要怎样的分布式锁"></a>我们需要怎样的分布式锁</h2><ul><li>可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。</li><li>这把锁要是一把可重入锁（避免死锁）</li><li>这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）</li><li>这把锁最好是一把公平锁（根据业务需求考虑要不要这条）</li><li>有高可用的获取锁和释放锁功能</li><li>获取锁和释放锁的性能要好</li></ul><h1 id="基于表主键唯一做分布式锁"><a href="#基于表主键唯一做分布式锁" class="headerlink" title="基于表主键唯一做分布式锁"></a>基于表主键唯一做分布式锁</h1><p>利用主键的特性，如果多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以任务操作成功的那个县城获得该方法的锁，当方法执行完毕之后，想要释放锁的话，删除这条数据库记录即可</p><p>上面这种简单的实现有以下几个问题：</p><ul><li>这把锁依赖数据库的可用性，数据库是一个单点，一旦数据库挂了，会导致业务系统不可用</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获取锁</li><li>这把锁只能是非阻塞的，因为 数据insert操作，一旦插入失败就会直接报错。没有获得锁的线程比不会进入排队队列，想要再次获得锁就要再次触发获得锁操作。</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li><li>这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁。</li><li>在 MySQL 数据库中采用主键冲突防重，在大并发情况下有可能会造成锁表现象。</li></ul><p><strong>我们也可以有其他方式解决上面的问题</strong></p><ul><li>数据库是单点？ 搞两个数据库，数据之前双向同步，一旦挂掉快速切换到备库上</li><li>没有失效时间？ 只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍</li><li>非阻塞的？搞一个 while 循环，直到 insert 成功再返回成功。</li><li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li><li>非公平的？再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许获取锁。</li><li>比较好的办法是在程序中生产主键进行防重。</li></ul><h1 id="基于Redis做分布式锁"><a href="#基于Redis做分布式锁" class="headerlink" title="基于Redis做分布式锁"></a>基于Redis做分布式锁</h1><h2 id="基于redis-的-setnx-、expire-方法做分布式锁"><a href="#基于redis-的-setnx-、expire-方法做分布式锁" class="headerlink" title="基于redis 的 setnx()、expire()方法做分布式锁"></a>基于redis 的 setnx()、expire()方法做分布式锁</h2><h3 id="setnx"><a href="#setnx" class="headerlink" title="setnx()"></a>setnx()</h3><p>setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。</p><h3 id="expire"><a href="#expire" class="headerlink" title="expire()"></a>expire()</h3><p>expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置。</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1、setnx(lockkey, 1) 如果返回 0，则说明占位失败；如果返回 1，则说明占位成功</p><p>2、expire() 命令对 lockkey 设置超时时间，为的是避免死锁问题。</p><p>3、执行完业务代码后，可以通过 delete 命令删除 key。</p><p>这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。<strong>比如，如果在第一步 setnx 执行成功后，在 expire() 命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题，所以如果要对其进行完善的话，可以使用 redis 的 setnx()、get() 和 getset() 方法来实现分布式锁。</strong></p><h2 id="基于-redis-的-setnx-、get-、getset-方法做分布式锁"><a href="#基于-redis-的-setnx-、get-、getset-方法做分布式锁" class="headerlink" title="基于 redis 的 setnx()、get()、getset()方法做分布式锁"></a>基于 redis 的 setnx()、get()、getset()方法做分布式锁</h2><p>这个方案的背景主要是在 setnx() 和 expire() 的方案上针对可能存在的死锁问题，做了一些优化。</p><h3 id="getset"><a href="#getset" class="headerlink" title="getset()"></a>getset()</h3><p>这个命令主要有两个参数 getset(key，newValue)。该方法是原子的，对 key 设置 newValue 这个值，并且返回 key 原来的旧值。假设 key 原来是不存在的，那么多次执行这个命令，会出现下边的效果：</p><ol><li>getset(key, “value1”) 返回 null 此时 key 的值会被设置为 value1</li><li>getset(key, “value2”) 返回 value1 此时 key 的值会被设置为 value2</li><li>依次类推！</li></ol><h3 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>setnx(lockkey, 当前时间+过期超时时间)，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁，转向 2。</li><li>get(lockkey) 获取值 oldExpireTime ，并将这个 value 值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向 3。</li><li>计算 newExpireTime = 当前时间+过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 lockkey 的值currentExpireTime。</li><li>判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前 getset 设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。</li><li>在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行 delete 释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。</li></ol><h1 id="基于-ZooKeeper-做分布式锁"><a href="#基于-ZooKeeper-做分布式锁" class="headerlink" title="基于 ZooKeeper 做分布式锁"></a>基于 ZooKeeper 做分布式锁</h1><h2 id="zookeeper-锁相关基础知识"><a href="#zookeeper-锁相关基础知识" class="headerlink" title="zookeeper 锁相关基础知识"></a>zookeeper 锁相关基础知识</h2><ul><li>zk一般由多个节点构成（单数），采用zab一致性协议。因此可以将zk看成一个单点结构，对其修改数据其内部自动将所有节点数据进行修改后才提供查询服务</li><li>zk的数据以目录树的形式，每个目录称为znode，znode中可存储数据（一般不超过1M），还可以在其中增加子节点</li><li>子节点有三种类型。序列化节点，每在该节点下增加一个节点自动给该节点的名称上自增。一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除。最后就是普通节点。</li><li>Watch 机制，client 可以监控每个节点的变化，当产生变化会给 client 产生一个事件。</li></ul><h2 id="zk基本锁"><a href="#zk基本锁" class="headerlink" title="zk基本锁"></a>zk基本锁</h2><ul><li>原理：利用临时节点与 watch 机制。每个锁占用一个普通节点 /lock，当需要获取锁时在 /lock 目录下创建一个临时节点，创建成功则表示获取锁成功，失败则 watch/lock 节点，有删除操作后再去争锁。临时节点好处在于当进程挂掉后能自动上锁的节点自动删除即取消锁。</li><li>缺点：所有取锁失败的进程都监听父节点，很容易发生羊群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。</li></ul><h2 id="zk-锁优化"><a href="#zk-锁优化" class="headerlink" title="zk 锁优化"></a>zk 锁优化</h2><ul><li>原理：上锁改为创建临时有序节点，每个上锁的节点均能创建节点成功，只是其序号不同。只有序号最小的可以拥有锁，如果这个节点序号不是最小的则 watch 序号比本身小的前一个节点 (公平锁)。</li><li>步骤：</li><li>在 /lock 节点下创建一个有序临时节点 (EPHEMERAL_SEQUENTIAL)。</li><li>判断创建的节点序号是否最小，如果是最小则获取锁成功。不是则取锁失败，然后 watch 序号比本身小的前一个节点。</li><li>当取锁失败，设置 watch 后则等待 watch 事件到来后，再次判断是否序号最小。</li><li>取锁成功则执行代码，最后释放锁（删除该节点）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h1&gt;&lt;h2 id=&quot;什么是锁&quot;&gt;&lt;a href=&quot;#什么是锁&quot; class=&quot;headerlink&quot; title=&quot;什么是锁&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>04.MySQL索引原理及慢查询优化</title>
    <link href="https://leslieaibin.github.io/2021/09/10/MySQL/04.MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>https://leslieaibin.github.io/2021/09/10/MySQL/04.MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</id>
    <published>2021-09-10T12:17:42.000Z</published>
    <updated>2021-09-11T02:30:25.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>MySQL凭借着出色的性能、低廉的成本、丰富的资源，已经成为绝大多数互联网公司的首选关系型数据库。虽然性能出色，但所谓“好马配好鞍”，如何能够更好的使用它，已经成为开发工程师的必修课，我们经常会从职位描述上看到诸如“精通MySQL”、“SQL语句优化”、“了解数据库原理”等要求。我们知道一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。背景</p><h2 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h2><h3 id="索引目的"><a href="#索引目的" class="headerlink" title="索引目的"></a>索引目的</h3><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p><h3 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h3><p>除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p><p>数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p><h3 id="磁盘IO与预读"><a href="#磁盘IO与预读" class="headerlink" title="磁盘IO与预读"></a>磁盘IO与预读</h3><p>前面提到了访问磁盘，那么这里先介绍下磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/7f46a0a4.png" alt="various-system-software-hardware-latencies"></p><p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。</p><p><strong>详解B+树</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/7af22798.jpg" alt="b+树"></p><p>如上图，是一颗b+树，关于b+树的定义可以参见<a href="http://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+树</a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p><h4 id="b-树的查找过程"><a href="#b-树的查找过程" class="headerlink" title="b+树的查找过程"></a>b+树的查找过程</h4><p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><h4 id="b-树性质"><a href="#b-树性质" class="headerlink" title="b+树性质"></a>b+树性质</h4><p>1.通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p><p>2.当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p><h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><p>关于MySQL索引原理是比较枯燥的东西，大家只需要有一个感性的认识，并不需要理解得非常透彻和深入。我们回头来看看一开始我们说的慢查询，了解完索引原理之后，大家是不是有什么想法呢？先总结一下索引的几大基本原则：</p><h3 id="建索引的几大原则："><a href="#建索引的几大原则：" class="headerlink" title="建索引的几大原则："></a>建索引的几大原则：</h3><ul><li><p>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p></li><li><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p></li><li><p>尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p></li><li><p>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</p></li><li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p></li></ul><h2 id="回到开始的慢查询"><a href="#回到开始的慢查询" class="headerlink" title="回到开始的慢查询"></a>回到开始的慢查询</h2><p>根据最左匹配原则，最开始的sql语句的索引应该是status、operator_id、type、operate_time的联合索引；其中status、operator_id、type的顺序可以颠倒，所以我才会说，把这个表的所有相关查询都找到，会综合分析；比如还有如下查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from task where status &#x3D; 0 and type &#x3D; 12 limit 10;</span><br><span class="line">select count(*) from task where status &#x3D; 0 ;</span><br></pre></td></tr></table></figure><p>那么索引建立成(status,type,operator_id,operate_time)就是非常正确的，因为可以覆盖到所有情况。这个就是利用了索引的最左匹配的原则</p><h3 id="查询优化神器-explain命令"><a href="#查询优化神器-explain命令" class="headerlink" title="查询优化神器 - explain命令"></a>查询优化神器 - explain命令</h3><p>关于explain命令相信大家并不陌生，具体用法和字段含义可以参考官网<a href="http://dev.mysql.com/doc/refman/5.5/en/explain-output.html">explain-output</a>，这里需要强调rows是核心指标，绝大部分rows小的语句执行一定很快（有例外，下面会讲到）。所以优化语句基本上都是在优化rows。</p><h3 id="慢查询优化基本步骤"><a href="#慢查询优化基本步骤" class="headerlink" title="慢查询优化基本步骤"></a>慢查询优化基本步骤</h3><p>0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE</p><p>1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</p><p>2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</p><p>3.order by limit 形式的sql语句让排序的表优先查</p><p>4.了解业务方使用场景</p><p>5.加索引时参照建索引的几大原则</p><p>6.观察结果，不符合预期继续从0分析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;MySQL凭借着出色的性能、低廉的成本、丰富的资源，已经成为绝大多数互联网公司的首选关系型数据库。虽然性能出色，但所谓“好马配好鞍”，如何能</summary>
      
    
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>03.一条SQL查询语句如何执行</title>
    <link href="https://leslieaibin.github.io/2021/09/09/MySQL/03.MySQL%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B/"/>
    <id>https://leslieaibin.github.io/2021/09/09/MySQL/03.MySQL%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B/</id>
    <published>2021-09-09T12:17:42.000Z</published>
    <updated>2021-09-11T02:30:12.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一条SQL查询语句如何执行"><a href="#一条SQL查询语句如何执行" class="headerlink" title="一条SQL查询语句如何执行"></a>一条SQL查询语句如何执行</h1><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210910095617441.png" alt="image-20210910095617441"></p><p>MySQL可以分为Server层和存储引擎层两部分</p><p>Server层包括 <strong>连接器、查询缓存、分析器、优化器、执行器</strong>等，涵盖了MySQL的大多数核心功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程，触发器，视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎InnoDB，它从MySQL5.5.5版本开始成为默认存储引擎。</p><p>也就是说，你执行create table建表的时候，如果不执行搜索引擎，默认的是innodb，不过，你也可以通过执行存储引擎的类型来选择别的引擎，比如在create table 语句中使用 engine=memory，来执行使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，你会先连接到这数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接，获取权限，位置和管理连接。连接命令一般是这么写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>输完命令后，你就需要在交互对话里面输入密码。虽然密码也可以直接在-p后面卸载命令行中，但这样可能会导致你的密码泄露。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。<br>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist令中看到它。文本中这个图是 show processlist的结果，其中的 Command列显示为Sleep的这一行，就表示现在系统里面有一个空闲连接</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210910103606002.png" alt="image-20210910103606002"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait timeout控制的，默认值是8小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒：Lost connection to MySQL server during query.这时候如果你要继续，就需要重连，然后再执行请求了数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断连接，下次查询再重新建立一个</p><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，你就可以执行 select语句了执行逻辑就会来到第二步：查询缓存MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key- -value对的形式，被直接缓存在内存中。key是查询的语句， value是查询的结果。如果你的查询能够直接在这个缓存中找到key.那么这个 value就会被直接返回给客户端。<br>如果语句不在查询缓存中，就会继续后面的执行阶段执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存， MySQ不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。<br>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会史新一次。</p><p>比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。<br>好在MSQL也提供了这种“按需使用”的方式。你可以将参数query cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL CACHE显式指定，像下面这个语句一样：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE from T where ID&#x3D;10：</span><br></pre></td></tr></table></figure><p><strong>需要注意的是， MySQL8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</strong></p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MQL需要知道你要做什么，因此需要对SQL语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句， MySQL需要识别出里面的字符串分别是什么，代表什么</p><p>MySQL从你输入的”select这个关键字识别出来，这是一个查询语句。它也要把字符串“T识别成“名T，把字符串识别成列D做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MSQL语法</p><p>如果你的语句不对，就会收到You have an error in your SQL syntax的错误提醒，比如下面这个语句 select少打了开头的字母s”。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL就知道你要做什么，在开始执行之前，要经过优化器的处理</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引，或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * <span class="function">from t1 join t2 <span class="title">using</span><span class="params">(ID)</span> where t1.c</span>=<span class="number">10</span> and t2.d = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出 c = 10的记录的ID值，在根据ID关联到表t2，再判断t2里面d的值是否等于20</li><li>也可以先从表t2里面取出d=20的记录的id值，在根据ID值关联到t1，在判断t1里面c的值是否等于10</li></ul><p>这两种执行方法的逻辑结果是一样的，但执行的效率会有不同，而优化器的作用是决定选择使用哪个方案</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MSQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from where ID=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行，打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口</p><p>比如我们这个例子中的表T中，D字段没有索引那么执行器的执行流程是这样的：</p><ul><li>调用InnoDB引擎接口取这个表的第一行，判断D值是不是10，如果不是则跳过，如果是则将这行存在结果集中</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端至此，这个语句就执行完成了。</li></ul><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的你会在数据库的慢查询日志中看到一个 rows examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rowsexamined并不是完全相同的。我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一条SQL查询语句如何执行&quot;&gt;&lt;a href=&quot;#一条SQL查询语句如何执行&quot; class=&quot;headerlink&quot; title=&quot;一条SQL查询语句如何执行&quot;&gt;&lt;/a&gt;一条SQL查询语句如何执行&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://test-1874</summary>
      
    
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>4.HashMap实现原理</title>
    <link href="https://leslieaibin.github.io/2021/09/05/Collection/4.HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
    <id>https://leslieaibin.github.io/2021/09/05/Collection/4.HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</id>
    <published>2021-09-04T16:15:42.000Z</published>
    <updated>2021-09-24T03:46:08.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HashMap是Java中对Map接口的实现类，是最常用的实现类中之一。主要有以下几个特性：</p><ul><li>HashMap中的key 和 value 都允许为null， 但最多智能拥有一个null的key</li><li>HashMap不保证顺序性</li><li>HashMap非线性安全</li></ul><p>HashMap的数据结构：</p><p>HashMap内部是以数组+链表的方式存储的数据。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210904213431065.png" alt="image-20210904213431065"></p><p>HashMap的数组中，每个元素称之为“<strong>桶</strong>”。需要注意的是，这个“桶”并不等同于“键值对（Entity）”。至于它是什么请往下看。</p><p><strong>初始化</strong></p><p>HashMap在初始化时会创建一个Entity的数组。其个数为<strong>16</strong>。其源码类似下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中key和value不必多说，不过它还包含了一个next属性，这说明它可以组织成一个链表结构。</p><p><strong>put()方法</strong></p><p>put方法被调用时，HashMap会根据key计算出对应的hashcode，然后根据hashcode确定该Entity应该存放在数组的哪个位置（应该放在哪个桶里）。</p><p>这种设定有一个问题：实际引用中有可能会发生hash碰撞（即两个数据虽然内容不同，但其hashcode有可能是相同的）！因此，HashMap如果发现hashcode已经存在，则会对key进行euqals对比：</p><ul><li>equals结果是true，则认为确实是同一个key，然后将新的value覆盖旧的value（此时put方法将会返回旧value值）。</li><li>equals结果是false，则认为是hash碰撞，此时会将之前的Entity作为新Entity的next，此时形成一个链表，新Entity则处在链表的首位。</li></ul><p>因此，所谓的<strong>“桶”就是数组每个位置放置的“链表”</strong>。</p><p><strong>get()方法</strong></p><p>如果理解了上述的put逻辑，则get方法就很容易理解。主要有以下几个步骤：</p><ul><li>根据key计算hashcode，然后得出其数组下标（位置）。</li><li>去对应位置获取桶（链表）。</li><li>从头到尾遍历链表的每一个Entity，通过equals方法找到对应的Entity。</li><li></li></ul><p>上述的过程中有一个点未详细说明：<strong>如何根据key的hashcode计算出对应的数组坐标呢？</strong></p><p>HashMap的内部实现用了一个非常巧妙的方法。HashMap的初始容量被定为<strong>16</strong>，且每次增长都是2的倍数。这样设计的目的是要<strong>保证存入map中的元素尽量分散</strong>，尽量避免出现桶中出现链表，这可以有效降低数据查询时的处理速度。</p><p>key是这么一步步转化成数组下标的：</p><p>第一步：Object Key –&gt; int hash</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果key是null，则其hash为0；否则便将 <strong>hashcode</strong> 与 <strong>hashcode的高位</strong> 做 <strong>异或运算</strong>。这是为了尽量避免“低位不变，高位变化”时造成的hash冲突。</p><p>第二步：hash –&gt; i</p><p>上一步计算出的hash是个长度较长的二进制数字，而通常情况下HashMap的底层数组长度（length）较小，因此如果我们进行 <strong>hash % length</strong> 计算，则一定能得到一个下标，且相对比较分散。而在源码中使用了性能更高的算法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (length - 1) &amp; hash</span><br></pre></td></tr></table></figure><p>这个公式对hash和length进行了<strong>按位与</strong>运算，等价于<strong>取余。</strong></p><h2 id="为什么底层数组的长度总要是2的n次方呢"><a href="#为什么底层数组的长度总要是2的n次方呢" class="headerlink" title="为什么底层数组的长度总要是2的n次方呢"></a>为什么底层数组的长度总要是2的n次方呢</h2><p>这时就能说清楚另外一件事情：<strong>为什么底层数组的长度总要是2的n次方呢？</strong></p><p>下图是个示例：</p><p><img src="https://pic2.zhimg.com/80/v2-417a388c7b8ae370fc1ede9e854e54a5_720w.jpg" alt="img"></p><p>可以看到，如果数组长度是2的n次方，那么<strong>length-1</strong>的二进制表示中，一定所有位都是<strong>1</strong>，此时取&amp;运算则可以完整保留hash响应位置的二进制数据。相反的，如果数组长度不是2的n次方，则出现hash碰撞的可能性大大提高。</p><h2 id="JDK8中HashMap的改进"><a href="#JDK8中HashMap的改进" class="headerlink" title="JDK8中HashMap的改进"></a>JDK8中HashMap的改进</h2><p>上文曾提到“<strong>桶</strong>”的概念。其实这个概念在JDK8中才是真正有意义的。因为JDK7中，原始数组的每个元素都一定是个链表（链表的节点一个或者多个），而到了JDK8的时候就不一定是链表了。</p><p>JDK8对存储方式进行改进的原因很简单：如果在一个HashMap中，有很多Key发生了碰撞的时候，就会产生一个超级长的链表。那么在数据查询的时候就会花费O(n)的时间。所以，JDK8中HashMap采用了“<strong>桶</strong>+<strong>链表/红黑树</strong>”数据存储方式：如果链表的长度大于等于8时，其内部便会将链表转化为红黑树的结构。红黑树的查询时间是O(log n)。</p><p>由于数据存储方式发生变化，因此列表扩容时也会发生一些变化。具体细节请看下一篇HashMap的扩容。</p><h1 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h1><p>为了方便说明，这里明确几个名词：</p><ul><li>capacity 即容量，默认16。</li><li>loadFactor 加载因子，默认是0.75</li><li>threshold 阈值。阈值=容量*加载因子。默认12。当元素数量超过阈值时便会触发扩容。</li></ul><p><strong>什么时候触发扩容？</strong></p><p>一般情况下，<strong>当元素数量超过阈值时</strong>便会触发扩容。每次扩容的容量都是之前容量的2倍。</p><p>HashMap的容量是有上限的，必须小于<strong>1&lt;&lt;30</strong>，即1073741824。如果容量超出了这个数，则不再增长，且阈值会被设置为<strong>Integer.MAX_VALUE</strong>（2^31^  - 1) ，即永远不会超出阈值了)。</p><h2 id="JDK7中的扩容机制"><a href="#JDK7中的扩容机制" class="headerlink" title="JDK7中的扩容机制"></a><strong>JDK7中的扩容机制</strong></h2><p>JDK7的扩容机制相对简单，有以下特性：</p><ul><li>空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是<strong>空数组</strong>。</li><li>有参构造函数：根据参数确定容量、负载因子、阈值等。</li><li>第一次put时会初始化数组，其容量变为<strong>不小于指定容量的2的幂数</strong>。然后根据负载因子确定阈值。</li><li>如果不是第一次扩容，则 <img src="https://www.zhihu.com/equation?tex=%E6%96%B0%E5%AE%B9%E9%87%8F=%E6%97%A7%E5%AE%B9%E9%87%8F%5Ctimes2" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=%E6%96%B0%E9%98%88%E5%80%BC=%E6%96%B0%E5%AE%B9%E9%87%8F%5Ctimes%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90" alt="[公式]"> 。</li></ul><h2 id="JDK8的扩容机制"><a href="#JDK8的扩容机制" class="headerlink" title="JDK8的扩容机制"></a><strong>JDK8的扩容机制</strong></h2><p>JDK8的扩容做了许多调整。</p><p>HashMap的容量变化通常存在以下几种情况：</p><ol><li>空参数的构造函数：实例化的HashMap默认内部数组是null，即没有实例化。第一次调用put方法时，则会开始第一次初始化扩容，长度为16。</li><li>有参构造函数：用于指定容量。会根据指定的正整数找到<strong>不小于指定容量的2的幂数</strong>，将这个数设置赋值给<strong>阈值</strong>（threshold）。第一次调用put方法时，会将阈值赋值给容量，然后让 <img src="https://www.zhihu.com/equation?tex=%E9%98%88%E5%80%BC=%E5%AE%B9%E9%87%8F%5Ctimes%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90" alt="[公式]"> 。（因此并不是我们手动指定了容量就一定不会触发扩容，超过阈值后一样会扩容！！）</li><li>如果不是第一次扩容，则容量变为原来的2倍，阈值也变为原来的2倍。<em>（容量和阈值都变为原来的2倍时，负载因子还是不变）</em></li></ol><p>此外还有几个细节需要注意：</p><ul><li>首次put时，先会触发扩容（算是初始化），然后存入数据，然后判断是否需要扩容；</li><li>不是首次put，则不再初始化，直接存入数据，然后判断是否需要扩容；</li></ul><h2 id="JDK7的元素迁移"><a href="#JDK7的元素迁移" class="headerlink" title="JDK7的元素迁移"></a><strong>JDK7的元素迁移</strong></h2><p>JDK7中，HashMap的内部数据保存的都是链表。因此逻辑相对简单：在准备好新的数组后，map会遍历数组的每个“桶”，然后遍历桶中的每个Entity，重新计算其hash值（也有可能不计算），找到新数组中的对应位置，以<strong>头插法</strong>插入新的链表。</p><p>这里有几个注意点：</p><ul><li>是否要重新计算hash值的条件这里不深入讨论，读者可自行查阅源码。</li><li>因为是头插法，因此新旧链表的元素位置会发生转置现象。</li><li>元素迁移的过程中在多线程情境下有可能会触发死循环（无限进行链表反转）。</li></ul><h2 id="JDK8的元素迁移"><a href="#JDK8的元素迁移" class="headerlink" title="JDK8的元素迁移"></a><strong>JDK8的元素迁移</strong></h2><p>JDK8则因为巧妙的设计，性能有了大大的提升：由于数组的容量是以2的幂次方扩容的，那么一个Entity在扩容时，新的位置要么在<strong>原位置</strong>，要么在<strong>原长度+原位置</strong>的位置。原因如下图：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-da2df9ad67181daa328bb09515c1e1c8_720w.png" alt="img"></p><p>数组长度变为原来的2倍，表现在二进制上就是<strong>多了一个高位参与数组下标确定</strong>。此时，一个元素通过hash转换坐标的方法计算后，恰好出现一个现象：最高位是0则坐标不变，最高位是1则坐标变为“10000+原坐标”，即“原长度+原坐标”。如下图：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-ac1017eb1b83ce5505bfc032ffbcc29a_720w.jpg" alt="img"></p><p>因此，在扩容时，不需要重新计算元素的hash了，只需要判断最高位是1还是0就好了。</p><p>JDK8的HashMap还有以下细节：</p><ul><li>JDK8在迁移元素时是正序的，不会出现链表转置的发生。</li><li>如果某个桶内的元素超过8个，则会将链表转化成红黑树，加快数据查询效率。</li></ul><h2 id="HashMap扩容死循环问题"><a href="#HashMap扩容死循环问题" class="headerlink" title="HashMap扩容死循环问题"></a>HashMap扩容死循环问题</h2><ul><li><p>当插入一个新的键值对时，会根据key对HashMap底层数组长度取模，得到键值对存放的数组下标，然后调用addEntry() 函数把这个键值对插入到这个下标所在的链表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key , V value, <span class="keyword">int</span> bucketIndex)</span></span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key , value, e);</span><br><span class="line">    <span class="keyword">if</span>(size++ &gt;= threshold)<span class="comment">// 如果键值对个数超过hashmap当前的阈值</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length)<span class="comment">// 调整resize()函数进行扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在这个addEntry() 函数中，会判断键值对个数是否超过了HashMap当前容量的阈值，如果超过了，则说明需要扩容，接下来就调用resize() 函数扩容为原来的两倍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">// 创建一个新数组</span></span><br><span class="line">    transfer(newTable);        <span class="comment">// 把老数组中的所有键值对都拷贝到新数组中</span></span><br><span class="line">    table = newTable;        <span class="comment">// 修改老数组的指向，把老数组指向新数组，完成扩容</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resize()函数会先创建一个新数组，然后调用 transfer() 函数把老数组中的所有键值对都拷贝到新数组中，最后修改老数组的指向，把老数组指向新数组，完成扩容。</p><p>扩容过程中会出现循环链表的情况就是多个线程在执行 transfer() 函数导致的，下面看看 transfer() 函数的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;        <span class="comment">// 老数组</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;     <span class="comment">// 新数组的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) <span class="comment">// 遍历老数组，把老数组中所有键值对拷贝到新数组</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];    <span class="comment">// 记录下老数组第 j 个链表，接下来会链表上的键值对都拷贝到新数组</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;        <span class="comment">// 如果链表不为空才需要拷贝</span></span><br><span class="line">            src[j] = <span class="keyword">null</span>;        <span class="comment">// 先老数组第j个链表置为空链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;                <span class="comment">// 循环遍历刚才记录下来的链表，把所有键值对都采用头插法插入到新数组对应链表</span></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;        <span class="comment">// 记录下当前结点的下个结点</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);    <span class="comment">// 求出该键值对在新数组的下标,即该键值对应该被插入到新数组第几个链表</span></span><br><span class="line">                e.next = newTable[i];    <span class="comment">// 把结点的next指针指向新数组的第i个链表头结点</span></span><br><span class="line">                newTable[i] = e;    <span class="comment">// 新数组第i个链表的头结点前移，指向当前结点</span></span><br><span class="line">                e = next;        <span class="comment">// 把指向当前结点的指针后移</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其中最关键的就是其中的 do while()循环，这里面就是会发生循环链表的代码。</p></li></ul><p>现在先走一遍正常扩容的流程,假设有下面这个HashMap, 假设数组大小为2</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1456655-20201211210822148-740596617.png" alt="img"></p><p>现在需要对它进行扩容，扩容后数组大小为原来的两倍，创建一个大小为4的数组</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1456655-20201211210822686-391022651.png" alt="img"></p><p>假设a、b两个数扩容后刚好又hash冲突了，即又在同一个链表中，所在下标为3；c在下标为1的链表中。下面开始扩容。</p><p>e指针指向了老数组的第1个链表</p><h3 id="执行上面的do-while循环，第一轮循环："><a href="#执行上面的do-while循环，第一轮循环：" class="headerlink" title="执行上面的do while循环，第一轮循环："></a>执行上面的do while循环，第一轮循环：</h3><p><a href="https://img2020.cnblogs.com/blog/1456655/202012/1456655-20201211210823926-116268729.png"><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1456655-20201211210823926-116268729.png" alt="img"></a></p><h3 id="第二轮循环："><a href="#第二轮循环：" class="headerlink" title="第二轮循环："></a>第二轮循环：</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1456655-20210820225941991-619872774.png" alt="img"></h3><h3 id="第三轮也是最后一轮循环，前面已经假设结点-c-将在新数组中的第二个链表"><a href="#第三轮也是最后一轮循环，前面已经假设结点-c-将在新数组中的第二个链表" class="headerlink" title="第三轮也是最后一轮循环，前面已经假设结点 c 将在新数组中的第二个链表"></a>第三轮也是最后一轮循环，前面已经假设结点 c 将在新数组中的第二个链表</h3><p><a href="https://img2020.cnblogs.com/blog/1456655/202012/1456655-20201211210826842-959746908.png"><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1456655-20201211210826842-959746908.png" alt="img"></a></p><p>至此，老数组中的健值对已全部拷贝到新数组中</p><h3 id="多线程环境中扩容"><a href="#多线程环境中扩容" class="headerlink" title="多线程环境中扩容"></a>多线程环境中扩容</h3><p>假设在第 二 次循环中的第二步（执行完e.next = newTable[i]；）后当前线程的时间片刚好用完了，当前线程被挂起，这时刚好又有一个线程 P2 也来执行扩容操作，它并不会从第二步开始执行，而是重新从第一步开始执行，加入新线程后的扩容图为</p><p><a href="https://img2020.cnblogs.com/blog/1456655/202012/1456655-20201211210829300-1877613427.png"><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1456655-20201211210829300-1877613427.png" alt="img"></a></p><p>可以看到，线程2扩容之后的newTable中的单链表形成了一个环，后续执行get操作的时候，会触发死循环，引起CPU的100%问题。</p><h1 id="扩容后，元素是如何重新分布的"><a href="#扩容后，元素是如何重新分布的" class="headerlink" title="扩容后，元素是如何重新分布的"></a>扩容后，元素是如何重新分布的</h1><ul><li><p>HashMap的初始化是在插入第一个元素时调用resize() 完成的</p></li><li><p>不指定容量，默认容量为16</p></li><li><p>指定容量也不一定按照你的值来，会经过tableSizeFor转成不小于输入值的2的n次幂</p><p>tableSizeFor<code>转换成2的n次幂不是直接赋值给</code>capacity<code>，而是先将值暂时保存在</code>threshold<code>，见源码</code>457<code>，然后在put第一个元素resize时，婉转的传递给</code>newCap</p></li><li><p>put元素时，元素的位置取决于数组的长度和key的hash值按位与的结果 <code>i = (n - 1) &amp; hash</code></p></li><li><p>如果这里没有元素直接放在这里</p></li><li><p>如果有，判断是不是键冲突，如果一样就新值覆盖旧值</p></li><li><p>如果有且不是键冲突，则将其放在元素的next位置，判断元素长度是否大于8，大于8进行树化</p></li><li><p>只有当size大于了扩容阈值 <code>size &gt; threshold</code>， 才会触发扩容，扩容前，当前元素已经放好了</p></li><li><p>扩容时，容量和扩容阈值都翻倍，必须小于 1&lt;&lt;30</p></li><li><p>扩容时，元素在新表中的位置分情况</p></li><li><p>当元素只是孤家寡人即元素的next==null时，位置为e.hash &amp; (newCap - 1)</p></li><li><p>当元素有next节点时，该链表上的元素分两类</p><ul><li> e.hash &amp; oldCap = 0的，在新表中与旧表中的位置一样</li><li> e.hash &amp; oldCap != 0的，位置为旧表位置+旧表容量</li></ul></li><li><p>当前节点时树的话</p><ul><li>(e.hash &amp; bit) == 0 在新表中与旧表中的位置一样</li><li>(e.hash &amp; bit) != 0  位置为旧表位置+旧表容量</li><li>在新的newCap中，判断阶段如果节点数小于6进行树退化，重新树化</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HashMap的实现原理&quot;&gt;&lt;a href=&quot;#HashMap的实现原理&quot; class=&quot;headerlink&quot; title=&quot;HashMap的实现原理&quot;&gt;&lt;/a&gt;HashMap的实现原理&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;</summary>
      
    
    
    
    <category term="Collection" scheme="https://leslieaibin.github.io/categories/Collection/"/>
    
    
    <category term="Collection" scheme="https://leslieaibin.github.io/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>02.索引</title>
    <link href="https://leslieaibin.github.io/2021/09/04/MySQL/02.%E7%B4%A2%E5%BC%95/"/>
    <id>https://leslieaibin.github.io/2021/09/04/MySQL/02.%E7%B4%A2%E5%BC%95/</id>
    <published>2021-09-04T12:17:42.000Z</published>
    <updated>2021-09-04T08:47:40.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是一个单独的，存储在磁盘上的数据结构，包含着对数据表里所有记录的引用指针，使用索引可以快速记录找出在某个或多个列中有一特定值的行，所有MySQL列数据都可以被索引，所有MySQL列类型都可以被索引，对相关列使用时提高查询操作速度的最佳途径。</p><p>索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。MySQL中索引的存储类型有两种，即BTREE和HASH，具体和表的存储引擎相关。<strong>MyISAM和InnoDB存储引擎只支持BTREE索引；MEMORY/HEAP存储引擎可以支持HASH和BTREE索引。</strong></p><p>优点：</p><ul><li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性</li><li>可以大大加快数据的查询速度，这也是创建索引的主要原因</li><li>在实现数据的参考完整性方面，可以加速表和表之间的连接</li><li>在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间。</li></ul><p>缺点：</p><ul><li>创建索引和维护索引需要耗费时间，并且随着数据量的增加所耗费的时间也会增加</li><li>索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li></ul><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</p><p>按物理存储分类可分为：<strong>聚簇索引、二级索引（辅助索引）</strong>。</p><p>按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong>。</p><p>按字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引）</strong>。</p><h3 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h3><p>MySQL索引按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</p><table><thead><tr><th>-</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Hash索引</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Full-text索引</td><td>√（MySQL5.6+）</td><td>√</td><td>×</td></tr></tbody></table><p><strong>B+tree</strong> 是MySQL中被存储引擎采用最多的索引类型。<strong>B+tree</strong> 中的 <code>B</code> 代表平衡（balance），而不是二叉（binary），因为 <strong>B+tree</strong> 是从最早的平衡二叉树演化而来的。下面展示B+tree数据结构与其他数据结构的对比。</p><h4 id="B-tree与B-tree的对比"><a href="#B-tree与B-tree的对比" class="headerlink" title="B+tree与B-tree的对比"></a><strong>B+tree与B-tree的对比</strong></h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000037684393" alt="B-tree结构（图片来源于网络）"></p><p><strong>相对于B-tree，B+tree有以下两点不同：</strong></p><ul><li>B+tree 非叶子节点只存储键值信息， 数据记录都存放在叶子节点中。而B-tree的非叶子节点也存储数据。所以B+tree单个节点的数据量更小，在相同的磁盘I/O次数下，能查询更多的节点。</li><li>B+tree 所有叶子节点之间都采用<strong>双向链表</strong>连接。适合MySQL中常见的基于范围的顺序检索场景，而B-tree无法做到这一点。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000037684392" alt="B+tree结构（图片来源于网络）"></p><h4 id="B-tree与红黑树的对比"><a href="#B-tree与红黑树的对比" class="headerlink" title="B+tree与红黑树的对比"></a>B+tree与红黑树的对比</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000037684042" alt="红黑树结构（图片来源于网络）"></p><p><strong>红黑树</strong>是一种<strong>弱平衡二叉查找树</strong>。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，<strong>红黑树确保没有一条路径会比其他路径长出两倍</strong>。</p><p>对于有N个叶子结点的 <strong>B+tree</strong>，其搜索复杂度为 <code>O(logdN)</code> ，其中 <strong>d</strong>(degree) 为 <strong>B+tree</strong> 的度，表示节点允许的最大子节点个数为<strong>d</strong>个，在实际应用当中，<strong>d</strong>值一般是大于100的，即使数据量达到千万级别时<strong>B+tree</strong>的高度依然维持在3-4左右，保证了3-4次磁盘I/O操作就能查询到目标数据。</p><p><strong>红黑树</strong>是二叉树，节点子节点个数为两个，意味着其搜索复杂度为 <code>O(logN)</code>，树的高度也会比 <strong>B+tree</strong> 高出不少，因此<strong>红黑树</strong>检索到目标数据所需经历的磁盘I/O次数更多。</p><h4 id="B-tree与Hash的对比"><a href="#B-tree与Hash的对比" class="headerlink" title="B+tree与Hash的对比"></a>B+tree与Hash的对比</h4><p>Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。 Hash 索引仅仅能满足 <code>=</code> , <code>IN</code> 和 <code>&lt;=&gt;</code>(表示NULL安全的等价) 查询，不能使用范围查询。</p><p>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</p><ul><li>Hash 索引无法适用数据的排序操作。</li><li>Hash 索引不能利用部分索引键查询</li><li>Hash 索引依然需要回表扫描。</li><li>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</li></ul><p><strong>由于范围查询是MySQL数据库查询中常见的场景，Hash表不适合做范围查询，它更适合做等值查询。另外Hash表还存在Hash函数选择和Hash值冲突等问题。因此，B+tree索引要比Hash表索引有更广的适用场景。</strong></p><h3 id="按照物理存储分类"><a href="#按照物理存储分类" class="headerlink" title="按照物理存储分类"></a>按照物理存储分类</h3><p>MySQL索引按叶子节点存储的是否为完整表数据分为：<strong>聚簇索引、二级索引（辅助索引）</strong>。全表数据存储在聚簇索引中，聚簇索引以外的其他索引叫做二级索引，也叫辅助索引。</p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引的每个叶子节点存储了一行完整的表数据，叶子节点间按id列递增连接，可以方便地进行顺序检索。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000037688814" alt="聚簇索引B+tree示意图（图片来源于网络）"><br>（图片来源于网络）</p><p>InnoDB表要求必须有聚簇索引，默认在主键字段上建立聚簇索引，在没有主键字段的情况下，表的第一个非空的唯一索引将被建立为聚簇索引，在前两者都没有的情况下，InnoDB将自动生成一个隐式的自增id列，并在此列上建立聚簇索引。</p><h5 id="以MyISAM为存储引擎的表不存在聚簇索引。"><a href="#以MyISAM为存储引擎的表不存在聚簇索引。" class="headerlink" title="以MyISAM为存储引擎的表不存在聚簇索引。"></a>以MyISAM为存储引擎的表不存在聚簇索引。</h5><p>MyISAM表中的主键索引和非主键索引的结构是一样的，索引的叶子节点不存储表数据，存放的是表数据的地址。所以，MyISAM表可以没有主键。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000037688815" alt="MyISAM索引B+tree示意图（图片来源于网络）"><br>（图片来源于网络）</p><p>MyISAM表的数据和索引是分开存储的。MyISAM表的主键索引和非主键索引的区别仅在于主键索引的B+tree上的key必须符合主键的限制，非主键索引B+tree上的key只要符合相应字段的特性就可以了。</p><h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>二级索引的叶子节点并不存储一行完整的表数据，而是存储了聚簇索引所在列的值。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000037688816" alt="二级索引B+tree示意图（图片来源于网络）"><br>（图片来源于网络）</p><h5 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h5><p>由于二级索引的叶子节点不存储完整的表数据，索引当通过二级索引查询到聚簇索引列值后，还需要回到聚簇索引也就是表数据本身进一步获取数据。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000037688817" alt="回表查询示意图（图片来源于网络）"><br>（图片来源于网络）</p><p>回表查询 需要额外的 <strong>B+tree</strong> 搜索过程，必然增大查询耗时。</p><p>需要注意的是，<strong>通过二级索引查询时，回表不是必须的过程</strong>，当<strong>SELECT的所有字段在单个二级索引中都能够找到</strong>时，就不需要回表，MySQL称此时的二级索引为<strong>覆盖索引</strong>或触发了<strong>索引覆盖</strong>。<br>可以用Explain命令查看SQL语句的执行计划，执行计划的Extra字段中若出现<strong>Using index</strong>，表示查询触发了<strong>索引覆盖</strong>。</p><h3 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h3><p>MySQL索引按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong>。</p><ul><li><strong>主键索引</strong></li></ul><p>建立在主键上的索引被称为<strong>主键索引</strong>，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。</p><ul><li><strong>唯一索引</strong></li></ul><p>建立在UNIQUE字段上的索引被称为<strong>唯一索引</strong>，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。</p><ul><li><strong>普通索引</strong></li></ul><p>建立在普通字段上的索引被称为<strong>普通索引</strong>。</p><ul><li><strong>前缀索引</strong></li></ul><p><strong>前缀索引</strong>是指对字符类型字段的前几个字符或对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引。前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。</p><h3 id="按索引字段个数分类"><a href="#按索引字段个数分类" class="headerlink" title="按索引字段个数分类"></a>按索引字段个数分类</h3><p>MySQL索引按字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引）</strong>。</p><ul><li>单列索引</li></ul><p>建立在单个列上的索引被称为单列索引。</p><ul><li>联合索引（复合索引、组合索引）</li></ul><p>建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。</p><h2 id="聚簇索引和非聚簇索引有什么区别"><a href="#聚簇索引和非聚簇索引有什么区别" class="headerlink" title="聚簇索引和非聚簇索引有什么区别"></a>聚簇索引和非聚簇索引有什么区别</h2><p>在InnoDB存储引擎中，可以将B+树索引分为聚簇索引和辅助索引（非聚簇索引）。无论是何种索引，每个页的大小都为16KB，且不能更改。</p><p>聚簇索引是根据主键创建的一棵B+树，聚簇索引的叶子节点存放了表中的所有记录。辅助索引是根据索引键创建的一棵B+树，与聚簇索引不同的是，其叶子节点仅存放索引键值，以及该索引键值指向的主键。也就是说，如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚簇索引来得到数据，这种查找方式又被称为书签查找。因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于聚簇索引。</p><h2 id="索引的实现原理"><a href="#索引的实现原理" class="headerlink" title="索引的实现原理"></a>索引的实现原理</h2><p>在MySQL中，索引是在存储引擎层实现的，不同存储引擎对索引的实现方式是不同的，下面我们探讨一下MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h3 id="MyISAM索引实现："><a href="#MyISAM索引实现：" class="headerlink" title="MyISAM索引实现："></a>MyISAM索引实现：</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址，MyISAM索引的原理图如下。这里假设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/index-1.png" alt="img"></p><p>如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示。同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/index-2.png" alt="img"></p><h3 id="InnoDB索引实现："><a href="#InnoDB索引实现：" class="headerlink" title="InnoDB索引实现："></a>InnoDB索引实现：</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p>下图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/index-3.png" alt="img"></p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。下图为定义在Col3上的一个辅助索引。这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/index-4.png" alt="img"></p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;h2 id=&quot;什么是索引&quot;&gt;&lt;a href=&quot;#什么是索引&quot; class=&quot;headerlink&quot; title=&quot;什么是索引&quot;&gt;&lt;/a&gt;什么是索</summary>
      
    
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>01.事务的隔离性</title>
    <link href="https://leslieaibin.github.io/2021/09/04/MySQL/01.%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/"/>
    <id>https://leslieaibin.github.io/2021/09/04/MySQL/01.%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/</id>
    <published>2021-09-04T11:17:42.000Z</published>
    <updated>2021-09-04T08:47:01.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><p>MySQL事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除该人员相关的信息，如信箱、文章等等，这样，这些数据库操作语句就构成一个事务</p><ul><li>在MySql中只有使用了Innodb数据库引擎的数据库或表才支持事务</li><li>事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行</li><li>事务用来管理insert、update、delete语句</li></ul><p>一般来说，事务是必须满足四个条件（ACID）：</p><ul><li>原子性（Atomicity）：一个事务中的所有操作要么全部完成，要么全部不完成，不会在结束中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</li><li>一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的数据必须完全符合所有的预设规则，这包含资料的精度，串联性以及后续数据库可以自发性地完成预定的工作</li><li>隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>持久性（Durability）：事务处理结束后，对数据的修改是永久的，即使系统故障也不会丢失。</li></ul><p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</p><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，但并不是所有引擎都支持事务。比如MySQL原生的MyISAM引擎不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。</p><h1 id="隔离性和隔离级别"><a href="#隔离性和隔离级别" class="headerlink" title="隔离性和隔离级别"></a>隔离性和隔离级别</h1><p>当数据库上多个事务同时执行的时候就可能出现脏读（dirty read)、不可重复读（nonrepeatable read)、幻读（phantom read)等问题。</p><ul><li><p><strong>脏读（读取未提交数据）</strong></p><p>A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于B事务更改了它，这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据，但事务B良心发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务A却什么都不知道，最终结果就是事务A读取了此次的脏数据，称为脏读。</p></li><li><p><strong>不可重复读（前后多次读取，数据内容不一致）</strong></p><p>事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读</p></li><li><p><strong>幻读（前后多次读取，数据总量不一致）</strong></p><p>事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。</p></li></ul><h2 id="SQL标准的事务隔离级别包括："><a href="#SQL标准的事务隔离级别包括：" class="headerlink" title="SQL标准的事务隔离级别包括："></a>SQL标准的事务隔离级别包括：</h2><ul><li>读未提交（read committed）： 一个事务还没提交，让做的变更就能被其他事务看到</li><li>读提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到</li><li>可重复读（repeatable read）： 一个事务执行过程中看到的数据，总跟这个事务启动时看到的数据是一值的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化：对于同一行记录，写会加“写锁”，读会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等待前一个事务执行完成，才能继续执行</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210904144955378.png" alt="image-20210904144955378"></p><ul><li>若隔离级别是”读未提交”：则V1的值就是2。 这时候事务B虽然还没有提交， 但是结果已经被A看到了。 因此， V2、 V3也都是2  </li><li>若隔离级别是”读提交”:  则V1是1， V2的值是2。 事务B的更新在提交后才能被A看到。 所以，V3的值也是2。  </li><li>若隔离级别是”可重复读”：则V1、 V2是1， V3是2。 之所以V2还是1， 遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的  </li><li>若隔离级别是”串行化”：则在事务B执行“将1改成2”的时候， 会被锁住。 直到事务A提交后，事务B才可以继续执行。 所以从A的角度看， V1、 V2值是1， V3的值是2。  </li></ul><table><thead><tr><th>隔离级别</th><th>脏读（Dirty Read）</th><th>不可重复读（NonRepeatable Read）</th><th>幻读（Phantom Read）</th></tr></thead><tbody><tr><td>未提交读（Read uncommitted）</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>已提交读（Read committed）</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读（Repeatable read）</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>可串行化（Serializable ）</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><p>在实现上， 数据库里面会创建一个视图， 访问的时候以视图的逻辑结果为准。 在“可重复读”隔离级别下， 这个视图是在事务启动时创建的， 整个事务存在期间都用这个视图。 在“读提交”隔离级<br>别下， 这个视图是在每个SQL语句开始执行的时候创建的。 这里需要注意的是， “读未提交”隔离<br>级别下直接返回记录上的最新值， 没有视图概念； 而“串行化”隔离级别下直接用加锁的方式来避<br>免并行访问。</p><p>我们可以看到在不同的隔离级别下， 数据库行为是有所不同的。 Oracle数据库的默认隔离级别其实就是“读提交”， 因此对于一些从Oracle迁移到MySQL的应用， 为保证数据库隔离级别的一致，<br>你一定要记得将MySQL的隔离级别设置为“读提交”。配置的方式是， 将启动参数transaction-isolation的值设置成READ-COMMITTED。 你可以用show variables来查看当前的值。  </p><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>在MySQL中， 实际上每条记录在更新的时候都会同时记录一条回滚操作。 记录上的最新值， 通<br>过回滚操作， 都可以得到前一个状态的值。假设一个值从1被按顺序改成了2、 3、 4， 在回滚日志里面就会有类似下面的记录。  </p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210904150457737.png" alt="image-20210904150457737"></p><p>当前值是4， 但是在查询这条记录的时候， 不同时刻启动的事务会有不同的read-view。 如图中看到的， 在视图A、 B、 C里面， 这一个记录的值分别是1、 2、 4， 同一条记录在系统中可以存在多<br>个版本， 就是数据库的多版本并发控制（MVCC） 。 对于read-view A， 要得到1， 就必须将当前<br>值依次执行图中所有的回滚操作得到。</p><p>同时你会发现， 即使现在有另外一个事务正在将4改成5， 这个事务跟read-view A、 B、 C对应的事务是不会冲突的。</p><p>你一定会问， 回滚日志总不能一直保留吧， 什么时候删除呢？ 答案是， 在不需要的时候才删除。也就是说， 系统会判断， 当没有事务再需要用到这些回滚日志时， 回滚日志会被删除。</p><p>什么时候才不需要了呢？ 就是当系统里没有比这个回滚日志更早的read-view的时候。</p><p>基于上面的说明， 我们来讨论一下为什么建议你尽量不要使用长事务  </p><p>长事务意味着系统里面会存在很老的事务视图。 由于这些事务随时可能访问数据库里面的任何数据， 所以这个事务提交之前， 数据库里面它可能用到的回滚记录都必须保留， 这就会导致大量占<br>用存储空间。</p><p>在MySQL 5.5及以前的版本， 回滚日志是跟数据字典一起放在ibdata文件里的， 即使长事务最终<br>提交， 回滚段被清理， 文件也不会变小。 我见过数据只有20GB， 而回滚段有200GB的库。 最终<br>只好为了清理回滚段， 重建整个库。</p><h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>如前面所述， 长事务有这些潜在风险， 我当然是建议你尽量避免。 其实很多时候业务开发同学并不是有意使用长事务， 通常是由于误用所致。 MySQL的事务启动方式有以下几种：</p><ul><li>显式启动事务语句， begin 或 start transaction。 配套的提交语句是commit， 回滚语句是<br>rollback。</li><li>set autocommit=0， 这个命令会将这个线程的自动提交关掉。 意味着如果你只执行一个<br>select语句， 这个事务就启动了， 而且并不会自动提交。 这个事务持续存在直到你主动执行commit 或 rollback 语句， 或者断开连接  </li></ul><p>有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。 这就导致接下来的<br>查询都在事务中， 如果是长连接， 就导致了意外的长事务。</p><p>因此， 我会建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL事务&quot;&gt;&lt;a href=&quot;#MySQL事务&quot; class=&quot;headerlink&quot; title=&quot;MySQL事务&quot;&gt;&lt;/a&gt;MySQL事务&lt;/h1&gt;&lt;p&gt;MySQL事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需</summary>
      
    
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="https://leslieaibin.github.io/2021/09/01/Redis/Redis%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
    <id>https://leslieaibin.github.io/2021/09/01/Redis/Redis%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</id>
    <published>2021-09-01T01:15:42.000Z</published>
    <updated>2021-09-01T08:37:09.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis是一个使用C语言写成，凯源的高性能key-value非关系缓存数据库。他支持存储的value类型比较多，包括String(字符串)、list(集合)、set(集合)、zset(sorted-set–有序集合) 和 hash (哈希类型）。Redis都是基于缓存的，所以很快，每秒都可以处理10万读写操作，是一直性能最好的key-value DB。redis也可以实现数据写入磁盘中，保证了数据的安全不丢失，而且redis的操作时原子性的</p><h2 id="Redis-有那些优缺点"><a href="#Redis-有那些优缺点" class="headerlink" title="Redis 有那些优缺点"></a>Redis 有那些优缺点</h2><p>优点：</p><ul><li>读写性能优异，redis能读的速度是110000次/s，写的速度是810000次/s</li><li>支持数据持久化，支持AOF和RDB两种持久化方式</li><li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操控台合并的原子执行</li><li>数据结构丰富，除了支持String类型的value 外还支持hash、set、zset、list等数据结构</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离</li></ul><p>缺点：</p><ul><li><p>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p></li><li><p>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</p></li><li><p>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</p></li><li><p>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</p></li></ul><h2 id="使用redis-有哪些好处"><a href="#使用redis-有哪些好处" class="headerlink" title="使用redis 有哪些好处"></a>使用redis 有哪些好处</h2><ul><li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势在于查找和操作的时间复杂度低</li><li>支持丰富数据类型，支持String，list，set，zset， hash</li><li>支持事务，操作都是原子性</li><li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后自动删除</li></ul><h2 id="为什么要用-Redis-而不用-map-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map/guava 做缓存?"></a>为什么要用 Redis 而不用 map/guava 做缓存?</h2><ul><li>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</li><li>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</li></ul><h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><ul><li>完全基于内存，绝大部分请求内存操作，影响速度的内存和网络速度，而非CPU</li><li>数据结构简单：Redis的数据结构是为自身专门量身打造的，而这些数据结构查找和操作的时间复杂度都是O(1)</li><li>避免上下文切换：因为单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的开销，而且单线程不会导致死锁</li><li>多路复用和非阻塞I/O：Redis 使用 I/O 多路复用功能来监听多个 socket 连接客户端，这样就可以使用一个线程来处理多个情况，从而减少线程切换带来的开销，同时也避免了 I/O 阻塞操作，从而大大地提高了 Redis 的性能</li><li>使用底层模型不同，他们之间底层实现方式以及客户端之间通信的应用协议不一样，Redis直接构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定时间去移动和请求</li></ul><h2 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a>Redis有哪些数据类型</h2><ul><li>Redis主要有5种数据类型，包括String、List、Set、Zset、Hash满足大部分使用要求</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210901105110111.png" alt="image-20210901105110111"></p><h2 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h2><ul><li><p>计数器</p><p>可以对String 进行自增自减运算，从而实现计数器功能。Redis这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量</p></li><li><p>缓存</p><p>将热点数据放到内存中，设置内存的最大使用两以及淘汰策略来保证缓存的命中率</p></li><li><p>会话缓存</p><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p></li><li><p>全页缓存 FPC</p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p></li><li><p>查找表</p><p>例如DNS记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p></li><li><p>消息队列（发布/订阅功能）</p><p>List是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p></li><li><p>分布式锁实现</p><p>在分布式场景下，无法使用单机环境下的锁来多个节点上的进程进行同步。可以使用Redis自带的SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p></li><li><p>其他</p><p>Set 可以实现交集，并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p></li></ul><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ul><li>什么是Redis 持久化 持久化就是把内存的数据写到磁盘中区，防止服务器宕机了内存数据丢失</li></ul><h2 id="Redis-的持久化机制是什么？-各自的优缺点？"><a href="#Redis-的持久化机制是什么？-各自的优缺点？" class="headerlink" title="Redis 的持久化机制是什么？ 各自的优缺点？"></a>Redis 的持久化机制是什么？ 各自的优缺点？</h2><ul><li>Redis 提供两种持久话机制RDB(默认) 和 AOF 机制：</li></ul><p><strong>RDB：是Redis DataBase缩写快照</strong></p><ul><li>RDB是Redis默认的持久化方式，按照一定时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件dumb.rdb。通过配置文件中的save参数来定义快照的周期</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1717449419419e78~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>优点：</p><ul><li>只有一个文件dumb.rdb，方便持久化</li><li>容灾性好，一个文件可以保存到安全的磁盘</li><li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化，使用单子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能</li><li>相对于数据集大时，比AOF的启动效率更高</li></ul><p>缺点：</p><ul><li>数据安全性低，RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失，所以这种方式更是华数据要求不严谨的时候</li><li>AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。</li></ul><p><strong>AOF：持久化</strong></p><ul><li>AOF持久化（即Append Only File 持久化）， 则是将Redis 执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志文件恢复数据</li><li>当两种方式同时开启，数据恢复Redis会有限选择AOF恢复</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/171744941b1f2a80~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>优点：</p><ul><li>数据安全，aof持久化可以配置appendfsync属性，有always，每进行一次命令操作就记录在aof文件中一次</li><li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li></ul><p>缺点：</p><ul><li>AOF文件比RDB文件大，且恢复速度慢</li><li>数据集大的时候，比RDB启动效率低</li></ul><p>两种持久化的优缺点是什么</p><ul><li>AOF文件比RDB更新频率高，优先使用AOF还原数据</li><li>AOF比RDB更安全也更大</li><li>RDB性能比AOF好</li><li>如果两个都配了有限加载AOF</li></ul><h2 id="如果选择合适的持久化方式"><a href="#如果选择合适的持久化方式" class="headerlink" title="如果选择合适的持久化方式"></a>如果选择合适的持久化方式</h2><ul><li><p>一般来说，如果想达到足以媲美PostgreSQL的安全性，你应该同时使用两种持久化功能，在这种情况下，当Redis重启的时候回有限载入AOF文件来恢复原始数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据要完整</p></li><li><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</p></li><li><p>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</p></li><li><p>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</p></li></ul><h2 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h2><ul><li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li><li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li></ul><h2 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h2><p>Redis是Key - value数据库，我们可以设置Redis中缓存的key的过期时间，Redis的过期缓存策略就是指当 Redis 中缓存的key过期了，Redis如何处理，通常有三种：</p><ul><li><p>定时过期：每个 设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据对内存很友好，但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的相同和吞吐量</p></li><li><p>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p></li><li><p>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p></li></ul><p>  Redis中同时使用了惰性过期和定期过期两种过期策略。</p><h2 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h2><ul><li>expire和persist命令。</li></ul><h2 id="我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h2><ul><li>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<ul><li>定时去清理过期的缓存；</li><li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li></ul></li></ul><p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><h2 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h2><ul><li>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</li></ul><h2 id="Redis的内存淘汰策略有哪些"><a href="#Redis的内存淘汰策略有哪些" class="headerlink" title="Redis的内存淘汰策略有哪些"></a>Redis的内存淘汰策略有哪些</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</span><br></pre></td></tr></table></figure><ul><li>全局的键空间选择性移除<ul><li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li></ul></li><li>设置过期时间的键空间选择性移除<ul><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li></ul></li><li>总结</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</span><br></pre></td></tr></table></figure><h2 id="Redis主要消耗什么物理资源？"><a href="#Redis主要消耗什么物理资源？" class="headerlink" title="Redis主要消耗什么物理资源？"></a>Redis主要消耗什么物理资源？</h2><ul><li>内存。</li></ul><h2 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h2><ul><li>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</li></ul><h2 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h2><ul><li>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</li></ul><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><ul><li>Redis基于Reactor模式开发了网络事件处理器，这个事件处理器称为文件事件处理器（file event handler)。它的组成结构分为四部分：多个套接字，IO多路复用程序，文件事件分派器，时间处理器。因为文件分派器队列的消费是单线程的，所以Redis是单线程模型</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210901152454724.png" alt="image-20210901152454724"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210901152509838.png" alt="image-20210901152509838"></p><ul><li>文件事件处理器使用IO多路复用程序同时监听套接字，并根据套接字目前执行的任务为套接字关联不同的时间处理器。</li><li>当被监听的套接字准备好执行连接应答（accept），读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事假处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行，但通过使用IO多路复用程序来监听多个套接字，文件事件处理器实现了高性能的网络通信模型，又可以很好地与redis服务器中其他 以单线程方式运行的模块进行对接，保持了redis内部单线程设计的简单性</p><p>时间事件：时间事件记录着那些在指定时间点运行的事件，多个时间事件以无序链表结构保存在服务器状态中。服务器需要定期对自身的资源和状态进行检查、整理， 保证服务器维持在一个健康稳定状态， 这类操作被统称为常规操作（cron job）。在 Redis 中， 常规操作由 redis.c/serverCron 实现，包括如下操作： - 更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等 - 清理数据库中的过期键值对 - 对不合理的数据库进行大小调整 - 关闭和清理连接失效的客户端 - 尝试进行 AOF 或RDB 持久化操作 - 如果服务器是主节点的话，对附属节点进行定期同步 - 如果处于集群模式的话，对集群进行定期同步和连接测试。Redis 将 serverCron（后文简称为sC） 作为时间事件运行， 确保它能够定期自动运行一次，又因 sC 需要在 Redis 服务器运行期一直定期运行， 所以它是一个循环时间事件：sC 会一直定期执行，直至服务器关闭。  </p><p>两种事件的调度：简单地说， Redis 里面的两种事件呈协作关系， 它们之间包含如下属性： - 一种事件会等待另一种事件执行完后，才开始执行，事件之间不会出现抢占 - 事件处理器先处理文件事件（即处理命令请求），再执行时间事件（调用 sC） - 文件事件的等待时间（类 poll 函数的最大阻塞时间），由距离到达时间最短的时间事件决定。这表明， 实际处理时间事件的时间， 通常会比事件所预定的时间要晚， 延迟时间取决于时间事件执行前， 执行完成文件事件所耗时间。  </p><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><ul><li>事务是一个单独的隔离操作：事务中所有命令都会序列化、按顺序执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</li><li>事务是一个原子操作：事务中的命令要么全部被执行，要门全部都不执行</li></ul><h2 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h2><ul><li>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li><li>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</li></ul><h2 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h2><ul><li>事务开始MULTI</li><li>命令入队</li><li>事务执行EXEC</li></ul><p>事务执行过程中，如果服务端收到EXEC、DISCARD、WATCH、MULTI之外的请求，将会请求放入队列排队</p><h2 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h2><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p><p>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p><ol><li><strong>redis 不支持回滚</strong>，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</li><li><strong>如果在一个事务中的命令出现错误，那么所有的命令都不会执行</strong>；</li><li><strong>如果在一个事务中出现运行错误，那么正确的命令会被执行</strong>。</li></ol><ul><li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li><li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li><li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</li><li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li><li>UNWATCH命令可以取消watch对所有key的监控。</li></ul><h2 id="事务管理（ACID）-概述"><a href="#事务管理（ACID）-概述" class="headerlink" title="事务管理（ACID） 概述"></a>事务管理（ACID） 概述</h2><ul><li><p>原子性（Atomicity）</p><p>原子性是指事务是一个不可分割的工作，要么事务中的操作都发生，要么都不发生</p></li><li><p>一致性（Consistency)</p><p>事务前后数据的完整性必须保持一致</p></li><li><p>隔离性（lsolation）</p><p>多个事务并发执行时，一个事务不影响其他事务的执行</p></li><li><p>持久性（Durability）</p><p>持久性是一个事务一旦被提交的，他对数据库中的数据的改变是永久的，接下来即使数据库发生故障也不应该对其有任何影响</p></li></ul><p>Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在_AOF_持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性</p><h2 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h2><ul><li>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</li></ul><h2 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h2><ul><li>Redis中，单条命令是原子性执行的，但<strong>事务不保证原子性，且没有回滚</strong>。事务中任意命令执行失败，其余的命令仍会被执行。</li></ul><h2 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h2><ul><li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，<br> 其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</li><li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;什么是Redis&quot;&gt;&lt;a href=&quot;#什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;什么是Redis&quot;</summary>
      
    
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>17.锁升级和锁状态</title>
    <link href="https://leslieaibin.github.io/2021/08/30/JVM/17.%E9%94%81%E5%8D%87%E7%BA%A7%E5%92%8C%E9%94%81%E7%8A%B6%E6%80%81/"/>
    <id>https://leslieaibin.github.io/2021/08/30/JVM/17.%E9%94%81%E5%8D%87%E7%BA%A7%E5%92%8C%E9%94%81%E7%8A%B6%E6%80%81/</id>
    <published>2021-08-30T01:15:42.000Z</published>
    <updated>2021-08-30T12:38:16.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>锁的状态总共有四种，级别由低到高依次为：无锁、偏向锁、轻量级锁、重量级锁，这四种锁状态分别代表什么，为什么会有锁升级。在JDK1.6之前，synchronized还是一个重量级锁，是一个效率比较低下的锁，但在JDK1.6后，JVM为了提高锁的获取与释放效率(sychronized) 进行了优化，引入了偏向锁和轻量级锁，从此以后锁的状态就有四种（无锁， 偏向锁， 轻量级锁，重量级锁），并且四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级，也就是说只能进行锁升级（从低级别到高级别），不能锁降级（高级别到低级别），意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p><h1 id="锁的四种状态"><a href="#锁的四种状态" class="headerlink" title="锁的四种状态"></a>锁的四种状态</h1><p>在synchronized最初的实现方式是“阻塞或唤醒一个Java线程需要操作系统切换cpu状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，这种方式就是synchronized实现同步最初的方式，这也是当初开发者诟病的地方，这也是在JDK6以前 synchronized效率低下的原因，JDK6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>所以目前锁状态一种有四种，从级别由低到高依次是：无锁、偏向锁，轻量级锁，重量级锁，锁状态只能升级，不能降级</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000022904666" alt="img"></p><h1 id="锁状态的思路以及特点"><a href="#锁状态的思路以及特点" class="headerlink" title="锁状态的思路以及特点"></a>锁状态的思路以及特点</h1><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000022904667" alt="img"></p><h1 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h1><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000022904669" alt="img"></p><h1 id="Synchronized锁"><a href="#Synchronized锁" class="headerlink" title="Synchronized锁"></a>Synchronized锁</h1><p>synchronized用的锁是存在Java对象头里的，那么什么是对象头</p><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>我们以Hotspot虚拟机为例，Hopspot 对象头主要包括两部分数据：Mark Word（标记字段） 和 Klass Pointer（类型指针）</p><p>Mark Word：默认存储对象的hashcode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>在上面中我们知道了，synchronized 用的锁是存在Java对象头里的，那么具体是存在对象头哪里呢？答案是：存在锁对象的对象头的Mark Word中，那么MarkWord在对象头中到底长什么样，它到底存储了什么呢？</p><p>在64位的虚拟机中：<img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000022904668" alt="img"></p><p>在32位的虚拟机中：<img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000022904670" alt="img"></p><p><strong>无锁 ：</strong>对象头开辟 25bit 的空间用来存储对象的 hashcode ，4bit 用于存放对象分代年龄，1bit 用来存放是否偏向锁的标识位，2bit 用来存放锁标识位为01</p><p><strong>偏向锁：</strong> 在偏向锁中划分更细，还是开辟 25bit 的空间，其中23bit 用来存放线程ID，2bit 用来存放 Epoch，4bit 存放对象分代年龄，1bit 存放是否偏向锁标识， 0表示无锁，1表示偏向锁，锁的标识位还是01</p><p><strong>轻量级锁：</strong>在轻量级锁中直接开辟 30bit 的空间存放指向栈中锁记录的指针，2bit 存放锁的标志位，其标志位为00</p><p><strong>重量级锁：</strong> 在重量级锁中和轻量级锁一样，30bit 的空间用来存放指向重量级锁的指针，2bit 存放锁的标识位，为11</p><p>GC标记： 开辟30bit 的内存空间却没有占用，2bit 空间存放锁标志位为11。</p><p>其中无锁和偏向锁的锁标志位都是01，只是在前面的1bit区分了这是无锁状态还是偏向锁状态</p><p>关于内存的分配，我们可以在git中openJDK中 markOop.hpp 可以看出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constants</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> </span>&#123; age_bits                 = <span class="number">4</span>,</span><br><span class="line">         lock_bits                = <span class="number">2</span>,</span><br><span class="line">         biased_lock_bits         = <span class="number">1</span>,</span><br><span class="line">         max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,</span><br><span class="line">         hash_bits                = max_hash_bits &gt; <span class="number">31</span> ? <span class="number">31</span> : max_hash_bits,</span><br><span class="line">         cms_bits                 = LP64_ONLY(<span class="number">1</span>) NOT_LP64(<span class="number">0</span>),</span><br><span class="line">         epoch_bits               = <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>age_bits： 就是我们说的分代回收的标识，占用4字节</p><p>lock_bits： 是锁的标志位，占用2个字节</p><p>biased_lock_bits： 是是否偏向锁的标识，占用1个字节</p><p>max_hash_bits： 是针对无锁计算的hashcode 占用字节数量，如果是32位虚拟机，就是 32 - 4 - 2 </p><p>-1 = 25 byte，如果是64 位虚拟机，64 - 4 - 2 - 1 = 57 byte，但是会有 25 字节未使用，所以64位的 </p><p>hashcode 占用 31 byte</p><p>hash_bits： 是针对 64 位虚拟机来说，如果最大字节数大于 31，则取31，否则取真实的字节数</p><p>cms_bits： 不是64位虚拟机就占用 0 byte，是64位就占用 1byte</p><p>epoch_bits： 就是 epoch 所占用的字节大小，2字节。</p><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>Monitor 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个 Java 对象就有一把看不见的锁，称为内部锁或者 Monitor 锁。</p><p>Monitor 是线程私有的数据结构，每一个线程都有一个可用 monitor record 列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个 monitor 关联，同时 monitor 中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为重量级锁。</p><p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking=false来禁用偏向锁。</p><h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点是修改操作会在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>初次执行到synchronized代码块的时候，锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并不会主动释放偏向锁。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</p><p>关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。</p><h2 id="轻量级锁（自旋锁）"><a href="#轻量级锁（自旋锁）" class="headerlink" title="轻量级锁（自旋锁）"></a>轻量级锁（自旋锁）</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000022904671" alt="img"></p><p>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。</p><p>轻量级锁的获取主要由两种情况：</p><p>① 当关闭偏向锁功能时；</p><p>② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。</p><p>一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，比较并设置是原子性发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，短时间的忙等，换取线程在用户态和内核态之间切换的开销。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。</p><p>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p><p>简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;锁的状态总共有四种，级别由低到高依次为：无锁、偏向锁、轻量级锁、重量级锁，这四种锁状态分别代表什么，为什么会有锁升级。在JDK1.6之前，s</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>java异常</title>
    <link href="https://leslieaibin.github.io/2021/08/30/java%E5%9F%BA%E7%A1%80/java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
    <id>https://leslieaibin.github.io/2021/08/30/java%E5%9F%BA%E7%A1%80/java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</id>
    <published>2021-08-30T01:15:42.000Z</published>
    <updated>2021-08-30T12:41:34.322Z</updated>
    
    <content type="html"><![CDATA[<p>java把异常作为一类，当做对象来处理。所有异常类的基类是Throwable类，两大子类分别是Error  和 Exception。</p><p>系统错误由Java虚拟机抛出，用Error类表示，Error类描述的是内部系统错误，例如Java虚拟机崩溃。这种情况仅凭程序自身是无法处理的，在程序中也不会对Error异常进行捕捉和抛出。</p><p>异常（Exception）又分为RuntimeException（运行时异常）和 CheckedException（检查时异常），两者区别如下：</p><ul><li>RuntimeException：程序运行过程中才可能发生的异常，一般为代码的逻辑异常，例如：类型错误，数组越界，空指针异常等</li><li>CheckedException：编译期间可以检查到的异常，必须显示的进行处理（捕获或者抛出到上一层）。例如：IOException, FileNotFoundException等等。</li></ul><h2 id="java异常体系结构图"><a href="#java异常体系结构图" class="headerlink" title="java异常体系结构图"></a>java异常体系结构图</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1294391-20180919152605174-2400592.png" alt="img"></p><p>首先说明一点，java中的Exception类的子类不仅仅只是像上图所示只包含IOException和RuntimeException这两大类，事实上Exception的子类很多很多，主要可概括为：运行时异常与非运行时异常。</p><p>Thorwable类（表示可抛出）是所有异常和错误的超类，两个直接子类为Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。下面将详细讲述这些异常之间的区别与联系：</p><p>1、Error与Exception</p><p>Error是程序无法处理的错误，它是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。</p><p>2、运行时异常和非运行时异常</p><p> 运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>常用关键字：try、catch、throw（抛出一个异常，动词）、throws（声明一个方法可能抛出的异常）、finally。</strong></p><h3 id="throws-声明异常"><a href="#throws-声明异常" class="headerlink" title="throws(声明异常)"></a>throws(声明异常)</h3><p>若方法中存在检查时异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 </p><p>在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。</p><p>若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p><h2 id="try-catch-捕获异常"><a href="#try-catch-捕获异常" class="headerlink" title="try-catch(捕获异常)"></a>try-catch(捕获异常)</h2><p>若执行try块的过程中没有发生异常，则跳过catch子句。若是出现异常，try块中剩余语句不再执行。开始逐步检查catch块，判断catch块的异常类实例是否是捕获的异常类型。匹配后执行相应的catch块中的代码。如果异常没有在当前的方法中被捕获，就会被传递给该方法的调用者。这个过程一直重复，直到异常被捕获或被传给main方法（交给JVM来捕获）。</p><p>对于try..catch捕获异常的形式来说，对于异常的捕获，可以有多个catch。对于try里面发生的异常，他会根据发生的异常和catch里面的进行匹配(按照catch块从上往下匹配)，如果有匹配的catch，它就会忽略掉这个catch后面所有的catch。</p><p>如果有finally的话进入到finally里面继续执行。</p><p>try ctach fianally 中有return 时，会先执行return ，但是不会返回。在执行完 finally 后 进行返回。</p><p>return 的是基本类型数据时， fianlly 里面的语句不会影响 return 的值，</p><p>return 的是引用类型数据时，此时已经确定了要返回对象的地址（地址一），后面 fianlly 里面的可以通过修改前面地址一中的内容修改返回的内容，</p><p>但是如果将对象指向另一个地址（地址二），则不会影响返回的内容。因为返回的对象地址已经确定为地址一，只能通过修改地址一对象的内容修改返回的信息。 </p><h2 id="try、catch、finally三个语句块应注意的问题"><a href="#try、catch、finally三个语句块应注意的问题" class="headerlink" title="try、catch、finally三个语句块应注意的问题"></a>try、catch、finally三个语句块应注意的问题</h2><ul><li>try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。</li><li>try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。</li><li>多个catch块时候，最多只会匹配其中一个异常类且只会执行该catch块代码，而不会再执行其它的catch块，且匹配catch语句的顺序为从上到下，也可能所有的catch都没执行。</li><li>先Catch子类异常再Catch父类异常。</li></ul><h2 id="throw、throws关键字"><a href="#throw、throws关键字" class="headerlink" title="throw、throws关键字"></a>throw、throws关键字</h2><p>  throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。throw关键字用法如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;方法test中的Exception&quot;</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>  throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java把异常作为一类，当做对象来处理。所有异常类的基类是Throwable类，两大子类分别是Error  和 Exception。&lt;/p&gt;
&lt;p&gt;系统错误由Java虚拟机抛出，用Error类表示，Error类描述的是内部系统错误，例如Java虚拟机崩溃。这种情况仅凭程序自</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>10.ThreadLocal</title>
    <link href="https://leslieaibin.github.io/2021/08/29/Thread/10.ThreadLocal/"/>
    <id>https://leslieaibin.github.io/2021/08/29/Thread/10.ThreadLocal/</id>
    <published>2021-08-29T02:15:42.000Z</published>
    <updated>2021-09-15T06:12:32.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h2><h3 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a><strong>官方介绍</strong></h3><p>从Java官方文档中描述：ThreadLocal类用来提供线程内部局部变量，这种变量在多线程环境下访问（通过get 和set 方法访问）时能保证各个线程的变量相对于独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程上下文</p><p>可以得知ThreadLocal作用是：提供线程内部的局部变量，不同的线程之间不会相互干扰，这种变量在线程声明周期内其作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度</p><p>总结：</p><ul><li>线程并发：在多线程并发的场景下</li><li>传递数据：可以通过ThreadLocal在统一线程，不同组件中传递公共变量</li><li>线程隔离：每个线程的变量都是独立的，不会相互影响</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>ThreadLocal：创建TheradLocal对象</li><li>public void set(T value)：设置当前线程绑定的局部变量</li><li>public T get()：获取当前线程绑定的局部变量</li><li>public  void remove()：移除当前线程绑定的局部变量</li></ul><h3 id="ThreadLocal类与synchronized关键字"><a href="#ThreadLocal类与synchronized关键字" class="headerlink" title="ThreadLocal类与synchronized关键字"></a>ThreadLocal类与synchronized关键字</h3><p>虽然ThreadLocal模式与synchronized关键字都用于处理多线程并发访问变量的问题，不过两者处理问题的角度和思路不同</p><ul><li>synchronized：同步机制采用“时间换空间”的方式，只提供了一份变量，让不同的线程排队访问，多个线程之间访问资源的同步</li><li>ThreadLocal：采用“空间换时间”的方式，为每一个线程都提供了一份变量的副本，从而实现同时访问而互不干扰。多线程中让每个线程之间的数据相互隔离</li></ul><p>总结：</p><p>在刚刚的案例中，虽然使用ThreadLocal和synchronized都能解决问题，但是使用ThreadLocal更为合适，因为这样可以使得程序拥有更高的并发性</p><h2 id="ThreadLocal的内部结构"><a href="#ThreadLocal的内部结构" class="headerlink" title="ThreadLocal的内部结构"></a>ThreadLocal的内部结构</h2><h3 id="常见的误解"><a href="#常见的误解" class="headerlink" title="常见的误解"></a>常见的误解</h3><p> 如果我们不去看源代码的话，可能会猜测ThreadLocal是这样子设计的：每个ThreadLocal都创建一个Map，然后用线程作为Map的key，要存储的局部变量作为Map的value，这样就能达到各个线程的局部变量隔离的效果。这是最简单的设计方法，JDK最早期的ThreadLocal 确实是这样设计的，但现在早已不是了。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20210124115504330.png" alt="img"></p><h3 id="现在设计"><a href="#现在设计" class="headerlink" title="现在设计"></a>现在设计</h3><p> 但是，JDK后面优化了设计方案，在JDK8中 ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap，这个Map的key是ThreadLocal实例本身，value才是真正要存储的值Object。</p><p>具体的过程是这样的：</p><p>每个Thread线程内部都有一个Map (ThreadLocalMap)</p><p>Map里面存储ThreadLocal对象（key）和线程的变量副本（value）</p><p>Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</p><p> 对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20210124120125266.png" alt="在这里插入图片描述"></p><h3 id="这样设计的好处"><a href="#这样设计的好处" class="headerlink" title="这样设计的好处"></a>这样设计的好处</h3><p> 这个设计与我们一开始说的设计刚好相反，这样设计有如下两个优势：</p><p>这样设计之后每个Map存储的Entry数量就会变少。因为之前的存储数量由Thread的数量决定，现在是由ThreadLocal的数量决定。在实际运用当中，往往ThreadLocal的数量要少于Thread的数量。<br>当Thread销毁之后，对应的ThreadLocalMap也会随之销毁，能减少内存的使用。</p><h2 id="ThreadLocal的核心方法源码"><a href="#ThreadLocal的核心方法源码" class="headerlink" title="ThreadLocal的核心方法源码"></a>ThreadLocal的核心方法源码</h2><p> 基于ThreadLocal的内部结构，我们继续分析它的核心方法源码，更深入的了解其操作原理。</p><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取当前线程对象</span></span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="comment">// 判断map是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">           <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">           <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  t the current thread 当前线程</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the map 对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *创建当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> t 当前线程</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> firstValue 存放到map中第一个entry的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//这里的this是调用此方法的threadLocal</span></span><br><span class="line">       t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先获取当前线程，并根据当前线程获取一个Map</li><li>如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key）</li><li>如果Map为空，则给该线程创建Map，并设置初始值</li></ul><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程中保存ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * 如果当前线程没有此ThreadLocal变量，</span></span><br><span class="line"><span class="comment"> * 则它会通过调用&#123;<span class="doctag">@link</span> #initialValue&#125; 方法进行初始化值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以当前的ThreadLocal 为 key，调用getEntry获取对应的存储实体e</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 对e进行判空 </span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 获取存储实体 e 对应的 value值</span></span><br><span class="line">            <span class="comment">// 即为我们想要的当前线程对应此ThreadLocal的值</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    初始化 : 有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">    第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="comment">    第二种情况: map存在, 但是没有与当前ThreadLocal关联的entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value 初始化后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用initialValue获取初始化的值</span></span><br><span class="line">    <span class="comment">// 此方法可以被子类重写, 如果不重写默认返回null</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 判断map是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回设置的值value</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先获取当前线程，根据当前线程获取一个Map</li><li>如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的Entry e，否则转到D</li><li> 如果e不为null，则返回e.value，否则转到D</li><li>Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</li></ul><p>总结：<strong>先获取当前线程的 ThreadLocalMap 变量，如果存在则返回值，不存在则创建并返回初始值。</strong></p><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">       <span class="comment">// 如果此map存在</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">// 存在则调用map.remove</span></span><br><span class="line">           <span class="comment">// 以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先获取当前线程，并根据当前线程获取一个Map</li><li>如果获取的map不为空，则移除当前ThreadLocal对象对应的entry</li></ul><h3 id="initialValue方法"><a href="#initialValue方法" class="headerlink" title="initialValue方法"></a><strong>initialValue方法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 返回当前线程对应的ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时</span></span><br><span class="line"><span class="comment">  * 除非线程先调用了set方法，在这种情况下，initialValue 才不会被这个线程调用。</span></span><br><span class="line"><span class="comment">  * 通常情况下，每个线程最多调用一次这个方法。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;这个方法仅仅简单的返回null &#123;<span class="doctag">@code</span> null&#125;;</span></span><br><span class="line"><span class="comment">  * 如果程序员想ThreadLocal线程局部变量有一个除null以外的初始值，</span></span><br><span class="line"><span class="comment">  * 必须通过子类继承&#123;<span class="doctag">@code</span> ThreadLocal&#125; 的方式去重写此方法</span></span><br><span class="line"><span class="comment">  * 通常, 可以通过匿名内部类的方式实现</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 当前ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的作用是 返回该线程局部变量的初始值。</p><ul><li><p> 这个方法是一个延迟调用方法，从上面的代码我们得知，在set方法还未调用而先调用了get方法时才执行，并且仅执行1次。</p></li><li><p>这个方法缺省实现直接返回一个null。</p></li><li><p>如果想要一个除null之外的初始值，可以重写此方法。（备注： 该方法是一个protected的方法，显然是为了让子类覆盖而设计的）</p></li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也是独立实现。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20210124143602480.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始容量 —— 必须是2的整次幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放数据的table，Entry类的定义在下面分析</span></span><br><span class="line"><span class="comment"> * 同样，数组长度必须是2的整次幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p> 跟HashMap类似，INITIAL_CAPACITY代表这个Map的初始容量；table 是一个Entry 类型的数组，用于存储数据；size 代表表中的存储数目； threshold 代表需要扩容时对应 size 的阈值。</p><p><strong>存储结构 - Entry</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Entry继承WeakReference，并且用ThreadLocal作为key.</span></span><br><span class="line"><span class="comment"> * 如果key为null(entry.get() == null)，意味着key不再被引用，</span></span><br><span class="line"><span class="comment"> * 因此这时候entry也可以从table中清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。不过Entry中的key只能是ThreadLocal对象，这点在构造方法中已经限定死了。</p><p> 另外，Entry继承WeakReference，也就是key（ThreadLocal）是弱引用，其目的是将ThreadLocal对象的生命周期和线程生命周期解绑。</p><h3 id="弱引用和内存泄漏"><a href="#弱引用和内存泄漏" class="headerlink" title="弱引用和内存泄漏"></a>弱引用和内存泄漏</h3><p>有些程序员在使用ThreadLocal的过程中会发现有内存泄漏的情况发生，就猜测这个内存泄漏跟Entry中使用了弱引用的key有关系。这个理解其实是不对的。</p><h4 id="内存泄漏相关概念"><a href="#内存泄漏相关概念" class="headerlink" title="内存泄漏相关概念"></a><strong>内存泄漏相关概念</strong></h4><ul><li>Memory overflow:内存溢出，没有足够的内存提供申请者使用。</li><li>Memory leak: 内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。内存泄漏的堆积终将导致内存溢出。</li></ul><h4 id="弱引用相关概念"><a href="#弱引用相关概念" class="headerlink" title="弱引用相关概念"></a><strong>弱引用相关概念</strong></h4><ul><li><p>Java中的引用有4种类型： 强、软、弱、虚。当前这个问题主要涉及到强引用和弱引用：</p></li><li><p>强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。</p></li><li><p>弱引用（WeakReference），垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p></li></ul><h4 id="如果key使用强引用"><a href="#如果key使用强引用" class="headerlink" title="如果key使用强引用"></a><strong>如果key使用强引用</strong></h4><p> 假设ThreadLocalMap中的key使用了强引用，那么会出现内存泄漏吗？</p><p> 此时ThreadLocal的内存图（实线表示强引用）如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20210124144330949.png" alt="在这里插入图片描述"></p><p>假设在业务代码中使用完ThreadLocal ，threadLocal Ref被回收了。</p><p> 但是因为threadLocalMap的Entry强引用了threadLocal，造成threadLocal无法被回收。</p><p> 在没有手动删除这个Entry以及CurrentThread依然运行的前提下，始终有强引用链 threadRef-&gt;currentThread-&gt;threadLocalMap-&gt;entry，Entry就不会被回收（Entry中包括了ThreadLocal实例和value），导致Entry内存泄漏。</p><p> 也就是说，ThreadLocalMap中的key使用了强引用， 是无法完全避免内存泄漏的。</p><h4 id="如果key使用弱引用"><a href="#如果key使用弱引用" class="headerlink" title="如果key使用弱引用"></a><strong>如果key使用弱引用</strong></h4><p> 那么ThreadLocalMap中的key使用了弱引用，会出现内存泄漏吗？</p><p> 此时ThreadLocal的内存图（实线表示强引用，虚线表示弱引用）如下：</p><p> 同样假设在业务代码中使用完ThreadLocal ，threadLocal Ref被回收了。</p><p> 由于ThreadLocalMap只持有ThreadLocal的弱引用，没有任何强引用指向threadlocal实例, 所以threadlocal就可以顺利被gc回收，此时Entry中的key=null。</p><p> 但是在没有手动删除这个Entry以及CurrentThread依然运行的前提下，也存在有强引用链 threadRef-&gt;currentThread-&gt;threadLocalMap-&gt;entry -&gt; value ，value不会被回收， 而这块value永远不会被访问到了，导致value内存泄漏。</p><p> 也就是说，ThreadLocalMap中的key使用了弱引用， 也有可能内存泄漏。</p><h4 id="出现内存泄漏的真实原因"><a href="#出现内存泄漏的真实原因" class="headerlink" title="出现内存泄漏的真实原因"></a><strong>出现内存泄漏的真实原因</strong></h4><p> 比较以上两种情况，我们就会发现，内存泄漏的发生跟ThreadLocalMap中的key是否使用弱引用是没有关系的。那么内存泄漏的的真正原因是什么呢？</p><p> 细心的同学会发现，在以上两种内存泄漏的情况中，都有两个前提：</p><ul><li><p>没有手动删除这个Entry</p></li><li><p>CurrentThread依然运行</p><p>第一点很好理解，只要在使用完ThreadLocal，调用其remove方法删除对应的Entry，就能避免内存泄漏。</p><p>第二点稍微复杂一点， 由于ThreadLocalMap是Thread的一个属性，被当前线程所引用，所以它的生命周期跟Thread一样长。那么在使用完ThreadLocal之后，如果当前Thread也随之执行结束，ThreadLocalMap自然也会被gc回收，从根源上避免了内存泄漏。</p><p>综上，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。</p></li></ul><h4 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a><strong>为什么使用弱引用</strong></h4><p> 根据刚才的分析, 我们知道了： 无论ThreadLocalMap中的key使用哪种类型引用都无法完全避免内存泄漏，跟使用弱引用没有关系。</p><p> 要避免内存泄漏有两种方式：</p><ul><li><p>使用完ThreadLocal，调用其remove方法删除对应的Entry</p></li><li><p>使用完ThreadLocal，当前Thread也随之运行结束</p></li></ul><p>相对第一种方式，第二种方式显然更不好控制，特别是使用线程池的时候，线程结束是不会销毁的。</p><p> 也就是说，只要记得在使用完ThreadLocal及时的调用remove，无论key是强引用还是弱引用都不会有问题。那么为什么key要用弱引用呢？</p><p> 事实上，在ThreadLocalMap中的set/getEntry方法中，会对key为null（也即是ThreadLocal为null）进行判断，如果为null的话，那么是会对value置为null的。</p><p> <strong>这就意味着使用完ThreadLocal，CurrentThread依然运行的前提下，就算忘记调用remove方法，弱引用比强引用可以多一层保障：弱引用的ThreadLocal会被回收，对应的value在下一次ThreadLocalMap调用set,get,remove中的任一方法的时候会被清除，从而避免内存泄漏。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ThreadLocal介绍&quot;&gt;&lt;a href=&quot;#ThreadLocal介绍&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal介绍&quot;&gt;&lt;/a&gt;ThreadLocal介绍&lt;/h2&gt;&lt;h3 id=&quot;官方介绍&quot;&gt;&lt;a href=&quot;#官方介绍&quot;</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树、B 树、B+树</title>
    <link href="https://leslieaibin.github.io/2021/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%20%E6%A0%91%E3%80%81B+%E6%A0%91/"/>
    <id>https://leslieaibin.github.io/2021/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%20%E6%A0%91%E3%80%81B+%E6%A0%91/</id>
    <published>2021-08-29T01:15:42.000Z</published>
    <updated>2021-08-29T13:40:53.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构</p><p><strong>特点：</strong></p><p>平衡二叉树是采用二分法思维把数据按规则组装成一个树型结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：</p><ul><li>非叶子节点只能允许最多两个子节点存在</li><li>每一个非叶子检点数据分布规则按照左边的子节点小于当前节点的值，右边的子节点大于当前节点的值（这里的值是基于自己的算法规则而定的，比如hash值）</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-28e39093993f673de576f57ea614d604_720w.jpg" alt="img"></p><p>平衡树的层级结构：因为平衡二叉树查询性能和树的层级（h高度）成反比，h值越小查询越快、为了保证树的结构左右两端数据大致平衡降低二叉树的查询难度一般会采用一种算法机制实现节点数据结构的平衡，实现了这种算法的有比如Treap、红黑树，使用平衡二叉树能保证数据的左右两边的节点层级相差不会大于1.，通过这样避免树形结构由于删除增加变成线性链表影响查询效率，保证数据平衡的情况下查找数据的速度近于二分法查找；</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-2b52d4e523f374f41b5429cd587443db_720w.jpg" alt="img"></p><p>总结平衡二叉树特点：</p><ul><li>非叶子节点最多拥有两个子节点</li><li>非叶子节点大于左边子节点，小于右边子节点</li><li>树的左右两边的层级数相差不会大于1</li><li>没有值相等重复的节点</li></ul><h1 id="B树（BTree"><a href="#B树（BTree" class="headerlink" title="B树（BTree)"></a>B树（BTree)</h1><p>B树和平衡二叉树稍有不同的是B树属于多叉树有名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用B树 和 B+树。</p><p><strong>规则：</strong></p><ul><li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</li><li>子节点数：非叶节点的子节点数&gt;1，且&lt;=M，且 M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</li><li>关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</li><li>所有叶子节点均在同一层，叶子节点除了除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</li></ul><p>最后我们用一个图和一个实例的例子理解：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-2c2264cc1c6c603dfeca4f84a2575901_720w.jpg" alt="img"></p><ul><li><p><strong>B树的查询流程：</strong></p><p>如上图我要从上图中找到E字母，查找流程如下：</p><ul><li>获取根节点的关键字比较，当前根节点关键字为M，E &lt; M(26个字母顺序)，所以找到指向左边的子节点(二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点);</li><li>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</li><li>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</li></ul></li><li><p>B<strong>树的插入节点流程</strong></p><p>定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来;</p><p>遵循规则：</p><p>（1）节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4就要进行节点拆分）；</p><p>（2）排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;</p></li></ul><p>  先插入 3、8、31、11</p><p>  <img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-e1d65c9c6236d4768c89e8e103e12583_720w.jpg" alt="img"></p><p>  再插入23、29</p><p>  <img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-66cdb6187cbc5227fd8c4aabe7282e6c_720w.jpg" alt="img"></p><p>  再插入50、28</p><p>  <img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-3057eaab2b1764dd51c2a8658791cc98_720w.jpg" alt="img"></p><ul><li><strong>B树节点的删除</strong></li></ul><p>  <strong>规则：</strong></p><p>  （1）节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）；</p><p>  （2）满足节点本身比左边节点大，比右边节点小的排序规则;</p><p>  （3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；</p><p>  <img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-a0f981fc847772cb28869927cd4fe66d_720w.jpg" alt="img"></p><p>  <strong>特点：</strong></p><p>  B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；</p><p><strong>规则：</strong></p><ul><li>B+ 树跟 B树不同 B树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加，</li><li>B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li><li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li><li>非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-5f069fd820637db1b877fdd6799a2b67_720w.jpg" alt="img"></p><p><strong>（百度百科算法结构示意图）</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-9644d1a1f83d3e45da779f2e63c35d55_720w.jpg" alt="img"></p><p><strong>（维基百科算法结构示意图）</strong></p><p><strong>特点：</strong></p><ul><li><strong>B+ 树的层级更少：</strong>相较于B树  B+ 树每个非叶子节点存储的关键字更多，树的层级更少所以查询数据更快</li><li><strong>B+ 树查询速度更稳定：</strong>B+ 所有的关键字数据地址都存在叶子节点上，所以每次查找的次数都相等所以查询速度要比B树更稳定</li><li><strong>B+ 树天然具备排序功能：</strong>B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高</li><li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描</li></ul><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h1><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><p>（1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b* 树的初始化个数为（cei(2/3*m)）</p><p>（2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</p><ul><li><strong>特点</strong></li></ul><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-e8bf8ee3230f3d39d59ce5e76a2ee32e_720w.jpg" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>相同思想和策略</strong></p><p>从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；</p><p><strong>不同的方式的磁盘空间利用</strong></p><p>不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;平衡二叉树&quot;&gt;&lt;a href=&quot;#平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;&lt;/a&gt;平衡二叉树&lt;/h1&gt;&lt;p&gt;平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/stron</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="https://leslieaibin.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>如何保证消息队列的可靠性传输</title>
    <link href="https://leslieaibin.github.io/2021/08/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93/"/>
    <id>https://leslieaibin.github.io/2021/08/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93/</id>
    <published>2021-08-26T01:15:42.000Z</published>
    <updated>2021-08-26T13:09:45.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ如何保证消息队列的可靠性传输"><a href="#RabbitMQ如何保证消息队列的可靠性传输" class="headerlink" title="RabbitMQ如何保证消息队列的可靠性传输"></a>RabbitMQ如何保证消息队列的可靠性传输</h1><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-6303e69011255831c54d605250a6aa67_720w.jpg" alt="img"></p><h2 id="生产者弄丢数据"><a href="#生产者弄丢数据" class="headerlink" title="生产者弄丢数据"></a>生产者弄丢数据</h2><p>生产者将数据发送到RabbitMQ的时候，可能数据就在半路丢失。此时RabbitMQ提供事务功能，就是生产者发送数据之前开启RabbitMQ事务channel.txSelect，然后发送消息，如果消息没有成功被RabbitMQ接受到，那么生产者就会异常报错，此时回滚事务channel.txRollback，然后重发消息，如果收到消息就可以提交事务channel.txCommit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">channel.txSelect</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里发送消息</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    channel.txRollback</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里再次重发这条消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">channel.txCommit</span><br></pre></td></tr></table></figure><p>但是问题是，RabbitMQ 事务机制（同步）一搞，基本上<strong>吞吐量会下来，因为太耗性能</strong>。</p><p>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 <code>confirm</code> 模式，在生产者那里设置开启 <code>confirm</code> 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 <code>ack</code> 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 <code>nack</code> 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p><p>事务机制和 <code>cnofirm</code> 机制最大的不同在于，<strong>事务机制是同步的</strong>，你提交一个事务之后会<strong>阻塞</strong>在那儿，但是 <code>confirm</code> 机制是<strong>异步</strong>的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</p><p>所以一般在生产者这块<strong>避免数据丢失</strong>，都是用 <code>confirm</code> 机制的。</p><h2 id="RabbitMQ-弄丢了数据"><a href="#RabbitMQ-弄丢了数据" class="headerlink" title="RabbitMQ 弄丢了数据"></a><strong>RabbitMQ 弄丢了数据</strong></h2><p>就是 RabbitMQ 自己弄丢了数据，这个你必须<strong>开启 RabbitMQ 的持久化</strong>，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，<strong>恢复之后会自动读取之前存储的数据</strong>，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，<strong>可能导致少量数据丢失</strong>，但是这个概率较小。</p><p>设置持久化有<strong>两个步骤</strong>：</p><ul><li>创建 queue 的时候将其设置为持久化<br>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li><li>第二个是发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2<br>就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li></ul><p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p><p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p><p>所以，持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code>，你也是可以自己重发的。</p><h2 id="消费端弄丢了数据"><a href="#消费端弄丢了数据" class="headerlink" title="消费端弄丢了数据"></a><strong>消费端弄丢了数据</strong></h2><p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，<strong>刚消费到，还没处理，结果进程挂了</strong>，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p><p>这个时候得用 RabbitMQ 提供的 <code>ack</code> 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 <code>ack</code>，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 <code>ack</code> 一把。这样的话，如果你还没处理完，不就没有 <code>ack</code> 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-83213e2ac79cd8899b09a66a5cf71669_720w.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RabbitMQ如何保证消息队列的可靠性传输&quot;&gt;&lt;a href=&quot;#RabbitMQ如何保证消息队列的可靠性传输&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ如何保证消息队列的可靠性传输&quot;&gt;&lt;/a&gt;RabbitMQ如何保证消息队列的可靠性</summary>
      
    
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>9.synchronized、Lock、volatile</title>
    <link href="https://leslieaibin.github.io/2021/08/25/Thread/9.synchronized%E3%80%81Lock%E3%80%81volatile/"/>
    <id>https://leslieaibin.github.io/2021/08/25/Thread/9.synchronized%E3%80%81Lock%E3%80%81volatile/</id>
    <published>2021-08-25T02:15:42.000Z</published>
    <updated>2021-08-25T13:34:03.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java的内存模型</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20170307155954797" alt="这里写图片描述"></p><ul><li>每个线程都有自己的本地内存空间（java栈中的帧），线程执行时，先把变量从内存读到线程自己的本地内存空间，然后对变量进行操作</li><li>对该变量操作完成后，在某个时间再把变量刷新回主内存</li></ul><p>锁提供的两种特性：<strong>互斥（mutual exclusion） 和可见性（visibility）</strong></p><ul><li>互斥：互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样一次只有一个线程能够使用该共享数据</li><li>可见性：简单来说就是一个线程修改了变量，其他线程可以立即知道。保证可见性的方法：volatile，synchronized，final（一旦初始化完成其他线程就可见）</li></ul><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile 是类型修饰符（type specifier）。它是被设计用来修饰被不同线程访问和修改的变量。确保本条指令不会因编译期的优化而省略，且要求每次直接读值。</p><p>简单概述volatile，它能够使变量在值发生改变时能尽快的让其他线程知道</p><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>编译器为了加快程序运行的速度，对一些变量的写操作会先在寄存器或者是CPU缓存上进行，最后才写入内存。而在这个过程中，变量的新值对其他线程时不可见的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isRunning;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunning</span><span class="params">(<span class="keyword">boolean</span> isRunning)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isRunning = isRunning;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@OverRide</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入到run方法中了&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (isRunning == <span class="keyword">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行完成了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RunThread thread = <span class="keyword">new</span> RunThread();</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            thread.setRunning(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在main线程中，thread.setRunning(false);将启动的线程RunThread中的共享变量设置为false，从而想让RunThread.java的while循环结束。如果使用JVM -server参数执行该程序时，RunThread线程并不会终止，从而出现了死循环。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>现在有两个线程，一个是main线程，另一个是RunThread。它们都试图修改isRunning变量。按照JVM内存模型，main线程将isRunning读取到本地线程内存空间，修改后，再刷新回主内存。</p><p>而在JVM设置成 -server模式运行程序时，线程会一直在私有堆栈中读取isRunning变量。因此，RunThread线程无法读到main线程改变的isRunning变量。从而出现了死循环，导致RunThread无法终止。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">private</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当对volatile标记的变量进行修改时，会将其他缓存中存储的修改前的变量清除，然后重新读取。一般来说应该是先在进行修改的缓存A中修改为新值，然后通知其他缓存清除掉此变量，当其他缓存B中的线程读取此变量时，会向总线发送消息，这时存储新值的缓存A获取到消息，将新值穿给B。最后将新值写入内存。当变量需要更新时都是此步骤，volatile的作用是被其修饰的变量，每次更新时，都会刷新上述步骤。</p><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>Java语言的关键字，可用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。然而，当一个线程访问object的一个加锁代码块时，另一个线程仍然可以访问该object中的非加锁代码块。</p><p><strong>（1）synchronized 方法</strong></p><p>方法声明时使用,放在范围操作符(public等)之后,返回类型声明(void等)之前.这时,线程获得的是成员锁,即一次只能有一个线程进入该方法,其他线程要想在此时调用该方法,只能排队等候,当前线程(就是在synchronized方法内部的线程)执行完该方法后,别的线程才能进入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    　　<span class="comment">//方法体</span></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>如在线程t1中有语句obj.synMethod(); 那么由于synMethod被synchronized修饰,在执行该语句前, 需要先获得调用者obj的对象锁, 如果其他线程(如t2)已经锁定了obj (可能是通过obj.synMethod,也可能是通过其他被synchronized修饰的方法obj.otherSynMethod锁定的obj), t1需要等待直到其他线程(t2)释放obj, 然后t1锁定obj, 执行synMethod方法. 返回之前之前释放obj锁。<strong>synchronized 块</strong></p><p><strong>（2）synchronized 块</strong></p><p>对某一代码块使用,synchronized后跟括号,括号里是变量,这样,一次只有一个线程进入该代码块.此时,线程获得的是成员锁。</p><p><strong>（3）synchronized (this)</strong></p><ul><li>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。　　</li><li>当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。　　</li><li>然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的除synchronized(this)同步代码块以外的部分。　</li><li>第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。　　</li><li>以上规则对其它对象锁同样适用。</li></ul><p><strong>（4）wait() 与notify()/notifyAll()</strong></p><p><strong>wait():</strong>  释放占有的对象锁，线程进入等待池，释放cpu,而其他正在等待的线程即可抢占此锁，获得锁的线程即可运行程序。而sleep()不同的是，线程调用此方法后，会休眠一段时间，休眠期间，会暂时释放cpu，但并不释放对象锁。也就是说，在休眠期间，其他线程依然无法进入此代码内部。休眠结束，线程重新获得cpu,执行代码。wait()和sleep()最大的不同在于wait()会释放对象锁，而sleep()不会！</p><p><strong>notify():</strong>   该方法会唤醒因为调用对象的wait()而等待的线程，其实就是对对象锁的唤醒，从而使得wait()的线程可以有机会获取对象锁。调用notify()后，并不会立即释放锁，而是继续执行当前代码，直到synchronized中的代码全部执行完毕，才会释放对象锁。JVM则会在等待的线程中调度一个线程去获得对象锁，执行代码。需要注意的是，wait()和notify()必须在synchronized代码块中调用。</p><p>notifyAll()则是唤醒所有等待的线程。</p><h1 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h1><h2 id="1-synchronized的缺陷"><a href="#1-synchronized的缺陷" class="headerlink" title="(1) synchronized的缺陷"></a><strong>(1) synchronized的缺陷</strong></h2><p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？</p><p>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><ul><li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li><li>线程执行发生异常，此时JVM会让线程自动释放锁。</li></ul><p>那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能等待，试想一下，这多么影响程序执行效率。</p><p>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p><p>再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p><p>但是采用synchronized关键字来实现同步的话，就会导致一个问题：</p><p>如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</p><p>因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p><p><strong>另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</strong></p><p>总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p><ul><li>Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</li><li>Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li></ul><h2 id="2-java-util-concurrent-locks包下常用的类"><a href="#2-java-util-concurrent-locks包下常用的类" class="headerlink" title="(2) java.util.concurrent.locks包下常用的类"></a><strong>(2) java.util.concurrent.locks包下常用的类</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁，如果锁被其他线程获取，则进行等待</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成</span></span><br><span class="line"><span class="comment">    *功，则返回true，如果获取失败（即锁已被其他线程获取），则返回</span></span><br><span class="line"><span class="comment">    *false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。*/</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>; <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li><p>当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。</p></li><li><p>而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p></li></ul><h2 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="(3) ReentrantLock"></a><strong>(3) ReentrantLock</strong></h2><p>ReentrantLock,意思是“可重入锁”,是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;得到了锁&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。</p><p>而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。</p><h1 id="volatile和synchronized区别"><a href="#volatile和synchronized区别" class="headerlink" title="volatile和synchronized区别"></a>volatile和synchronized区别</h1><ul><li><p>volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.</p></li><li><p>volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.</p></li><li><p>volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性.</p><p>《Java编程思想》上说，定义long或double变量时，如果使用volatile关键字，就会获得（简单的赋值与返回操作）原子性</p></li><li><p>volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.</p></li><li><p>当一个域的值依赖于它之前的值时，volatile就无法工作了，如n=n+1,n++等。如果某个域的值受到其他域的值的限制，那么volatile也无法工作，如Range类的lower和upper边界，必须遵循lower&lt;=upper的限制。</p></li><li><p>使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。</p></li></ul><h1 id="synchronized和lock区别"><a href="#synchronized和lock区别" class="headerlink" title="synchronized和lock区别"></a>synchronized和lock区别</h1><ul><li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li><li>Lock可以提高多个线程进行读操作的效率。</li></ul><p>　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;java的内存模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://test-1874253.oss-cn-beijing.aliyuncs</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>3.HashMap、ConcurrentHashMap、HashTable</title>
    <link href="https://leslieaibin.github.io/2021/08/24/Collection/3.java%E9%9B%86%E5%90%88[3]--HashMap%E3%80%81ConcurrentHashMap%E3%80%81HashTable%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://leslieaibin.github.io/2021/08/24/Collection/3.java%E9%9B%86%E5%90%88[3]--HashMap%E3%80%81ConcurrentHashMap%E3%80%81HashTable%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-08-23T16:15:42.000Z</published>
    <updated>2021-08-24T07:13:47.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap、ConcurrentHashMap、HashTable的区别"><a href="#HashMap、ConcurrentHashMap、HashTable的区别" class="headerlink" title="HashMap、ConcurrentHashMap、HashTable的区别"></a>HashMap、ConcurrentHashMap、HashTable的区别</h1><h2 id="HashMap-vs-ConcurrentHashMap"><a href="#HashMap-vs-ConcurrentHashMap" class="headerlink" title="HashMap vs ConcurrentHashMap"></a>HashMap vs ConcurrentHashMap</h2><p>引入ConcurrentHashMap是为了同步集合HashTable之间有更好的选择，HashTable与HashMap,ConcurrentHashMap主要区别于HashMap不是同步的，线程不安全的和不适合应用于多线程并发环境下，而ConcurrentHashMap是线程安全的集合容器，特别是在多线程和并发环境中，通常作为Map的主要实现。</p><h2 id="HashMap与ConcurrentHashMap的区别"><a href="#HashMap与ConcurrentHashMap的区别" class="headerlink" title="HashMap与ConcurrentHashMap的区别"></a>HashMap与ConcurrentHashMap的区别</h2><ul><li>ConcurrentHashMap是线程安全的并发环境下不需要额外的同步。虽然它不像Hashtable那样需要同样的同步等级（全表锁），但也有很多实际的用途</li><li>你可以使用Collections.synchronizedMap(HashMap)来包装HashMap作为同步容器，这时它的作用与hashtable一样，当每次对Map做修改操作的时候都会锁住这个Map对象，而ConcurrentHashMap会基于并发的等级来划分整个Map来达到线程安全，它之后锁操作的那一段数据而不是整个Map都上锁</li><li>ConcurrentHashMap有很好的的扩展性，在多线程环境下性能比做同步的HashMap要好，但是在但性能环境下，HashMap会比ConcurrentHashMap好一点</li></ul><p>总结一下以上两者的区别，它们在线程安全、扩展性、同步之间的区别。如果是用于缓存的话，<code>ConcurrentHashMap</code>是一个更好的选择，在Java应用中会经常用到。<code>ConcurrentHashMap</code>在读操作线程数多于写操作线程数的情况下更胜一筹。</p><h2 id="ConcurrentHashMap-vs-Hashtable-vs-Synchronized-Map"><a href="#ConcurrentHashMap-vs-Hashtable-vs-Synchronized-Map" class="headerlink" title="ConcurrentHashMap vs Hashtable vs Synchronized Map"></a>ConcurrentHashMap vs Hashtable vs Synchronized Map</h2><ul><li><p>虽然三个集合类在多线程并发应用中都是线程安全的，但是他们有一个重大的差别，就是他们各自实现线程安全的方式。<code>Hashtable</code>是jdk1的一个遗弃的类，它把所有方法都加上<code>synchronized</code>关键字来实现线程安全。所有的方法都同步这样造成多个线程访问效率特别低。<code>Synchronized Map</code>与<code>HashTable</code>差别不大，也是在并发中作类似的操作，两者的唯一区别就是<code>Synchronized Map</code>没被遗弃，它可以通过使用<code>Collections.synchronizedMap()</code>来包装<code>Map</code>作为同步容器使用。</p></li><li><p>另一方面，<code>ConcurrentHashMap</code>的设计有点特别，表现在多个线程操作上。它不用做外的同步的情况下默认同时允许16个线程读和写这个Map容器。因为其内部的实现剥夺了锁，使它有很好的扩展性。不像<code>HashTable</code>和<code>Synchronized Map</code>，<code>ConcurrentHashMap</code>不需要锁整个Map，相反它划分了多个段(segments)，要操作哪一段才上锁那段数据。</p></li></ul><h2 id="ConcurrentHashMap实现原理"><a href="#ConcurrentHashMap实现原理" class="headerlink" title="ConcurrentHashMap实现原理"></a>ConcurrentHashMap实现原理</h2><p>ConcurrentHashMap在JDK1.7  和 JDK 1.8 的实现有很大的区别</p><p>ConcurrentHashMap底层结构是一个Segment数组，默认大小是16，每个Segment数组又可以看成一个小的HashMap，也就是说Segment数组使用链表加数组实现的。</p><h3 id="jdk-1-7的实现基于分段锁的ConcurrentHashMap"><a href="#jdk-1-7的实现基于分段锁的ConcurrentHashMap" class="headerlink" title="jdk 1.7的实现基于分段锁的ConcurrentHashMap"></a>jdk 1.7的实现基于分段锁的ConcurrentHashMap</h3><p>在JDK1.7中ConcurrentHashMap采用了<strong>数组+Segment+分段锁</strong>的方式实现。</p><ul><li><p>Segment（分段锁）</p><p>ConcurrentHashMap中的<strong>分段锁称为Segment</strong>，它即类似于HashMap的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表,同时又是一个ReentrantLock（Segment继承了ReentrantLock）。</p></li><li><p>内部结构</p><p>ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。如下图是ConcurrentHashMap的内部结构图：</p></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4209232655-5de51f35bf273_articlex" alt="file"></p><p>从上面的结构我们可以了解到，ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。</p><p><strong>第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。</strong></p><p><strong>坏处</strong></p><p>这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长</p><p><strong>好处</strong></p><p>写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上）。</p><p>所以，通过这一种结构，ConcurrentHashMap的并发能力可以大大的提高。</p><h3 id="JDK1-8版本的CurrentHashMap的实现原理"><a href="#JDK1-8版本的CurrentHashMap的实现原理" class="headerlink" title="JDK1.8版本的CurrentHashMap的实现原理**"></a>JDK1.8版本的CurrentHashMap的实现原理**</h3><p>DK8中ConcurrentHashMap参考了JDK8 HashMap的实现，采用了<strong>数组+链表+红黑树</strong>的实现方式来设计，<strong>内部大量采用CAS操作，这里我简要介绍下CAS</strong>。</p><p>CAS是compare and swap的缩写，即我们所说的比较交换。cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。</p><p><strong>JDK8中彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。</strong></p><p><strong>Node：保存key，value及key的hash值的数据结构。其中value和next都用volatile修饰，保证并发的可见性。</strong></p><p><strong>Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，不过保证线程安全性。</strong></p><p>在JDK8中ConcurrentHashMap的结构，由于引入了红黑树，使得ConcurrentHashMap的实现非常复杂，我们都知道，红黑树是一种性能非常好的二叉查找树，其查找性能为O（logN），但是其实现过程也非常复杂，而且可读性也非常差，Doug<br>Lea的思维能力确实不是一般人能比的，早期完全采用链表结构时Map的查找时间复杂度为O（N），JDK8中ConcurrentHashMap在链表的长度大于某个阈值的时候会将链表转换成红黑树进一步提高其查找性能。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1083488536-5de51f3800fc4_articlex" alt="file"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。</p><p><strong>1.数据结构：</strong>取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</p><p><strong>2.保证线程安全机制：</strong>JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。</p><p><strong>3.锁的粒度：</strong>原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</p><p>**4.链表转化为红黑树:**定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。</p><p><strong>5.查询时间复杂度：</strong>从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HashMap、ConcurrentHashMap、HashTable的区别&quot;&gt;&lt;a href=&quot;#HashMap、ConcurrentHashMap、HashTable的区别&quot; class=&quot;headerlink&quot; title=&quot;HashMap、Concurre</summary>
      
    
    
    
    <category term="Collection" scheme="https://leslieaibin.github.io/categories/Collection/"/>
    
    
    <category term="Collection" scheme="https://leslieaibin.github.io/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>2.Java集合</title>
    <link href="https://leslieaibin.github.io/2021/08/20/Collection/2.%E9%9B%86%E5%90%88[2]/"/>
    <id>https://leslieaibin.github.io/2021/08/20/Collection/2.%E9%9B%86%E5%90%88[2]/</id>
    <published>2021-08-19T16:15:42.000Z</published>
    <updated>2021-08-20T12:14:50.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合容器概述"><a href="#集合容器概述" class="headerlink" title="集合容器概述"></a>集合容器概述</h1><h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><ul><li>集合就是一个放数据的容器，准确的说是放数据对象引用的容器</li><li>集合类存放的都是对象的引用，而不是对象的本身</li><li>集合类型主要有三种： set(集)、list(列表) 和 map(映射)</li></ul><h2 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h2><ul><li><p>集合用于存储对象的容器，对象是用来封装数据，对象多了也需要存储集中式管理</p></li><li><p>和数组对比对象的大小是不确定的，集合的长度是可变的，数组需要提前定义大小</p></li></ul><h2 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h2><ul><li>数组是 固定长度的，集合可变长度的</li><li>数组可以存储基本数据类型，也可以存储引用数据类型，集合只能存储引用数据类型</li><li>数组存储的元素必须是同一个数据类型，集合存储的对象可以是不同数据类型</li></ul><h2 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h2><ul><li>容量自增长</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量</li><li>可以方便的扩展或改写集合，提高代码复用性和可操作性</li><li>通过使用JDK自带的集合类，降低代码维护和学习新API成本</li></ul><h2 id="常用的集合类有哪些"><a href="#常用的集合类有哪些" class="headerlink" title="常用的集合类有哪些"></a>常用的集合类有哪些</h2><ul><li>Map接口和Collection接口是所有集合框架的父接口</li><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要包括：HashMap、TreeMap、Hashtable、weakHashMap等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有： ArrayList、LinkedList、Stack以及Vector等</li></ul><h2 id="List、Map-、Set三者的区别"><a href="#List、Map-、Set三者的区别" class="headerlink" title="List、Map 、Set三者的区别"></a>List、Map 、Set三者的区别</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e70de4bd~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li><p>Java容器分为Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</p></li><li><p>Collection 集合主要有List 和 Set 两大接口</p><ul><li>List：一个有序的（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有ArrayList、LinkedList 和 Vector</li><li>Set：一个无序的（存入和取出顺序有可能不一致）容器，不可以存储重复元素，值允许存入一个null 元素，必须保证元素的唯一性。Set接口常用实现类 HashSet、LinkedHashSet 以及 TreeSet。</li></ul></li><li><p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p><ul><li>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</li></ul></li></ul><h2 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h2><ul><li><p>List </p><ul><li>ArrayList：Object数组</li><li>Vector: Object数组</li><li>LinkedList：双向循环链表</li></ul></li><li><p>Set</p><ul><li>HashSet（无序，唯一）：基于HashMap实现的，底层采用HashMap来保存元素</li><li>LinkedHashSet：LinkedHashSet继承与HashSet，并且其内部是通过LinkedHashMap实现的。</li><li>TreeSet(有序，唯一)： 红黑树（自平衡的排序二叉树）</li></ul></li><li><p>Map</p><ul><li>HashMap：JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要解决哈希冲突而存在的（”拉链法”解决冲突）JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转换为红黑树，以减少搜索时间</li><li>LinkedHashMap：LinkedHashMap 继承自HashMap，所以它的底层也是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap在上面结构基础上，增加一条双向链表，使得上面的结构可以保持键值对的插入顺序，同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable：数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul></li></ul><h2 id="那些集合类是线程安全的"><a href="#那些集合类是线程安全的" class="headerlink" title="那些集合类是线程安全的"></a>那些集合类是线程安全的</h2><ul><li>Vector：就比Arraylist 多个synchronized(线程安全)，因为效率较低，不建议使用</li><li>hashTable：就比hashMap多了个Synchronized（线程安全），不建议使用</li><li>ConcurrentHashMap：是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。（推荐使用）</li></ul><h2 id="Java集合的快速失败机制-“fail-fast”？"><a href="#Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”？"></a>Java集合的快速失败机制 “fail-fast”？</h2><ul><li><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p></li><li><p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p></li><li><p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p></li><li><p>解决办法：</p><ol><li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li><li>使用CopyOnWriteArrayList来替换ArrayList</li></ol></li></ul><h2 id="怎样确保一个集合不能被修改"><a href="#怎样确保一个集合不能被修改" class="headerlink" title="怎样确保一个集合不能被修改"></a>怎样确保一个集合不能被修改</h2><ul><li>可以使用Collections.unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任操作都会抛出Java.lang.UnsupportedOperationException异常</li></ul><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><h3 id="迭代器Iterator是什么"><a href="#迭代器Iterator是什么" class="headerlink" title="迭代器Iterator是什么"></a>迭代器Iterator是什么</h3><ul><li><p>Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器允许调用者在迭代过程中移除元素</p></li><li><p>所有Collection接继承了Iterator迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Iterator-怎么使用-，有什么特点"><a href="#Iterator-怎么使用-，有什么特点" class="headerlink" title="Iterator 怎么使用 ，有什么特点"></a>Iterator 怎么使用 ，有什么特点</h3><ul><li><p>Iterator使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String obj = it.next();</span><br><span class="line">    Sysrtem.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Iterator的特点是只能单向遍历，但是更加安全，因为他可以确保在当前遍历集合元素被更改的时候，就会抛出ConcurrentModificationException 异常。</p></li></ul><h3 id="如何边遍历边移除-Collection-中的元素"><a href="#如何边遍历边移除-Collection-中的元素" class="headerlink" title="如何边遍历边移除 Collection 中的元素"></a>如何边遍历边移除 Collection 中的元素</h3><ul><li><p>边遍历边修改Collection的正确方式是使用Iterator.remove()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的</span></span><br><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    it.romove();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误的</span></span><br><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">   list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p></li></ul><h3 id="Iterator-和-ListIterator-有什么区别"><a href="#Iterator-和-ListIterator-有什么区别" class="headerlink" title="Iterator 和 ListIterator 有什么区别"></a>Iterator 和 ListIterator 有什么区别</h3><ul><li>Iterator可以遍历Set 和 List 集合，而ListIterator 只能遍历List</li><li>Iterator只能单向遍历，而ListIterator可以双向遍历（向前/先后）</li><li>LsitIterator实现Iterator接口，然后添加了一些额外的功能，比如添加一个元素，替换一个元素，获取前面或后面的元素的索引位置</li></ul><h3 id="遍历一个-List-有哪些不同的方式，每种方法的实现原理是什么，Java-中-List-遍历的最佳实践是什么"><a href="#遍历一个-List-有哪些不同的方式，每种方法的实现原理是什么，Java-中-List-遍历的最佳实践是什么" class="headerlink" title="遍历一个 List 有哪些不同的方式，每种方法的实现原理是什么，Java 中 List 遍历的最佳实践是什么"></a>遍历一个 List 有哪些不同的方式，每种方法的实现原理是什么，Java 中 List 遍历的最佳实践是什么</h3><p><strong>方式三种：</strong></p><ul><li>for循环遍历，基于计数器。在集合外部维护一个计数器，然后一次读取每个位置的元素，当读取到最后一个元素停止</li><li>迭代器遍历，Iterator。Iterator是面向对象的一个设计模式，目的设计屏蔽不同数据集合的特点，统一遍历集合接口。Java在Collection中支持Iterator模式</li><li>foreach循环遍历。foreach内部也是采用了Iterator的方式实现，使用时不需要显示声明Iterator或计数器。优点：代码简洁，缺点是只能做简单的遍历，不能在遍历过程中操作数据集合（删除，替换）</li></ul><p><strong>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</strong></p><ul><li>推荐做法，支持Random Access的列表可用for循环遍历，否则建议使用Iterator 或 foreach遍历</li><li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li><li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li></ul><h3 id="说一下ArrayList的优缺点"><a href="#说一下ArrayList的优缺点" class="headerlink" title="说一下ArrayList的优缺点"></a>说一下ArrayList的优缺点</h3><ul><li>ArrayList的优点如下<ul><li>ArrayList底层是以数组实现的，是一种随机访问模式。ArrayList实现了RandomAccess接口，因此查找的时候非常快</li><li>ArrayList在顺序添加一个元素的时候非常方便。</li></ul></li><li>ArrayList的缺点<ul><li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能</li><li>插入元素的时候也需要做一次元素复制，缺点同上</li></ul></li><li>ArrayList比较适合顺序添加，随机访问的场景</li></ul><h3 id="如何实现数组和List之间的转换"><a href="#如何实现数组和List之间的转换" class="headerlink" title="如何实现数组和List之间的转换"></a>如何实现数组和List之间的转换</h3><ul><li>数组转List: Arrays.asList(array)进行转换</li><li>List转换数组：使用 List 自带的 toArray() 方法</li></ul><h3 id="ArrayList-和-LinkedList的区别是什么"><a href="#ArrayList-和-LinkedList的区别是什么" class="headerlink" title="ArrayList 和 LinkedList的区别是什么"></a>ArrayList 和 LinkedList的区别是什么</h3><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li><li>LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</li></ul><h3 id="ArrayList-和-Vector-的区别是什么"><a href="#ArrayList-和-Vector-的区别是什么" class="headerlink" title="ArrayList 和 Vector 的区别是什么"></a>ArrayList 和 Vector 的区别是什么</h3><ul><li><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p><ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul></li><li><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p></li><li><p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p></li></ul><h3 id="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？"></a>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</h3><ul><li>ArrayList和Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</li><li>Vector 中的方法由于加了 synchronized 修饰，因此 <strong>Vector</strong> <strong>是线程安全容器，但性能上较ArrayList差</strong>。</li><li>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 <strong>LinkedList</strong> <strong>插入速度较快</strong>。</li></ul><h3 id="多线程场景下如何使用ArrayList"><a href="#多线程场景下如何使用ArrayList" class="headerlink" title="多线程场景下如何使用ArrayList"></a>多线程场景下如何使用ArrayList</h3><ul><li>ArrayList不是线程安全的，如果遇到多线程场景，可以通过Collections 的 synchronizedList 方法将其转换成线程安全的容器在使用</li></ul><h3 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a>List 和 Set 的区别</h3><ul><li>List，Set 都是继承自Collection接口</li><li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li><li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li><li>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</li><li>Set和List对比<ul><li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li><li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</li></ul></li></ul><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><h3 id="说下HashSet的实现原理"><a href="#说下HashSet的实现原理" class="headerlink" title="说下HashSet的实现原理"></a>说下HashSet的实现原理</h3><ul><li>HashSet是基于HashMap实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为present，因此HashSet的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</li></ul><h3 id="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"><a href="#HashSet如何检查重复？HashSet是如何保证数据不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h3><ul><li><p>向HashSet中add()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equals方法比较。</p></li><li><p>HashSet中的add()方法会使用HashMap()的putf()方法</p></li><li><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p></li></ul><h3 id="hashCode（）与equals（）的相关规定："><a href="#hashCode（）与equals（）的相关规定：" class="headerlink" title="hashCode（）与equals（）的相关规定："></a><strong>hashCode（）与equals（）的相关规定</strong>：</h3><ol><li>如果两个对象相等，则hashcode一定也是相同的<ul><li>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值</li></ul></li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals 的区别"></a>== 和 equals 的区别</h3><ul><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例指向的内存空间值是不是相同的</li><li>== 是指对内存地址进行比较 equals()是对字符串</li></ul><h3 id="HashSet-与-HashMap的区别"><a href="#HashSet-与-HashMap的区别" class="headerlink" title="HashSet 与 HashMap的区别"></a>HashSet 与 HashMap的区别</h3><table><thead><tr><th align="center">HashMap</th><th align="center">HashSet</th></tr></thead><tbody><tr><td align="center">实现了Map接口</td><td align="center">实现Set接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用put（）向map中添加元素</td><td align="center">调用add（）方法向Set中添加元素</td></tr><tr><td align="center">HashMap使用键（Key）计算Hashcode</td><td align="center">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td align="center">HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td><td align="center">HashSet较HashMap来说比较慢</td></tr></tbody></table><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><h2 id="什么是Hash算法"><a href="#什么是Hash算法" class="headerlink" title="什么是Hash算法"></a>什么是Hash算法</h2><p>哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值</p><h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><ul><li>链表是可以将物理地址上不连续的数据连接起来，通过指针来对物理地址进行操作，实现增删改查等功能</li><li>链表大致分为单链表和双向链表<ul><li>单链表：每个节点包含两部分，一部分存放数据变量data，另一部分是指向下一个节点的next指针</li><li>双向链表：除了包含单链表的部分，还增加的pre前一个节点的指针</li></ul></li><li>链表的优点：<ul><li>插入删除速度快（因为next指针指向其下一个节点，通过改变指针的指向可以方便的增加删除元素）</li><li>内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时间才创建空间）</li><li>大小没有固定，拓展很灵活</li></ul></li><li>链表的缺点<ul><li>不能随机查找，必须从第一个开始遍历，查找效率低</li></ul></li></ul><h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><ul><li>HashMap：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是他不保证该顺序恒久不变</li><li>HashMap的数据结构：在Java编程语言中，最基本的结构就是两种，一个是数组，另一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个”链表散列”的数据结构，即数组和链表的结合体</li><li>HashMap 基于 Hash 算法实现的<ul><li>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</li><li>存储时，如果出现hash值相同的key，此时有两种情况<ul><li>如果key相同，则覆盖原始值</li><li>如果key不同（出现冲突），则将当前的key-value放入链表中</li></ul></li><li>获取时，直接找到hash值对应的下标，再进一步判断key是否相同，从而找到对应值</li><li>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</li></ul></li><li>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</li></ul><h2 id="HashMap在JDK1-7和JDK1-8中有哪些不同？-HashMap的底层实现"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？-HashMap的底层实现" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？ HashMap的底层实现"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？ HashMap的底层实现</h2><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。</p><p>数组的特点：寻址容易，插入和删除困难</p><p>链表的特点：寻址困难，但插入和删除容易</p><p>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突</p><ul><li><p><strong>HashMap JDK1.8之前</strong></p><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表当中即可。</p></li><li><p><strong>HashMap JDK1.8之后</strong></p><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p></li><li><p><strong>JDK1.7 VS JDK1.8比较</strong></p><p>JDK1.8主要解决或优化了一些问题：</p><ol><li>resize扩容优化</li><li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法</li><li>解决了多线程死循环问题，但仍是非线程安全，多线程可能会造成数据丢失</li></ol></li></ul><h2 id="什么是红黑树"><a href="#什么是红黑树" class="headerlink" title="什么是红黑树"></a>什么是红黑树</h2><p>说道红黑树先讲什么是二叉树： 二叉树简单来说就是每一个节上可以关联两个子节点</p><p><strong>红黑树</strong></p><p>红黑树是一种特殊的二叉查找树。红黑树的每个节点都有存储位表示节点的颜色，可以是红或黑</p><p>红黑树的每个结点是黑色或者红色。当是不管怎么样他的根结点是黑色。每个叶子结点（叶子结点代表终结、结尾的节点）也是黑色 [注意：这里叶子结点，是指为空(NIL或NULL)的叶子结点！]</p><p>如果一个结点是红色的，则它的子结点必须是黑色的。</p><p>每个结点到叶子结点NIL所经过的黑色结点的个数一样的。[确保没有一条路径会比其他路径长出俩倍，所以红黑树是相对接近平衡的二叉树的！]</p><p>红黑树的基本操作是<strong>添加、删除</strong>。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的结点之后，红黑树的结构就发生了变化，可能不满足上面三条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转和变色，可以使这颗树重新成为红黑树。简单点说，旋转和变色的目的是让树保持红黑树的特性。</p><h2 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h2><ul><li>当我们put的时候，首先计算 <code>key</code>的<code>hash</code>值，这里调用了 <code>hash</code>方法，<code>hash</code>方法实际是让<code>key.hashCode()</code>与<code>key.hashCode()&gt;&gt;&gt;16</code>进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<code>index = (table.length - 1) &amp; hash</code>，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</li></ul><h2 id="HashMap的扩容操作是怎么实现的？"><a href="#HashMap的扩容操作是怎么实现的？" class="headerlink" title="HashMap的扩容操作是怎么实现的？"></a>HashMap的扩容操作是怎么实现的？</h2><ul><li><p>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p></li><li><p>每次扩展的时候，都是扩展2倍</p></li><li><p>扩展后Node对象的位置要么是原位置，要么移动到原偏移量两倍的位置</p></li><li><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p></li></ul><h2 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h2><ul><li>Hash，一般翻译为“散列”，也有直接音译为“哈希”的， Hash就是指使用哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。</li><li>hash冲突：当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把他叫做哈希碰撞</li></ul><p><strong>总结</strong></p><p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p><ul><li>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；</li><li>开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</li></ul><h2 id="能否使用任何类作为Map的Key"><a href="#能否使用任何类作为Map的Key" class="headerlink" title="能否使用任何类作为Map的Key"></a>能否使用任何类作为Map的Key</h2><p>可以使用任何类作为Map的Key，然而在使用之前需要考虑一下几点：</p><ul><li>如果类重写了equals()方法，也应该重写hashCode()方法</li><li>类的所有实例需要遵循与euqals()和hashCode()相关的规则</li><li>如果一个类没有使用equals，不应该在hashCode()中使用它</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><h2 id="为什么HashMap中String、Integer这样的包装类适合作为K？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为K？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为K？"></a>为什么HashMap中String、Integer这样的包装类适合作为K？</h2><ul><li>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率<ul><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li></ul></li></ul><h2 id="如果使用Object-作为HashMap的Key，应该怎么办"><a href="#如果使用Object-作为HashMap的Key，应该怎么办" class="headerlink" title="如果使用Object 作为HashMap的Key，应该怎么办"></a>如果使用Object 作为HashMap的Key，应该怎么办</h2><p>答：重写<code>hashCode()</code>和<code>equals()</code>方法</p><p><strong>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</p><p><strong>重写<code>equals()</code>方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</p><h2 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h2><ul><li>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</li><li><strong>那怎么解决呢？</strong><ol><li>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li><li>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li></ol></li></ul><h2 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h2><ul><li>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</li><li><strong>这个算法应该如何设计呢？</strong><ul><li>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</li></ul></li><li><strong>那为什么是两次扰动呢？</strong><ul><li>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</li></ul></li></ul><h2 id="HashMap-与-HashTable-有什么区别？"><a href="#HashMap-与-HashTable-有什么区别？" class="headerlink" title="HashMap 与 HashTable 有什么区别？"></a>HashMap 与 HashTable 有什么区别？</h2><ol><li><p><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</p></li><li><p><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</p></li><li><p><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</p></li><li><p>初始容量大小和每次扩充容量大小的不同</p><p> ：</p><ol><li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</li><li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li></ol></li><li><p><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p></li><li><p>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p></li></ol><h2 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h2><ol><li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li><li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li></ol><h2 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h2><ul><li>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。<ul><li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li>实现线程安全的方式</li><li><strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li><li>② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul></li></ul><h2 id="ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h2><p><strong>JDK1.7</strong></p><ul><li><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p></li><li><p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p></li><li><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735524c5089b8~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li><li><p>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</p><p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</p></li></ul><p><strong>JDK1.8</strong></p><ul><li>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</li></ul><h1 id="辅助工具类"><a href="#辅助工具类" class="headerlink" title="辅助工具类"></a>辅助工具类</h1><h2 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h2><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><h2 id="如何实现-Array-和-List-之间的转换？"><a href="#如何实现-Array-和-List-之间的转换？" class="headerlink" title="如何实现 Array 和 List 之间的转换？"></a>如何实现 Array 和 List 之间的转换？</h2><ul><li>Array 转 List： Arrays. asList(array) ；</li><li>List 转 Array：List 的 toArray() 方法。</li></ul><h2 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h2><ul><li><p>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</p></li><li><p>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</p></li><li><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p></li></ul><h2 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h2><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h2 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h2><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li><li>Collections 工具类的 sort 方法有两种重载的形式，</li><li>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li></ul><p>？</p><ul><li><p>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</p></li><li><p>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</p></li><li><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p></li></ul><h2 id="Collection-和-Collections-有什么区别？-1"><a href="#Collection-和-Collections-有什么区别？-1" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h2><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h2 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？-1"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？-1" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h2><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li><li>Collections 工具类的 sort 方法有两种重载的形式，</li><li>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li><li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;集合容器概述&quot;&gt;&lt;a href=&quot;#集合容器概述&quot; class=&quot;headerlink&quot; title=&quot;集合容器概述&quot;&gt;&lt;/a&gt;集合容器概述&lt;/h1&gt;&lt;h2 id=&quot;什么是集合&quot;&gt;&lt;a href=&quot;#什么是集合&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Collection" scheme="https://leslieaibin.github.io/categories/Collection/"/>
    
    
    <category term="Collection" scheme="https://leslieaibin.github.io/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>04.Spring-Bean</title>
    <link href="https://leslieaibin.github.io/2021/08/07/Spring/04.Spring-Bean/"/>
    <id>https://leslieaibin.github.io/2021/08/07/Spring/04.Spring-Bean/</id>
    <published>2021-08-07T11:17:42.000Z</published>
    <updated>2021-09-17T12:20:29.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bean-的完整生命周期"><a href="#Bean-的完整生命周期" class="headerlink" title="Bean 的完整生命周期"></a><strong>Bean 的完整生命周期</strong></h1><p> 在传统的Java应用中，bean的生命周期很简单，使用Java关键字 new 进行Bean 的实例化，然后该Bean 就能够使用了。一旦bean不再被使用，则由Java自动进行垃圾回收。</p><p> 相比之下，Spring管理Bean的生命周期就复杂多了，正确理解Bean 的生命周期非常重要，因为Spring对Bean的管理可扩展性非常强，下面展示了一个Bean的构造过程</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-8787f1b3800b71f6234e996d432e0a0c_720w.jpg" alt="img"></p><p>Bean 的生命周期</p><p><strong>如上图所示，Bean 的生命周期还是比较复杂的，下面来对上图每一个步骤做文字描述:</strong></p><ul><li><strong>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</strong></li><li><strong>Bean实例化后对将Bean的引入和值注入到Bean的属性中</strong></li><li><strong>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</strong></li><li><strong>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</strong></li><li><strong>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来</strong></li><li><strong>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</strong></li><li><strong>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</strong></li><li><strong>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</strong></li><li><strong>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</strong></li><li><strong>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</strong></li></ul><blockquote><p><strong>上面是Spring 中Bean的核心接口和生命周期，面试回答上述过程已经足够了。但是翻阅JavaDoc文档发现除了以上接口外，还有另外的初始化过程涉及的接口：</strong><br><strong>摘自org.springframework.beans.factory.BeanFactory， 全部相关接口如下，上述已有的就不用着重标注，把额外的相关接口着重标注下</strong></p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-90b0560e479d8e512903b61b6a0c7901_720w.jpg" alt="img"></p><p> Bean 完整的生命周期</p><p>文字解释如下：</p><p>————————————初始化————————————</p><ul><li>BeanNameAware.setBeanName() 在创建此bean的bean工厂中设置bean的名称，在普通属性设置之后调用，在InitializinngBean.afterPropertiesSet()方法之前调用</li><li><code>BeanClassLoaderAware.setBeanClassLoader()</code>: 在普通属性设置之后，InitializingBean.afterPropertiesSet()之前调用</li><li>BeanFactoryAware.setBeanFactory() : 回调提供了自己的bean实例工厂，在普通属性设置之后，在InitializingBean.afterPropertiesSet()或者自定义初始化方法之前调用</li><li><code>EnvironmentAware.setEnvironment()</code>: 设置environment在组件使用时调用</li><li><code>EmbeddedValueResolverAware.setEmbeddedValueResolver()</code>: 设置StringValueResolver 用来解决嵌入式的值域问题</li><li><code>ResourceLoaderAware.setResourceLoader()</code>: 在普通bean对象之后调用，在afterPropertiesSet 或者自定义的init-method 之前调用，在 ApplicationContextAware 之前调用。</li><li><code>ApplicationEventPublisherAware.setApplicationEventPublisher()</code>: 在普通bean属性之后调用，在初始化调用afterPropertiesSet 或者自定义初始化方法之前调用。在 ApplicationContextAware 之前调用。</li><li><code>MessageSourceAware.setMessageSource()</code>: 在普通bean属性之后调用，在初始化调用afterPropertiesSet 或者自定义初始化方法之前调用，在 ApplicationContextAware 之前调用。</li><li>ApplicationContextAware.setApplicationContext(): 在普通Bean对象生成之后调用，在InitializingBean.afterPropertiesSet之前调用或者用户自定义初始化方法之前。在ResourceLoaderAware.setResourceLoader，ApplicationEventPublisherAware.setApplicationEventPublisher，MessageSourceAware之后调用。</li><li><code>ServletContextAware.setServletContext()</code>: 运行时设置ServletContext，在普通bean初始化后调用，在InitializingBean.afterPropertiesSet之前调用，在 ApplicationContextAware 之后调用<strong>注：是在WebApplicationContext 运行时</strong></li><li>BeanPostProcessor.postProcessBeforeInitialization() : 将此BeanPostProcessor 应用于给定的新bean实例 在任何bean初始化回调方法(像是InitializingBean.afterPropertiesSet或者自定义的初始化方法）之前调用。这个bean将要准备填充属性的值。返回的bean示例可能被普通对象包装，默认实现返回是一个bean。</li><li>BeanPostProcessor.postProcessAfterInitialization() : 将此BeanPostProcessor 应用于给定的新bean实例 在任何bean初始化回调方法(像是InitializingBean.afterPropertiesSet或者自定义的初始化方法)之后调用。这个bean将要准备填充属性的值。返回的bean示例可能被普通对象包装</li><li>InitializingBean.afterPropertiesSet(): 被BeanFactory在设置所有bean属性之后调用(并且满足BeanFactory 和 ApplicationContextAware)。</li></ul><p>————————————销毁————————————</p><p>在BeanFactory 关闭的时候，Bean的生命周期会调用如下方法:</p><ul><li><code>DestructionAwareBeanPostProcessor.postProcessBeforeDestruction()</code>: 在销毁之前将此BeanPostProcessor 应用于给定的bean实例。能够调用自定义回调，像是DisposableBean 的销毁和自定义销毁方法，这个回调仅仅适用于工厂中的单例bean(包括内部bean)</li><li>实现了自定义的destory()方法</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Bean-的完整生命周期&quot;&gt;&lt;a href=&quot;#Bean-的完整生命周期&quot; class=&quot;headerlink&quot; title=&quot;Bean 的完整生命周期&quot;&gt;&lt;/a&gt;&lt;strong&gt;Bean 的完整生命周期&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt; 在传统的Java应用中，</summary>
      
    
    
    
    <category term="Spring" scheme="https://leslieaibin.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://leslieaibin.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>03.Spring-AOP</title>
    <link href="https://leslieaibin.github.io/2021/08/06/Spring/03.Spring-AOP/"/>
    <id>https://leslieaibin.github.io/2021/08/06/Spring/03.Spring-AOP/</id>
    <published>2021-08-06T11:17:42.000Z</published>
    <updated>2021-09-17T12:20:17.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于AOP"><a href="#关于AOP" class="headerlink" title="关于AOP"></a>关于AOP</h1><p>面向切面编程(Aspect-oriented Programming，俗称AOP)提供了一种面向对象编程(Object-oriented Programming，俗称OOP)的补充，面向对象编程最核心的单元是类(class)，然而面向切面编程最核心的单元是切面(Aspects)。与面向对象的顺序流程不同，AOP采用的是横向切面的方式，注入与主业务流程无关的功能，例如事务管理和日志管理。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1515111-20200607142722234-1912689830.png" alt="img"></p><p>Spring的一个关键组件是AOP框架。 虽然Spring IoC容器不依赖于AOP（意味着你不需要在IOC中依赖AOP），但AOP为Spring IoC提供了非常强大的中间件解决方案。</p><p>AOP 是一种编程范式，最早由 AOP 联盟的组织提出的，通过<strong>预编译方式和运行期动态代理</strong>实现程序功能的统一维护的一种技术。它是 OOP的延续。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</p><p>我们之间的开发流程都是使用顺序流程，那么使用 AOP 之后，你就可以横向抽取重复代码，什么叫横向抽取呢？或许下面这幅图你能理解，先来看一下传统的软件开发存在什么样风险。</p><p><strong>纵向继承体系</strong>：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1515111-20200607142730437-1498917848.png" alt="img"></p><p>在改进方案之前，我们或许都遇到过 IDEA 对你输出 Duplicate Code 的时候，这个时候的类的设计是很糟糕的，代码写的也很冗余，基本上 if…else… 完成所有事情，这个时候就需要把相同的代码抽取出来成为公共的方法，降低耦合性。这种提取代码的方式是纵向抽取，纵向抽取的代码之间的关联关系非常密切。</p><p>横向抽取也是代码提取的一种方式，不过这种方式不会修改主要业务逻辑代码，只是在此基础上添加一些与主要的业务逻辑无关的功能，AOP 采取横向抽取机制，补充了传统纵向继承体系(OOP)无法解决的重复性 代码优化(性能监视、事务管理、安全检查、缓存)，将业务逻辑和系统处理的代码(关闭连接、事务管理、操作日志记录)解耦。</p><h2 id="AOP的作用"><a href="#AOP的作用" class="headerlink" title="AOP的作用"></a>AOP的作用</h2><p>作用：在不修改源代码的情况下，可以实现功能的增强</p><p>传统的纵向体系代码复用：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20180630172708942" alt="这里写图片描述"></p><p>横向抽取机制（AOP思想）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20180630172800537" alt="这里写图片描述"></p><p>AOP 思想： 基于代理思想，对原来目标对象，创建代理对象，在不修改原对象代码情况下，通过代理对象，调用增强功能的代码，从而对原有业务方法进行增强 ！</p><h2 id="AOP应用场景"><a href="#AOP应用场景" class="headerlink" title="AOP应用场景"></a>AOP应用场景</h2><ul><li>记录日志<ul><li>场景二： 监控方法运行时间 （监控性能）</li><li>场景三： 权限控制</li><li>场景四： 缓存优化 （第一次调用查询数据库，将查询结果放入内存对象， 第二次调用， 直接从内存对象返回，不需要查询数据库 ）</li><li>场景五： 事务管理 （调用方法前开启事务， 调用方法后提交关闭事务 ）</li></ul></li></ul><h1 id="AOP的实现原理"><a href="#AOP的实现原理" class="headerlink" title="AOP的实现原理"></a>AOP的实现原理</h1><p>那Spring中AOP是怎么实现的呢？Spring中AOP的有两种实现方式：</p><ul><li>JDK动态代理</li><li>Cglib动态代理</li></ul><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><ul><li><p>引入依赖，有spring，单元测，日志管理</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!-- Spring --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 单元测试 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 日志 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserDao实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userDaoImp</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;持久层：用户保存&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">    <span class="comment">// newProxyInstance的三个参数解释</span></span><br><span class="line">    <span class="comment">// 参数1: 代理类加载器，同目标类的类加载器</span></span><br><span class="line">    <span class="comment">// 参数2: 代理类要实现的接口列表，同目标实现的接口列表</span></span><br><span class="line">    <span class="comment">// 参数3：回调，是一个InvocationHandler接口的实现对象，当调用代理对象的方法时，执行的是回调中的invoke方法</span></span><br><span class="line">    <span class="comment">// proxy为代理对象</span></span><br><span class="line">    UserDao proxy = (UserDao) Proxy.newProxyInstance(</span><br><span class="line">        userDao.getClass().getClassLoader(),</span><br><span class="line">    userDao.getClass().getInterfaces(),</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// 参数proxy: 被代理的对象</span></span><br><span class="line">            <span class="comment">// 参数method: 执行的方法，代理对象执行那个方法，method就是那个方法</span></span><br><span class="line">            <span class="comment">// 参数args: 执行方法的参数</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args )</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;记录日志&quot;</span>);</span><br><span class="line">                Object result = method.invoke(userDao, args);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//代理对象执行方法</span></span><br><span class="line">    proxy.saveUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果 </p><p>在没有修改原来类的代码的情况下，对原有类的功能进行了增强</p></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20180630183349483" alt="这里写图片描述"></p><h2 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h2><p>在实际开发中，可能需要对没有实现接口的类增强，用JDK动态代理的方式就没法实现，采用CGlib动态代理可能对没有实现接口的类产生代理，实际上是生成了目标类的子类来增强</p><p>首先，需要导入Cglib所需的jar包。</p><ul><li><p>创建LinkManDao类，没有实现任何接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkManDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;持久层：联系人保存。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LinkManDao linkManDao = <span class="keyword">new</span> LinkManDao();</span><br><span class="line">    <span class="comment">// 创建cglib核心对象</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="comment">// 设置父类</span></span><br><span class="line">    enhancer.setSuperclass(linkManDao.getClass());</span><br><span class="line">    <span class="comment">// 设置回调</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor()&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 当你调用目标方法时，实质上是调用该方法</span></span><br><span class="line"><span class="comment">       * proxy:代理对象</span></span><br><span class="line"><span class="comment">       * method: 目标方法</span></span><br><span class="line"><span class="comment">       * args： 目标方法的形参</span></span><br><span class="line"><span class="comment">       * methodProxy: 代理方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Method method, </span></span></span><br><span class="line"><span class="function"><span class="params">                                Object[] args, </span></span></span><br><span class="line"><span class="function"><span class="params">                                MethodProxy methodProxy)</span><span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">            System.out.<span class="title">println</span><span class="params">(<span class="string">&quot;记录日志&quot;</span>)</span></span>;</span><br><span class="line">        Object result = method.invoke(linkManDao, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    LinkManDao proxy = (LinkManDao) enhancer.create();</span><br><span class="line">    proxy.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20180630185628828" alt="这里写图片描述"></p></li></ul><h1 id="应用：-Transactional-注解"><a href="#应用：-Transactional-注解" class="headerlink" title="应用：@Transactional 注解"></a>应用：@Transactional 注解</h1><p><code>@Transactional</code>是spring中声明式事务管理的注解配置方式，相信这个注解的作用大家都很清楚。<code>@Transactional</code>注解可以帮助我们把事务开启、提交或者回滚的操作，通过aop的方式进行管理。</p><p>通过<code>@Transactional</code>注解就能让spring为我们管理事务，免去了重复的事务管理逻辑，减少对业务代码的侵入，使我们开发人员能够专注于业务层面开发。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210917201024599.png" alt="image-20210917201024599"></p><p>我们知道实现@Transactional原理是基于spring aop，aop又是动态代理模式的实现，通过对源码的阅读，总结出下面的步骤来了解实际中，在spring 是如何利用aop来实现@Transactional的功能的。</p><h2 id="spring中声明式事务实现原理猜想"><a href="#spring中声明式事务实现原理猜想" class="headerlink" title="spring中声明式事务实现原理猜想"></a><strong>spring中声明式事务实现原理猜想</strong></h2><p>首先，对于spring中aop实现原理有了解的话，应该知道想要对一个方法进行代理的话，肯定需要定义切点。在@Transactional的实现中，同样如此，spring为我们定义了以 @Transactional 注解为植入点的切点，这样才能知道@Transactional注解标注的方法需要被代理。</p><p>有了切面定义之后，在spring的bean的初始化过程中，就需要对实例化的bean进行代理，并且生成代理对象。</p><p>生成代理对象的代理逻辑中，进行方法调用时，需要先获取切面逻辑，@Transactional注解的切面逻辑类似于@Around，在spring中是实现一种类似代理逻辑。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210917201203887.png" alt="image-20210917201203887"></p><h2 id="Transactional作用"><a href="#Transactional作用" class="headerlink" title="@Transactional作用"></a><strong>@Transactional作用</strong></h2><p>首先是@Transactional，作用是定义代理植入点。我们知道代理对象创建的通过<code>BeanPostProcessor</code>的实现类<code>AnnotationAwareAspectJAutoProxyCreator</code>的<code>postProcessAfterInstantiation</code>方法来实现个，如果需要进行代理，那么在这个方法就会返回一个代理对象给容器，同时判断植入点也是在这个方法中。</p><p>那么下面开始分析，在配置好注解驱动方式的事务管理之后，spring会在ioc容器创建一个<code>BeanFactoryTransactionAttributeSourceAdvisor</code>实例，这个实例可以看作是一个切点，在判断一个bean在初始化过程中是否需要创建代理对象，都需要验证一次<code>BeanFactoryTransactionAttributeSourceAdvisor</code>是否是适用这个bean的切点。如果是，就需要创建代理对象，并且把<code>BeanFactoryTransactionAttributeSourceAdvisor</code>实例注入到代理对象中。</p><p>前文我们知道在<code>AopUtils#findAdvisorsThatCanApply</code>中判断切面是否适用当前bean，可以在这个地方断点分析调用堆栈，<code>AopUtils#findAdvisorsThatCanApply</code>一致调用，最终通过以下代码判断是否适用切点。</p><ul><li><code>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute(Method method, Class&lt;?&gt; targetClass)</code> 这里可以根据参数打上条件断点进行调试分析调用栈，targetClass就是目标class …一系列调用</li><li>最终<code>SpringTransactionAnnotationParser#parseTransactionAnnotation(java.lang.reflect.AnnotatedElement)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotatedElement ae)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里就是分析Method是否被@Transactional注解标注，有的话，不用说BeanFactoryTransactionAttributeSourceAdvisor适配当前bean，进行代理，并且注入切点</span></span><br><span class="line">    <span class="comment">//BeanFactoryTransactionAttributeSourceAdvisor</span></span><br><span class="line">   AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ae, Transactional.class);</span><br><span class="line">   <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseTransactionAnnotation(attributes);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是判断是否需要根据@Transactional进行代理对象创建的判断过程。@Transactional的作用一个就是标识方法需要被代理，一个就是携带事务管理需要的一些属性信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于AOP&quot;&gt;&lt;a href=&quot;#关于AOP&quot; class=&quot;headerlink&quot; title=&quot;关于AOP&quot;&gt;&lt;/a&gt;关于AOP&lt;/h1&gt;&lt;p&gt;面向切面编程(Aspect-oriented Programming，俗称AOP)提供了一种面向对象编程(Objec</summary>
      
    
    
    
    <category term="Spring" scheme="https://leslieaibin.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://leslieaibin.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
