<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Ai</title>
  
  <subtitle>春暖花开去见你</subtitle>
  <link href="https://leslieaibin.github.io/atom.xml" rel="self"/>
  
  <link href="https://leslieaibin.github.io/"/>
  <updated>2022-05-24T03:08:27.912Z</updated>
  <id>https://leslieaibin.github.io/</id>
  
  <author>
    <name>Leslie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>05.编写Netty应用程序</title>
    <link href="https://leslieaibin.github.io/2022/05/23/Netty/05.Netty%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/"/>
    <id>https://leslieaibin.github.io/2022/05/23/Netty/05.Netty%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/</id>
    <published>2022-05-23T11:15:42.000Z</published>
    <updated>2022-05-24T03:08:27.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="05-Netty服务启动"><a href="#05-Netty服务启动" class="headerlink" title="05.Netty服务启动"></a>05.Netty服务启动</h1><p>之前讲过的 EchoServer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 声明线程池</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EchoServerHandler echoServerHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 服务端引导器</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">// 3. 设置线程池</span></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 4. 设置ServerSocketChannel的类型</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 5. 设置参数</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">                    <span class="comment">// 6. 设置ServerSocketChannel对应的Handler，只能设置一个</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// 7. 设置SocketChannel对应的Handler</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline p = ch.pipeline();</span><br><span class="line">                            <span class="comment">// 可以添加多个子Handler</span></span><br><span class="line">                            p.addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">                            p.addLast(echoServerHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 绑定端口</span></span><br><span class="line">            ChannelFuture f = serverBootstrap.bind(PORT).sync();</span><br><span class="line">            <span class="comment">// 9. 等待服务端监听端口关闭，这里会阻塞主线程</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 10. 优雅地关闭两个线程池</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>通过前面使用案例的学习，我们知道，Netty 启动的时候主要是下面这行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f = serverBootstrap.bind(PORT).sync();</span><br></pre></td></tr></table></figure><p>这里主要有两个方法，一个是 bind ()，一个是 sync ()，sync () 属于 ChannelFuture 的范畴，我们之后再说：</p><ol><li> Netty 的 Channel 跟 Java 原生的 Channel 是否有某种关系？</li><li> bind () 是否调用了 Java 底层的 Socket 相关的操作？</li><li> Netty 服务启动之后 ChannelPipeline 里面长什么样？</li></ol><p>好了，让我们带着这几个问题探索吧。</p><h2 id="服务启动过程剖析"><a href="#服务启动过程剖析" class="headerlink" title="服务启动过程剖析"></a>服务启动过程剖析</h2><p>让我们将断点打在 <code>ChannelFuture f = serverBootstrap.bind(PORT).sync();</code> 这行，以 Debug 模式启动程序，程序会停在此处，按 F7 或者 Shirft+F7 进入 bind () 方法内部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们只传进来了一个端口，而使用 <code>InetSocketAddress</code> 类构造了一个地址，默认的，会生成一个 <code>0.0.0.0:8007</code> 的地址。</p><p>接着往下走，会来到一个叫 <code>doBind()</code> 的方法，一般地，在开源框架中带 <code>doXxx</code> 开头的方法都是干正事的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key1，初始化并注册什么呢？</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="comment">// 注册失败</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已完成，上面未失败，所以这里是已完成且成功了</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        <span class="comment">// key2，绑定什么呢？取决于initAndRegister()中异步执行的快慢，所以不一定到这里，这里可以打一个断点</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未完成</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        <span class="comment">// 设置回调等待完成，回调内部处理注册的结果</span></span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="comment">// 注册失败</span></span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 注册成功</span></span><br><span class="line">                    promise.registered();</span><br><span class="line">                    <span class="comment">// key2，绑定什么呢？取决于initAndRegister()中异步执行的快慢，所以不一定到这里，这里可以打一个断点</span></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关键方法，我前面加上一个 <code>key</code> 表示。</p></blockquote><p><code>doBind()</code> 主要干了两件事：</p><ul><li>  initAndRegister ()，初始化并注册什么呢？</li><li>  doBind0 ()，到底绑定的是什么？</li></ul><p>让我们继续跟进到 <code>initAndRegister()</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// key1，通过ChannelFactory创建一个Channel，使用反射的形式创建一个Channel</span></span><br><span class="line">        <span class="comment">// 反射的类为我们第4步中设置的NioServerSocketChannel.class</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// key2，初始化Channel，干了些什么？</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常处理，可以不看</span></span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key3，注册Channel到哪里？这里有个group()，难道是EventLoopGroup？</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="comment">// 失败了，关闭Channel</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initAndRegister</code> 主要干了三个事：</p><ul><li><p>  channelFactory.newChannel ()，通过反射的形式创建 Channel，而且是无参构造方法，new 的时候做了哪些事儿？</p></li><li><p>  <code>init(channel)</code>，初始化 Channel 的什么？</p></li><li><p>  <code>register(channel)</code>，注册 Channel 到哪里？</p></li></ul><p>因为我们这里使用的是 NioServerSocketChannel，所以，直接查看它的无参构造方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 无参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.1 使用Java底层的SelectorProvider创建一个Java原生的ServerSocketChannel</span></span><br><span class="line"><span class="comment">// windows平台下使用的是WindowsSelectorProvider，因为ServerSocketChannel是跟操作系统交互的，所以是平台相关的，每个平台下都不一样</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// key，创建Java原生ServerSocketChannel</span></span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">            <span class="string">&quot;Failed to open a server socket.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.2 有参构造方法，参数是Java原生的ServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造方法，注意parent参数为null</span></span><br><span class="line">    <span class="comment">// key，感兴趣的事件为Accept事件</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="comment">// 创建ChannelConfig</span></span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.2.1 调用父类构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioMessageChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, readInterestOp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.2.1.1 调用父类父类的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造方法，parent为null</span></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">// ch为Java原生的Channel</span></span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="comment">// 感兴趣的事件，这里为Accept事件</span></span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将channel设置为非阻塞（是不是跟NIO案例中的用法一样？！）</span></span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                <span class="string">&quot;Failed to close a partially initialized socket.&quot;</span>, e2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Failed to enter non-blocking mode.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  1.2.1.1.1 调用父类父类父类的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时parent为null</span></span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="comment">// 赋予一个id</span></span><br><span class="line">    id = newId();</span><br><span class="line">    <span class="comment">// 赋值了一个unsafe，非Java的Unsafe，而是Netty自己的Unsafe</span></span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    <span class="comment">// 创建ChannelPipeline</span></span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.2.1.1.1.1 创建默认的ChannelPipeline</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// ChannelPipeline中默认有两个节点，head和tail，且是双向链表</span></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里 NioServerSocketChannel 的创建过程就完毕了，我们简单总结一下：</p><ol><li> Netty 的 ServerSocketChannel 会与 Java 原生的 ServerSocketChannel 绑定在一起；</li><li> 会注册 Accept 事件；</li><li> 会为每一个 Channel 分配一个 id；</li><li> 会为每一个 Channel 创建一个叫作 unsafe 的东西；</li><li> 会为每一个 Channel 分配一个 ChannelPipeline；</li><li> ChannelPipeline 中默认存在一个双向链表 <code>head&lt;=&gt;tail</code>；</li></ol><p>好了，再来看 <code>init(channel)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.bootstrap.ServerBootstrap#init</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将第5步中设置到ServerBootstrap中的Option设置到Channel的Config中</span></span><br><span class="line">    setChannelOptions(channel, options0().entrySet().toArray(EMPTY_OPTION_ARRAY), logger);</span><br><span class="line">    <span class="comment">// 设置一些属性到Channel中，用法与Option一样</span></span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));</span><br><span class="line">    <span class="comment">// 从Channel中取出ChannelPipeline，上面创建的</span></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子Channel的配置，子Channel也就是SocketChannel</span></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions =</span><br><span class="line">        childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将ServerBootstrap中的Handler设置到ChannelPipeline的最后</span></span><br><span class="line">    <span class="comment">// ChannelInitializer的实现原理？</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            <span class="comment">// 第6步设置的Handler</span></span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 同时，又向ChannelPipeline的最后添加了一个叫作ServerBootstrapAcceptor的Handler</span></span><br><span class="line">            <span class="comment">// 这是什么写法？</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 把子Channel相关的参数传到这个Handler里面，那它是干什么的呢？</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init(channel)</code> 方法整体来说还是比较简单的，就是把 ServerBootstrap 中的配置设置到 Channel 中，不过依然有几处我们现在可能还不太理解的地方：</p><ul><li>  ChannelInitializer 的实现原理是什么？</li><li>  <code>ch.eventLoop().execute()</code> 这是什么写法？</li><li>  ServerBootstrapAcceptor 是干什么？</li></ul><p>这三个问题，我们留到后面的章节中再解答。</p><p>好了，我们再来看看 <code>initAndRegister()</code> 方法的最后一个关键步骤，<code>ChannelFuture regFuture = config().group().register(channel);</code> 注册 Channel 到什么地方？</p><p>查看源码，可以发现，这里的 group 就是我们的 bossGroup，所以这里就是调用 bossGroup 的 <code>register(channel)</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用 <code>next()</code> 方法选择出来一个 EventLoop 来注册 Channel，里面实际上使用的是一个叫做 <code>EventExecutorChooser</code> 的东西来选择，它实际上又有两种实现方式 ——<code>PowerOfTwoEventExecutorChooser</code> 和 <code>GenericEventExecutorChooser</code>，本质上就是从 EventExecutor 数组中选择一个 EventExecutor，我们这里就是 NioEventLoop，那么，它们有什么区别呢？有兴趣的可以点开它们的源码看看，我简单地提一下，本质都是按数组长度取余数 ，不过，2 的 N 次方的形式更高效。</p><p>最后，来到了 EventLoop 的 <code>register(channel)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.Channel)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    <span class="comment">// key，调用的是channel的unsafe的register()方法</span></span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，先创建了一个叫做 <code>ChannelPromise</code> 的东西，它是 ChannelFuture 的子类，暂时先把它当作 ChannelFuture 来看待。最后，又调回了 Channel 的 Unsafe 的 register () 方法，这里第一个参数是 this，也就是 NioEventLoop，第二个参数是刚创建的 ChannelPromise。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.AbstractChannel.AbstractUnsafe#register</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 各种检查，可以跳过</span></span><br><span class="line">    ObjectUtil.checkNotNull(eventLoop, <span class="string">&quot;eventLoop&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registered to an event loop already&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">            <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key1，将上面传进来的EventLoop绑定到Channel上</span></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">    <span class="comment">// 判断当前线程是否跟EventLoop线程是同一个</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// key2，调用register0</span></span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// key2，调用register0，实际走的是这里，所以这里需要打个断点</span></span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 异常处理，可以跳过</span></span><br><span class="line">            logger.warn(</span><br><span class="line">                <span class="string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,</span><br><span class="line">                AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要干了两件事：</p><ul><li>  把 EventLoop 与 Channel 绑定在一起；</li><li>  调用 register0 () 方法；</li></ul><p>这里又出现了 eventLoop.execute () 这种写法，先忽略它，专注于主要逻辑。</p><p>接着，跟踪到 <code>register0()</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.AbstractChannel.AbstractUnsafe#register0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断检查，可以跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        <span class="comment">// key1，调用doRegister()方法</span></span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key2，调用invokeHandlerAddedIfNeeded()</span></span><br><span class="line">        <span class="comment">// 触发添加Handler的回调，其中pineline.addLast(ChannelInitializer)的处理就是在这一步完成的</span></span><br><span class="line">        <span class="comment">// 这一步之后pipeline里面应该是head&lt;=&gt;LoggineHandler&lt;=&gt;tail</span></span><br><span class="line">        <span class="comment">// 而ServerBootstrapAcceptor还没有加入到pipeline中，</span></span><br><span class="line">        <span class="comment">// 因为它设置了使用EventLoop的线程执行，当前线程就是EventLoop的线程</span></span><br><span class="line">        <span class="comment">// 所以，添加ServerBootstrapAcceptor会在当前任务执行完毕才会执行</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        <span class="comment">// 调用ChannelPineline的fireChannelRegistered()，实际是调用的各个ChannelHandler的channelRegistered()方法</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="comment">// Channel是否已经激活，此时还未绑定到具体的地址，所以还未激活</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常处理，可以跳过</span></span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>这里有两个个非常重要的方法：</p><ul><li>  doRegister ()，一看就是干正事的方法</li><li>  pipeline.invokeHandlerAddedIfNeeded ()，触发添加 Handler 的回调，其中 pineline.addLast (ChannelInitializer) 的处理就是在这一步完成的，有兴趣的同学可以跟踪看一下，这一块我们本节不详细展开</li></ul><p>先来看 <code>doRegister()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.nio.AbstractNioChannel#doRegister</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// key，将EventLoop中的Selector与Java原生的Channel绑定在一起，并返回这个SelectionKey</span></span><br><span class="line">            <span class="comment">// 注意，第三个参数是this，代表的是当前这个Netty中的Channel，我们这里就是NioServerSocketChannel</span></span><br><span class="line">            <span class="comment">// 它作为Selection的attachment绑定到SelectionKey上，与JavaChannel和Selector是同一个级别的</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理，可以跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实就一行关键代码，将 Selector 与 Java 原生 Channel 绑定在一起，并将当前 Netty 的 Channel 通过 attachment 的形式绑定到 SelectionKey 上，到这里，你可能会有疑问：为什么要把 Netty 的 Channel 当作附件放到 SelectionKey 中呢？后面你会知道的，相信我。</p><p>所以，整个注册的过程主要就干了三个事：</p><ol><li> 把 Channel 绑定到一个 EventLoop 上；</li><li> 把 Java 原生 Channel、Netty 的 Channel、Selector 绑定到 SelectionKey 中；</li><li> 触发 Register 相关的事件；</li></ol><p>至此，<code>initAndRegister()</code> 方法内部就分析完成了，我们再来看看另一个重要方法 <code>doBind0()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. io.netty.bootstrap.AbstractBootstrap#doBind0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步执行</span></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                <span class="comment">// key，调用Channel的bind()方法，因为在线程池里面，所以这里要打一个断点</span></span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 调用Channel的bind()方法 io.netty.channel.AbstractChannel#bind(java.net.SocketAddress, io.netty.channel.ChannelPromise)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用的是pipeline的bind()方法</span></span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 调用的是pipeline的bind()方法io.netty.channel.DefaultChannelPipeline#bind(java.net.SocketAddress, io.netty.channel.ChannelPromise)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从尾开始调用，也就是outbound</span></span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 此时pipeline中的Handler为head&lt;=&gt;LoggingHandler&lt;=&gt;ServerBootstrapAcceptor&lt;=&gt;tail，出站的pineple实际为tail=&gt;LoggingHandler=&gt;head，下面我只贴主要代码</span></span><br><span class="line"><span class="comment">// 5. io.netty.handler.logging.LoggingHandler#bind</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isEnabled(internalLevel)) &#123;</span><br><span class="line">        logger.log(internalLevel, format(ctx, <span class="string">&quot;BIND&quot;</span>, localAddress));</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6. io.netty.channel.DefaultChannelPipeline.HeadContext#bind</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最后调用的是HeadContext这个Handler中unsafe的bind()方法</span></span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7. io.netty.channel.AbstractChannel.AbstractUnsafe#bind</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// key，绑定地址</span></span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 成功激活，调用pipeline.fireChannelActive()方法</span></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置promise为成功状态</span></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8. 绕了一圈，最后又回到了NioServerChannel的doBind()方法 io.netty.channel.socket.nio.NioServerSocketChannel#doBind</span></span><br><span class="line"><span class="meta">@SuppressJava6Requirement(reason = &quot;Usage guarded by java version check&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 根据不同的JDK版本调用不同的方法</span></span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="comment">// 我使用的JDK8版本，所以走到这里了</span></span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>doBind0()</code> 最后也是通过 Java 原生 Channel 的 bind () 方法来实现的。</p><p>最后，我们来总结一下整个服务启动的过程，服务启动主要是通过两个主要的大方法来完成的：</p><ol><li>initAndRegister ()，初始化并注册什么呢？<ul><li>channelFactory.newChannel()<ul><li>  通过反射创建一个 NioServerSocketChannel</li><li>  将 Java 原生 Channel 绑定到 NettyChannel 中</li><li>  注册 Accept 事件</li><li>  为 Channel 分配 id</li><li>  为 Channel 创建 unsafe</li><li>  为 Channel 创建 ChannelPipeline（默认是 head&lt;=&gt;tail 的双向链表）</li></ul></li><li>init(channel)<ul><li>  把 ServerBootstrap 中的配置设置到 Channel 中</li><li>  添加 ServerBootstrapAcceptor 这个 Handler</li></ul></li><li>register(channel)<ul><li>  把 Channel 绑定到一个 EventLoop 上</li><li>  把 Java 原生 Channel、Netty 的 Channel、Selector 绑定到 SelectionKey 中</li><li>  触发 Register 相关的事件</li></ul></li></ul></li><li>doBind0 ()，到底绑定的是什么？<ul><li>  通过 Java 原生 Channel 绑定到一个本地地址上</li></ul></li></ol><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=http://img1.sycdn.imooc.com/5f1805890001d7af18450993.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;05-Netty服务启动&quot;&gt;&lt;a href=&quot;#05-Netty服务启动&quot; class=&quot;headerlink&quot; title=&quot;05.Netty服务启动&quot;&gt;&lt;/a&gt;05.Netty服务启动&lt;/h1&gt;&lt;p&gt;之前讲过的 EchoServer：&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>04.编写Netty应用程序</title>
    <link href="https://leslieaibin.github.io/2022/05/17/Netty/04.%E7%BC%96%E5%86%99Netty%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://leslieaibin.github.io/2022/05/17/Netty/04.%E7%BC%96%E5%86%99Netty%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-05-17T11:15:42.000Z</published>
    <updated>2022-05-17T06:52:00.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编写Netty应用程序"><a href="#编写Netty应用程序" class="headerlink" title="编写Netty应用程序"></a>编写Netty应用程序</h1><p>从 <code>netty-example</code> 工程下抄了一份 EchoServer 过来，并删减了部分代码，归纳出来一份编写 Netty 服务端程序的模板，我把它称为 “Netty 编码十步曲”。</p><h2 id="1-声明线程池（必须）"><a href="#1-声明线程池（必须）" class="headerlink" title="1. 声明线程池（必须）"></a>1. 声明线程池（必须）</h2><p>一般来说，我们会声明两个 Group，一个是 bossGroup，用于处理 Accept 事件，一个是 workerGroup，用于处理消息的读写事件。其中，bossGroup 一般声明为一个线程。当然，如果声明一个 Group 也是可以的，只是不建议。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure><p>这就像是大型餐厅一般有接待生和服务员两种职位一样，接待生一般形象良好，专门负责接待客人，服务员形象稍差，专门负责上菜收碟，你要说不区分两种职位，混用行不行呢，当然也可以，只是不建议，专人干专事。</p><h2 id="2-创建服务端引导类（必须）"><a href="#2-创建服务端引导类（必须）" class="headerlink" title="2. 创建服务端引导类（必须）"></a>2. 创建服务端引导类（必须）</h2><p>引导类，是用来集成所有配置，引导程序加载的，分成两种，一种是客户端引导类 Bootstrap（个人觉得叫 ClientBootstrap 可能更贴切），另一种是服务端引导类 ServerBootstrap，我们这里编写的是服务端程序，创建的当然是服务端引导类。<br>注意，Bootstrap 和 ServerBootstrap 之间并不是继承关系，他们是平等的，都继承了 AbstractBootstrap 抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br></pre></td></tr></table></figure><p>Bootstrap/ServerBootstrap 就像是店长，它负责统筹整个 Netty 程序的正常运行。</p><h2 id="3-设置线程池（必须）"><a href="#3-设置线程池（必须）" class="headerlink" title="3. 设置线程池（必须）"></a>3. 设置线程池（必须）</h2><p>把第一步声明的线程池设置到 ServerBootstrap 中，它说明了 Netty 应用程序以什么样的线程模型运行，正如前面所说 bossGroup 负责接受（Accept）连接，workerGroup 负责读写数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure><h2 id="4-设置-ServerSocketChannel-类型（必须）"><a href="#4-设置-ServerSocketChannel-类型（必须）" class="headerlink" title="4. 设置 ServerSocketChannel 类型（必须）"></a>4. 设置 ServerSocketChannel 类型（必须）</h2><p>设置 Netty 程序以什么样的 IO 模型运行，我们这里介绍的是 NIO 编程，选择的当然是 NioServerSocketChannel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.channel(NioServerSocketChannel.class);</span><br></pre></td></tr></table></figure><p>如果您需要使用阻塞型 IO 模型，直接把 Nio 改成 Oio 就可以了，即 OioServerSocketChannel，不过它已经废弃了，所以不建议。</p><p>另外，如果您的程序运行在 Linux 系统上，还可以使用一种更高效的方式，即 EpollServerSocketChannel，它使用的是 Linux 系统上的 epoll 模型，比 select 模型更高效，可见 Netty 把性能优化做到了极致。</p><h2 id="5-设置参数（可选）"><a href="#5-设置参数（可选）" class="headerlink" title="5. 设置参数（可选）"></a>5. 设置参数（可选）</h2><p>设置 Netty 中可以使用的任何参数，这些参数都在 ChannelOption 及其子类中，后面我们会详细介绍各个参数的含义，不过，很遗憾地告诉你，大多数情况下并不需要修改 Netty 的默认参数，这就是 Netty 比较牛的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.option(ChannelOption.SO_BACKLOG, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>我们这里设置了一个 SO_BACKLOG 系统参数，它表示的是最大等待连接数量。</p><h2 id="6-设置-Handler（可选）"><a href="#6-设置-Handler（可选）" class="headerlink" title="6. 设置 Handler（可选）"></a>6. 设置 Handler（可选）</h2><p>设置 ServerSocketChannel 对应的 Handler，注意只能设置一个，它会在 SocketChannel 建立起来之前执行，等我们看源码的时候会详细介绍它的执行时机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br></pre></td></tr></table></figure><p>我们这里简单地设置一个打印日志的 Handler。</p><h2 id="7-编写并设置子-Handler（必须）"><a href="#7-编写并设置子-Handler（必须）" class="headerlink" title="7. 编写并设置子 Handler（必须）"></a>7. 编写并设置子 Handler（必须）</h2><p>Netty 中的 Handler 分成两种，一种叫做 Inbound，一种叫做 Outbound。我们这里简单地写一个 Inbound 类型的 Handler，它接收到数据后立即写回客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 读取数据后写回客户端</span></span><br><span class="line">ctx.write(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">ctx.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">cause.printStackTrace();</span><br><span class="line">ctx.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置子 Handler 设置的是 SocketChannel 对应的 Handler，注意也是只能设置一个，它用于处理 SocketChannel 的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ChannelPipeline p = ch.pipeline();</span><br><span class="line"><span class="comment">// 可以添加多个子Handler</span></span><br><span class="line">p.addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">p.addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>虽然只能设置一个，但是 Netty 的提供了一种可以设置多个 Handler 的途径，即使用 ChannelInitializer 方式，当然，第六步的设置 Handler 也可以使用这种方式设置多个 Handler。</p><p>这里，我们设置了一个打印的 Handler 和一个自定义的 EchoServerHandler。</p><h2 id="8-绑定端口（必须）"><a href="#8-绑定端口（必须）" class="headerlink" title="8. 绑定端口（必须）"></a>8. 绑定端口（必须）</h2><p>绑定端口，并启动服务端程序，sync () 会阻塞直到启动完成才执行后面的代码。</p><pre><code>ChannelFuture f = serverBootstrap.bind(PORT).sync();</code></pre><h2 id="9-等待服务端端口关闭（必须）"><a href="#9-等待服务端端口关闭（必须）" class="headerlink" title="9. 等待服务端端口关闭（必须）"></a>9. 等待服务端端口关闭（必须）</h2><p>等待服务端监听端口关闭，sync () 会阻塞主线程，内部调用的是 Object 的 wait () 方法。</p><pre><code>f.channel().closeFuture().sync();</code></pre><h2 id="10-优雅地关闭线程池（建议）"><a href="#10-优雅地关闭线程池（建议）" class="headerlink" title="10. 优雅地关闭线程池（建议）"></a>10. 优雅地关闭线程池（建议）</h2><p>最后，是在 finally 中调用 shutdownGracefully () 方法优雅地关闭线程池，优雅停机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bossGroup.shutdownGracefully();</span><br><span class="line">workerGroup.shutdownGracefully();</span><br></pre></td></tr></table></figure><p><strong>为什么需要设置 ServerSocketChannel 的类型，而不需要设置 SocketChannel 的类型呢？</strong></p><p>那是因为 SocketChannel 是 ServerSocketChannel 在接受连接之后创建出来的，所以，并不需要单独再设置它的类型，比如，NioServerSocketChannel 创建出来的肯定是 NioSocketChannel，而 EpollServerSocketChannel 创建出来的肯定是 EpollSocketChannel。</p><h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><p>其实学 Netty 的 99% 都是服务端的同学，所以，我们的课程并不会刻意介绍如何编写客户端的 Netty 程序，但是我们怎么调试呢？</p><p>这里，我教给大家一个技巧，通过 XSHELL 这个工具调试，这个工具几乎是后端同学必备的一个工具，所以调试起来也是比较容易的。</p><p>比如，我上面启动了一个 Netty 服务端，它的端口是 8007，只要打开 Terminal，不要连接任何服务器，输入以下代码即可连接到我们的 Netty 服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 8007</span><br></pre></td></tr></table></figure><p>然后，输入任何你想输入的内容，它都会照样返回，比如下面这样：</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220517144316303.png" alt="image-20220517144316303"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本节，我们学习了 Netty 编码的十步曲，其中，有些步骤是必须的，有些步骤可选的，有些步骤是建议保留的，相信通过本节的学习，你一定可以写出十分健壮且优雅的 Netty 服务端程序了。</p><p>别急哦，本节还没有结束，在附录部分有一份简单的群聊系统，您也可以尝试按照本节介绍的十步曲自己尝试写一个简单的示例练练手。</p><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img1.sycdn.imooc.com/5f0d610d0001afcc10830670.png"></p><h2 id="附录-——-使用-Netty-实现简单群聊系统"><a href="#附录-——-使用-Netty-实现简单群聊系统" class="headerlink" title="附录 —— 使用 Netty 实现简单群聊系统"></a>附录 —— 使用 Netty 实现简单群聊系统</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 1. 声明线程池</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 2. 服务端引导器</span></span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"><span class="comment">// 3. 设置线程池</span></span><br><span class="line">serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line"><span class="comment">// 4. 设置ServerSocketChannel的类型</span></span><br><span class="line">.channel(NioServerSocketChannel.class)</span><br><span class="line"><span class="comment">// 5. 设置参数</span></span><br><span class="line">.option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line"><span class="comment">// 6. 设置ServerSocketChannel对应的Handler，只能设置一个</span></span><br><span class="line">.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line"><span class="comment">// 7. 设置SocketChannel对应的Handler</span></span><br><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ChannelPipeline p = ch.pipeline();</span><br><span class="line"><span class="comment">// 可以添加多个子Handler</span></span><br><span class="line">p.addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line"><span class="comment">// 只需要改这一个地方就可以了</span></span><br><span class="line">p.addLast(<span class="keyword">new</span> ChatNettyHandler());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 绑定端口</span></span><br><span class="line">ChannelFuture f = serverBootstrap.bind(PORT).sync();</span><br><span class="line"><span class="comment">// 9. 等待服务端监听端口关闭，这里会阻塞主线程</span></span><br><span class="line">f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 10. 优雅地关闭两个线程池</span></span><br><span class="line">bossGroup.shutdownGracefully();</span><br><span class="line">workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatNettyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;one conn active: &quot;</span> + ctx.channel());</span><br><span class="line"><span class="comment">// channel是在ServerBootstrapAcceptor中放到EventLoopGroup中的</span></span><br><span class="line">ChatHolder.join((SocketChannel) ctx.channel());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes()];</span><br><span class="line">byteBuf.readBytes(bytes);</span><br><span class="line">String content = <span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class="line">System.out.println(content);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (content.equals(<span class="string">&quot;quit\r\n&quot;</span>)) &#123;</span><br><span class="line">ctx.channel().close();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ChatHolder.propagate((SocketChannel) ctx.channel(), content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;one conn inactive: &quot;</span> + ctx.channel());</span><br><span class="line">ChatHolder.quit((SocketChannel) ctx.channel());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Map&lt;SocketChannel, String&gt; USER_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加入群聊</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> socketChannel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(SocketChannel socketChannel)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 有人加入就给他分配一个id</span></span><br><span class="line">String userId = <span class="string">&quot;用户&quot;</span> + ThreadLocalRandom.current().nextInt(Integer.MAX_VALUE);</span><br><span class="line">send(socketChannel, <span class="string">&quot;您的id为：&quot;</span> + userId + <span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (SocketChannel channel : USER_MAP.keySet()) &#123;</span><br><span class="line">send(channel, userId + <span class="string">&quot; 加入了群聊&quot;</span> + <span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前用户加入到map中</span></span><br><span class="line">USER_MAP.put(socketChannel, userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 退出群聊</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> socketChannel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">(SocketChannel socketChannel)</span> </span>&#123;</span><br><span class="line">String userId = USER_MAP.get(socketChannel);</span><br><span class="line">send(socketChannel, <span class="string">&quot;您退出了群聊&quot;</span> + <span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">USER_MAP.remove(socketChannel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (SocketChannel channel : USER_MAP.keySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (channel != socketChannel) &#123;</span><br><span class="line">send(channel, userId + <span class="string">&quot; 退出了群聊&quot;</span> + <span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩散说话的内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> socketChannel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">propagate</span><span class="params">(SocketChannel socketChannel, String content)</span> </span>&#123;</span><br><span class="line">String userId = USER_MAP.get(socketChannel);</span><br><span class="line"><span class="keyword">for</span> (SocketChannel channel : USER_MAP.keySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (channel != socketChannel) &#123;</span><br><span class="line">send(channel, userId + <span class="string">&quot;: &quot;</span> + content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送消息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> socketChannel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(SocketChannel socketChannel, String msg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ByteBufAllocator allocator = ByteBufAllocator.DEFAULT;</span><br><span class="line">ByteBuf writeBuffer = allocator.buffer(msg.getBytes().length);</span><br><span class="line">writeBuffer.writeCharSequence(msg, Charset.defaultCharset());</span><br><span class="line">socketChannel.writeAndFlush(writeBuffer);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，只需要改动设置子 Handler 里面的那一个地方就可以了，其它地方完全不需要修改，非常便捷。</p><h2 id="模拟群聊"><a href="#模拟群聊" class="headerlink" title="模拟群聊"></a>模拟群聊</h2><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220517145013600.png" alt="image-20220517145013600"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编写Netty应用程序&quot;&gt;&lt;a href=&quot;#编写Netty应用程序&quot; class=&quot;headerlink&quot; title=&quot;编写Netty应用程序&quot;&gt;&lt;/a&gt;编写Netty应用程序&lt;/h1&gt;&lt;p&gt;从 &lt;code&gt;netty-example&lt;/code&gt; 工程下抄了</summary>
      
    
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>03.Java NIO的核心组件</title>
    <link href="https://leslieaibin.github.io/2022/05/17/Netty/03.%20Java%20NIO%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>https://leslieaibin.github.io/2022/05/17/Netty/03.%20Java%20NIO%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</id>
    <published>2022-05-17T01:15:42.000Z</published>
    <updated>2022-05-17T03:23:05.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="03-Java-NIO的核心组件"><a href="#03-Java-NIO的核心组件" class="headerlink" title="03.Java NIO的核心组件"></a>03.Java NIO的核心组件</h1><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><strong>什么是 Channel 呢？</strong> 让我们来看看 JDK 怎么说：</p><blockquote><p>// java.nio.channels.Channel</p><p>A nexus for I/O operations.</p><p>A channel represents an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct I/O operations, for example reading or writing.</p></blockquote><p><strong>Channel 是一种 IO 操作的连接</strong>（nexus，连接的意思），它代表的是到实体的开放连接，这个实体可以是硬件设备、文件、网络套接字或者可执行 IO 操作（比如读、写）的程序组件。</p><p>在 linux 系统中，一切皆可看作是文件，所以，简单点讲，Channel 就是到文件的连接，并可以通过 IO 操作这些文件。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220517110316979.png" alt="image-20220517110316979"><br>因此，针对不同的文件类型又衍生出了<strong>不同类型的 Channel</strong>：</p><ul><li>  FileChannel：操作普通文件</li><li>  DatagramChannel：用于 UDP 协议</li><li>  SocketChannel：用于 TCP 协议，客户端与服务端之间的 Channel</li><li>  ServerSocketChannel：用于 TCP 协议，仅用于服务端的 Channel</li></ul><blockquote><p>ServerSocketChannel 和 SocketChannel 是专门用于 TCP 协议中的。<br>ServerSocketChannel 是一种服务端的 Channel，只能用在服务端，可以看作是到网卡的一种 Channel，它监听着网卡的某个端口。<br>SocketChannel 是一种客户端与服务端之间的 Channel，客户端连接到服务器的网卡之后，被服务端的 Channel 监听到，然后与客户端之间建立一个 Channel，这个 Channel 就是 SocketChannel。</p></blockquote><p>那么，这些 <strong>Channel 又该如何使用呢？</strong> 我们以 FileChannel 为代表来写一个简单的示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 从文件获取一个FileChannel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;D:\\object.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">        <span class="comment">// 声明一个Byte类型的Buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 将FileChannel中的数据读出到buffer中，-1表示读取完毕</span></span><br><span class="line">        <span class="comment">// buffer默认为写模式</span></span><br><span class="line">        <span class="comment">// read()方法是相对channel而言的，相对buffer就是写</span></span><br><span class="line">        <span class="keyword">while</span> ((fileChannel.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// buffer切换为读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// buffer中是否有未读数据</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 未读数据的长度</span></span><br><span class="line">                <span class="keyword">int</span> remain = buffer.remaining();</span><br><span class="line">                <span class="comment">// 声明一个字节数组</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[remain];</span><br><span class="line">                <span class="comment">// 将buffer中数据读出到字节数组中</span></span><br><span class="line">                buffer.get(bytes);</span><br><span class="line">                <span class="comment">// 打印出来</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清空buffer，为下一次写入数据做准备</span></span><br><span class="line">            <span class="comment">// clear()会将buffer再次切换为写模式</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的示例，我们可以发现，Channel 是和 Buffer 一起使用的，那么，什么是 Buffer 呢？为什么要和 Buffer 一起使用呢？必须吗？</p><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p><strong>什么是 Buffer 呢？</strong> 让我们再来看看 JDK 怎么说：</p><blockquote><p>// java.nio.Buffer</p><p>A container for data of a specific primitive type.</p><p>A buffer is a linear, finite sequence of elements of a specific primitive type. Aside from its content, the essential properties of a buffer are its capacity, limit, and position.</p></blockquote><p>Buffer 是一个容器，什么样的容器呢？存放数据的容器。存放什么样的数据呢？特定基本类型的数据。这个容器有哪些特点呢？它是线性的，有限的序列，元素是某种基本类型的数据。它又有哪些属性呢？主要有三个属性：<strong>capacity、limit、position</strong>。</p><p>那么，<strong>Buffer 为什么要和 Channel 一起使用呢？必须一起使用吗？</strong></p><p>打个比方，我们知道，山西盛产煤这种资源，一粒一粒的煤我们可以看作是数据。煤要往外运，那就需要修铁路，比如从山西运到上海，那就要修一条从山西到上海的铁路，这条铁路就相当于是连接山西和上海的通道（Channel）。数据和通道都有了，煤要放在哪里运过去呢？那就需要一种容器，有人可能会想到火车，其实火车可以看作是运输的一种方式或者叫协议，不使用火车，使用滑板车可不可以呢？其实也可以，只是运输的风险比较大而已，所以，火车可以看作是 TCP 协议，而滑板车是 UDP 协议。真正的容器应该是装煤的箱子，也就是 Buffer。</p><p>它们之间的关系如下图所示：</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220517110842715.png" alt="image-20220517110842715"></p><p>所以，Channel 和 Buffer 能不能单独使用呢？其实也可以，只是意义不大，比如，声明了一个 Channel 啥也不干，声明了一个 Buffer 里面存放一些数据啥也不干，意义不大，数据有交互才有意义，所以我们一般把 Channel 和 Buffer 一起使用，从 Channel 读取数据到 Buffer 中，或者从 Buffer 写入数据到 Channel 中。</p><p><strong>NIO 的传输方式和传统的基于 BIO 的传输方式基本是类似的，那么，它们有什么区别呢</strong>？</p><p>首先，BIO 是面向流的，而 NIO 是面向 Channel 或者面向缓冲区的，它的效率更高。</p><p>其次，流是单向的，所以又分成 InputStream 和 OutputStream，而 Channel 是双向的，既可读也可写。</p><p>然后，流只支持同步读写，而 Channel 是可以支持异步读写的。</p><p>最后，流一般与字节数组或者字符数组配合使用，而 Channel 一般与 Buffer 配合使用。</p><p>我们知道了 Buffer 是一个容器，它里面存储的是特定的基本类型，那么，<strong>有哪些类型的 Buffer 呢？</strong></p><p>我们知道基本类型有：byte、char、short、int、long、float、double、boolean，那么是不是每一种基本类型对应一种 Buffer 呢？嗯，基本上是这样，除了 boolean 没有对应的 Buffer 以外，其它的类型都有对应的 Buffer，因为 boolean 本质上就是 0 和 1 两种情况，Java 字节码层面也是用 0 和 1 来表示 boolean 类型的 false 和 true 的。</p><p>所以，Buffer 的类型有：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。</p><p>上面是按照基本类型的角度来划分的，其实针对每一种类型还有不同的内存实现，分为<strong>堆内存实现和直接内存实现</strong>，比如，ByteBuffer 又分为 HeapByteBuffer 和 DirectByteBuffer 两种不同的内存实现。</p><p>OK，Buffer 有这么多种不同的实现，那么，<strong>它们该如何使用呢？</strong></p><p>从前面 Buffer 的定义，我们知道 Buffer 有三个非常重要的属性，分别为：capacity、limit、position。</p><ul><li><p>  capacity，比较好理解，Buffer 的容量，即能够容纳多少数据。</p></li><li><p>  limit，这个稍微费脑一些，表示的是最大可写或者最大可读的数据。</p></li><li><p>  position，这个就更难理解一些，表示下一次可使用的位置，针对读模式表示下一个可读的位置，针对写模式表示下一个可写的位置。</p></li></ul><p>上面的描述可能比较抽象，让我们上一张图来细细品味一下：</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220517111648246.png" alt="image-20220517111648246"><br>上图中，深蓝色表示已经写入的空间，这部分有数据可读；淡蓝色表示未被写入的空间，这部分没有数据可读。</p><p>写模式下，position 指向下一个可写的位置，limit 表示最大可写的数据，capacity 表示容量。比如，Buffer 的大小为 8，已经写了三个单位的数据，则 capacity=8，limit=8，position=3。</p><p>读模式下，position 指向下一个可读的位置，limit 表示最大可读的数据，capacity 表示容量。比如，Buffer 的大小为 8，已经写了三个单位的数据，此时切换为读模式，则 capacity=8，limit=3，position=0。</p><blockquote><p>注意，position 表示的是位置，类似于数组的下标，是从 0 开始的。而 limit 和 capacity 表示的是大小，类似于数组的长度，是从 1 开始的。当 Buffer 从写模式切换为读模式时，limit 变为原 position 的值，position 变为 0。</p></blockquote><p>好了，Buffer 的结构我们了解了，那么，要如何使用 Buffer 呢？</p><p>Buffer 提供了一系列的方法，供我们简单快捷地使用 Buffer，我们从使用的流程上来说的话，大概有下面这么<strong>几个重要的方法：</strong></p><ul><li>  分配一个 Buffer：allocate ()</li><li>  写入数据：buf.put () 或者 channel.read (buf)，read 为 read to 的意思，从 channel 读出并写入 buffer</li><li>  切换为读模式：buf.flip ()</li><li>  读取数据：buf.read () 或者 channel.write (buf)，write 为 write from 的意思，从 buffer 读出并写入 channel</li><li>  重新读取或重新写入：rewind ()，重置 position 为 0，limit 和 capacity 保持不变，可以重新读取或重新写入数据</li><li>  清空数据：buf.clear ()，清空所有数据</li><li>  压缩数据：buf.compact ()，清除已读取的数据，并将未读取的数据往前移</li></ul><p>我们对照着代码来看看如何使用 Buffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 从文件获取一个FileChannel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;D:\\object.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">        <span class="comment">// 分配一个Byte类型的Buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 将FileChannel中的数据读出到buffer中，-1表示读取完毕</span></span><br><span class="line">        <span class="comment">// buffer默认为写模式</span></span><br><span class="line">        <span class="comment">// read()方法是相对channel而言的，相对buffer就是写</span></span><br><span class="line">        <span class="keyword">while</span> ((fileChannel.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// buffer切换为读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// buffer中是否有未读数据</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 读取数据</span></span><br><span class="line">                System.out.print((<span class="keyword">char</span>)buffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清空buffer，为下一次写入数据做准备</span></span><br><span class="line">            <span class="comment">// clear()会将buffer再次切换为写模式</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看 NIO 的另一个核心组件 ——Selector，可以毫不夸张地说，没有 Selector 就无法使用 NIO 来进行网络编程，那么，<strong>Selector 有哪些过人之处呢？</strong></p><h2 id="Selecor"><a href="#Selecor" class="headerlink" title="Selecor"></a>Selecor</h2><p><strong>什么是 Selector？</strong> 让我们再来看看 JDK 怎么说：</p><blockquote><p>// java.nio.channels.Selector</p><p>A multiplexor of {@link SelectableChannel} objects.</p></blockquote><p>首先，Selector 是一个多路复用器。什么的多路复用器？SelectableChannel 对象的多路复用器，注意，这里的对象是复数，说明一个 Selector 可以关联到多个 SelectableChannel。另外，它是 <strong>SelectableChannel</strong> 的多路复用器，可以跟 FileChannel 配合使用吗？不可以，因为 FileChannel 不是 SelectableChannel。那么 SelectableChannel 有哪些呢？跟网络编程相关的那些 Channel 基本上都是 SelectableChannel，比如 SocketChannel、ServerSocketChannel、DatagramChannel 等。</p><p>那么，<strong>Selector 跟 Channel 究竟是怎样的关系呢？</strong></p><p>从上面的描述中，我们也能够大胆猜测，Selector 和 Channel 是一对多的关系，一个 Selector 可以为多个 Channel 服务，监听它们准备好的事件。Selector 就像饭店中的服务员一样，一个服务员是可以服务于多位顾客的，时刻监听着顾客的吩咐。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220517111956805.png" alt="image-20220517111956805"><br>OK，那么，<strong>Selector 又该怎么使用呢？</strong> 我们还是以饭店来举例。</p><p>首先，饭店需要先聘请一个服务员，然后这个服务员来上班。同样地，Selector 也需要先创建出来，创建的方式有两种，一种是调用 <code>Selector.open()</code> 方法，一种是调用 <code>SelectorProvider.openSelector()</code> 方法，其中 SelectorProvider 是自定义的。鉴于第二种方式不太常用，所以我们只讲第一种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Selector</span></span><br><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p>接着，有顾客上门了，服务员去接待，“吃啥啊兄弟？”，“小炒黄牛肉。”，顾客把点的菜告诉服务员。同样地，你需要 Selector 干什么，也需要告诉他，在 Java 里面，我们叫作注册事件到 Selector 上，当然了，我们是非阻塞式的，所以，注册之前还要先设置为非阻塞式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册事件到Selector上</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p>Channel 注册到 Selector 上之后，返回了一个叫作 SelectionKey 的对象，<strong>SelectionKey 又是什么呢？</strong></p><p>一般地，我们在饭店点完菜之后，都会给一个牌子到你手上，服务员通过这个牌子可以找到你，你通过这个牌子可以去拿饭。SelectionKey 就相当于是这个牌子，它将 Channel 和 Selector 的牢牢地绑定在一起，并保存着你感兴趣的事件。</p><p><strong>事件又是什么东西？</strong></p><p>事件是 Channel 感兴趣的事情，比如读事件、写事件等等，在 Java 中，定义了四种事件，位于 SelectionKey 这个类中：</p><ul><li>  读事件：SelectionKey.OP_READ = 1 &lt;&lt; 0 = 0000 0001</li><li>  写事件：SelectionKey.OP_WRITE = 1 &lt;&lt; 2 = 0000 0100</li><li>  连接事件：SelectionKey.OP_CONNECT = 1 &lt;&lt; 3 = 0000 1000</li><li>  接受连接事件：SelectionKey.OP_ACCEPT = 1 &lt;&lt; 4 = 0001 0000</li></ul><p>细心的同学会发现，四种事件的位正好是错开的，所以，我们可以使用 “位或” 操作监听多种感兴趣的事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p>然后，服务员拿到了好几个顾客的菜单后，不断地去后厨询问，看看有没有做好的，有做好的就通知到这些顾客。在 Java 中，这叫作轮询，“轮” 是一次又一次的意思，包含循环的含义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select()只有询问的意思，加上循环才是轮询的意思</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    selector.select(); <span class="comment">// 一直阻塞直到有感兴趣的事件</span></span><br><span class="line">    <span class="comment">// selector.selectNow(); // 立即返回，不阻塞</span></span><br><span class="line">    <span class="comment">// selector.select(timeout); // 阻塞一段时间返回</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>与服务员不断地询问后厨不同的是，服务员没问到结果，可能就去忙其它的事了，比如玩手机，而 select () 没询问到结果会一直阻塞着，直到有感兴趣的事件来了为止。当然，你也可以使用的它的兄弟方法 <code>selectNow()</code> 不阻塞立即返回，或者 <code>select(timeout)</code> 阻塞一段时间后返回。</p><p>最后，服务员拿到这些做好的菜单，通知顾客自己过来聚餐（这个服务员比较懒）。在 Java 中，通过 <code>selector.selectedKeys()</code> 返回就绪的事件，然后遍历这些事件就可以拿到想要的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// 接受连接事件已就绪</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// 连接事件已就绪</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// 读事件已就绪</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// 写事件已就绪</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是从 Channel 中取数据了，也就是 Channel 和 Buffer 的交互了，在上面已经介绍过了，这里我们就不重复介绍了。</p><h2 id="Channel、Buffer、Selector-三者如何联合使用"><a href="#Channel、Buffer、Selector-三者如何联合使用" class="headerlink" title="Channel、Buffer、Selector 三者如何联合使用"></a>Channel、Buffer、Selector 三者如何联合使用</h2><p>Channel、Buffer、Selector 这三个 NIO 的核心组件我们都剖析完了，那么，它们该如何联合起来使用呢？让我们看一个完整的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOEchoServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 创建ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 绑定8080端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8002</span>));</span><br><span class="line">        <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 将Channel注册到selector上，并注册Accept事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;server start&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞在select上（第一阶段阻塞）</span></span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果使用的是select(timeout)或selectNow()需要判断返回值是否大于0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有就绪的Channel</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">// 遍历selectKeys</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                <span class="comment">// 如果是accept事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 强制转换为ServerSocketChannel</span></span><br><span class="line">                    ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                    SocketChannel socketChannel = ssc.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;accept new conn: &quot;</span> + socketChannel.getRemoteAddress());</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 将SocketChannel注册到Selector上，并注册读事件</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 如果是读取事件</span></span><br><span class="line">                    <span class="comment">// 强制转换为SocketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">// 创建Buffer用于读取数据</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">// 将数据读入到buffer中（第二阶段阻塞）</span></span><br><span class="line">                    <span class="keyword">int</span> length = socketChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">                        <span class="comment">// 将数据读入到byte数组中</span></span><br><span class="line">                        buffer.get(bytes);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 换行符会跟着消息一起传过来</span></span><br><span class="line">                        String content = <span class="keyword">new</span> String(bytes, <span class="string">&quot;UTF-8&quot;</span>).replace(<span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;receive msg: &quot;</span> + content);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img1.sycdn.imooc.com/5f0d5cad00014cc413761908.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;03-Java-NIO的核心组件&quot;&gt;&lt;a href=&quot;#03-Java-NIO的核心组件&quot; class=&quot;headerlink&quot; title=&quot;03.Java NIO的核心组件&quot;&gt;&lt;/a&gt;03.Java NIO的核心组件&lt;/h1&gt;&lt;h2 id=&quot;Channel&quot;&gt;</summary>
      
    
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>01.IO多路复用基础</title>
    <link href="https://leslieaibin.github.io/2022/05/14/Netty/01.%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
    <id>https://leslieaibin.github.io/2022/05/14/Netty/01.%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-14T01:15:42.000Z</published>
    <updated>2022-05-14T08:57:50.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-O-五种IO模型"><a href="#I-O-五种IO模型" class="headerlink" title="I/O 五种IO模型"></a>I/O 五种IO模型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了加深对 <strong>I/O多路复用机制</strong> 的理解，以及了解到多路复用也有局限性，在这里我们先回顾下 <strong>Unix网络编程中的五种IO模型</strong>。</p><ul><li><p>  <strong>Blocking IO - 阻塞IO</strong></p></li><li><p>  <strong>NoneBlocking IO - 非阻塞IO</strong></p></li><li><p>  <strong>IO multiplexing - IO多路复用</strong></p></li><li><p>  <strong>signal driven IO - 信号驱动IO</strong></p></li><li><p>  <strong>asynchronous IO - 异步IO</strong></p></li></ul><h2 id="Unix网络编程中的五种IO模型"><a href="#Unix网络编程中的五种IO模型" class="headerlink" title="Unix网络编程中的五种IO模型"></a>Unix网络编程中的五种IO模型</h2><h3 id="阻塞IO-Blocking-IO"><a href="#阻塞IO-Blocking-IO" class="headerlink" title="阻塞IO - Blocking IO"></a>阻塞IO - Blocking IO</h3><p>最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。</p><p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/filters:no_upscale()"></p><blockquote><p>也许有人会说，可以采用多线程+ 阻塞IO 来解决效率问题，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</p></blockquote><h3 id="非阻塞IO-NoneBlocking-IO"><a href="#非阻塞IO-NoneBlocking-IO" class="headerlink" title="非阻塞IO - NoneBlocking IO"></a>非阻塞IO - NoneBlocking IO</h3><p>当用户线程发起一个 IO 操作后，并不需要等待，而是马上就得到一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 IO 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p><p>在非阻塞IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p><blockquote><p>对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514163555308.png" alt="image-20220514163555308"></p><ul><li><p>  非阻塞式主要体现在用户进程发起recvfrom系统调用的时候,这个时候系统内核还没有接收到数据报,直接返回错误给用户进程,告诉“当前还没有数据报可达,晚点再来”</p></li><li><p>  用户进程接收到信息,但是用户进程不知道什么时候数据报可达,于是就开始不断轮询(polling)向系统内核发起recvfrom的系统调用“询问数据来了没”,如果没有则继续返回错误</p></li><li><p>  用户进程轮询发起recvfrom系统调用直至数据报可达,这个时候需要等待系统内核复制数据报到用户进程的缓冲区,复制完成之后将返回成功提示</p></li></ul><h3 id="IO多路复用-IO-multiplexing"><a href="#IO多路复用-IO-multiplexing" class="headerlink" title="IO多路复用 - IO multiplexing"></a>IO多路复用 - IO multiplexing</h3><p>所谓 I/O 多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要 <code>select</code> 、 <code>poll</code> 、 <code>epoll</code> 来配合。</p><p>在多路复用IO模型中，会有一个内核线程不断地去轮询多个 socket 的状态，只有当真正读写事件发送时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有真正有读写事件进行时，才会使用IO资源，所以它大大减少来资源占用。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514163854576.png" alt="image-20220514163854576"></p><ul><li><p>  IO复用模式是使用select或者poll函数向系统内核发起调用，阻塞在这两个系统函数调用，而不是真正阻塞于实际的IO操作(recvfrom调用才是实际阻塞IO操作的系统调用)</p></li><li><p>  阻塞于select函数的调用,等待数据报套接字变为可读状态</p></li><li><p>  当select套接字返回可读状态的时候,就可以发起recvfrom调用把数据报复制到用户空间的缓冲区</p></li></ul><h3 id="信号驱动IO-signal-driven-IO"><a href="#信号驱动IO-signal-driven-IO" class="headerlink" title="信号驱动IO - signal driven IO"></a>信号驱动IO - signal driven IO</h3><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。这个一般用于UDP中，对TCP套接字几乎没用，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么请求。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514164305315.png" alt="image-20220514164305315"></p><p>用户进程可以使用信号方式，当系统内核描述符就绪时将会发送SIGNO给到用户空间，这个时候再发起recvfrom的系统调用等待返回成功提示，流程如下：</p><ul><li><p>  先开启套接字的信号IO启动功能，并通过一个内置安装信号处理函数的signaction系统调用，当发起调用之后会直接返回；</p></li><li><p>  其次，等待内核从网络中接收数据报之后，向用户空间发送当前数据可达的信号给信号处理函数；</p></li><li><p>  信号处理函数接收到信息就发起recvfrom系统调用等待内核数据复制数据报到用户空间的缓冲区；</p></li><li><p>  接收到复制完成的返回成功提示之后，应用进程就可以开始从网络中读取数据。</p></li></ul><h3 id="异步IO-asynchronous-IO"><a href="#异步IO-asynchronous-IO" class="headerlink" title="异步IO - asynchronous IO"></a>异步IO - asynchronous IO</h3><p>前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514164743871.png" alt="image-20220514164743871"></p><ul><li><p>  由POSIX规范定义，告知系统内核启动某个操作，并让内核在整个操作包含数据等待以及数据复制过程的完成之后通知用户进程数据已经准备完成，可以进行读取数据；</p></li><li><p>  与上述的信号IO模型区分在于异步是通知我们何时IO操作完成,而信号IO是通知我们何时可以启动一个IO操作</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现代计算机服务器操作系统大部分都是基于linxu实现,为处理高并发而采取NIO的模型,对于支持异步IO模型的系统持有不确定因素。</p><h4 id="同步与异步的定义"><a href="#同步与异步的定义" class="headerlink" title="同步与异步的定义"></a>同步与异步的定义</h4><ul><li><p>  同步:发起一个fn的调用,需要等待调用结果返回,该调用结果要么是期望的结果要么是异常抛出的结果,可以说是原子性操作(要么成功要么失败返回)</p></li><li><p>  异步: 发起一个fn调用,无需等待结果就直接返回,只有当被调用者执行处理程序之后通过“唤醒”手段通知调用方获取结果(唤醒的方式有回调,事件通知等)</p></li><li><p>  <strong>小结: 同步和异步关注的是程序之间的通信</strong></p></li></ul><h4 id="阻塞与非阻塞的定义"><a href="#阻塞与非阻塞的定义" class="headerlink" title="阻塞与非阻塞的定义"></a>阻塞与非阻塞的定义</h4><ul><li><p>  阻塞: 类比线程阻塞来说明,在并发多线程争抢资源的竞态条件下,如果有一个线程已持有锁,那么当前线程将无法获取锁而被挂起,处于等待状态</p></li><li><p>  非阻塞: 一旦线程释放锁,其他线程将会进入就绪状态,具备争抢锁的资格</p></li><li><p>  <strong>小结: 阻塞与非阻塞更关注是程序等待结果的状态</strong></p></li><li><p>  由此可知,同步异步与阻塞非阻塞之间不存在关联,关注的目标是不一样的</p></li></ul><h4 id="同步IO与异步IO-基于POSIX规范"><a href="#同步IO与异步IO-基于POSIX规范" class="headerlink" title="同步IO与异步IO(基于POSIX规范)"></a>同步IO与异步IO(基于POSIX规范)</h4><ul><li><p>  同步IO: 表示应用进程发起真实的IO操作请求(recvfrom)导致进程一直处于等待状态,这时候进程被阻塞,直到IO操作完成返回成功提示</p></li><li><p>  异步IO: 表示应用进程发起真实的IO操作请求(recvfrom)导致进程将直接返回一个错误信息,<strong>“相当于告诉进程还没有处理好,好了会通知你”</strong></p></li><li><p>  阻塞IO: 主要是体现发起IO操作请求通知内核并且内核接收到信号之后如果让进程等待,那么就是阻塞</p></li><li><p>  非阻塞IO: 发起IO操作请求的时候不论结果直接告诉进程“<strong>不用等待,晚点再来</strong>”,那就是非阻塞</p></li></ul><h4 id="IO模型对比"><a href="#IO模型对比" class="headerlink" title="IO模型对比"></a>IO模型对比</h4><p><strong><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://mmbiz.qpic.cn/mmbiz_png/x0aJCHEALOVINn8dZh1a2Ytw6UHicKK4giaXf9TBYJ7Kes5jnGHAkULmDUria9Dx7gSE7kxMsU0eI072s2lEIbhxQ/640?wx_fmt=png"></strong></p><ul><li><p>  根基上述的同步与异步IO定义并结合上述的模型可知,只有异步IO模型符合POSIX规范的异步IO,其他IO模型都存在recvfrom系统调用被内核阻塞,属于同步IO操作</p></li><li><p>  由此可知,阻塞IO与非阻塞IO可总结如下:</p></li><li><p>  也就是说,要么称为同步与异步IO,要么称为上述5种模型的IO说法,注意上述的同步与异步的概念</p></li><li><p>  大部分操作系统都是基于同步IO的方式实现,对于支持异步IO模型的操作系统还不确定,在实际工作我们经常会说Blocking-IO(阻塞IO)和Non-Blocking-IO(非阻塞IO),极少称同步IO与异步IO</p></li><li><p>  <strong>小结: 同步与异步针对通信机制,阻塞与非阻塞针对程序调用等待结果的状态</strong></p></li></ul><p><strong>一句话总结</strong>：</p><ul><li>  阻塞IO与非阻塞IO</li></ul><blockquote><p>这是最简单的模型，一般配合多线程来实现。</p></blockquote><ul><li>  多路复用(select/poll/epoll)</li></ul><blockquote><p>一个线程解决多连接的问题</p></blockquote><ul><li>  信号驱动IO模型</li></ul><blockquote><p>一种同步IO，更加灵活</p></blockquote><ul><li>  异步IO模型</li></ul><blockquote><p>高效主流的模型，效率很高。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;I-O-五种IO模型&quot;&gt;&lt;a href=&quot;#I-O-五种IO模型&quot; class=&quot;headerlink&quot; title=&quot;I/O 五种IO模型&quot;&gt;&lt;/a&gt;I/O 五种IO模型&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>02.IO多路复用实现机制</title>
    <link href="https://leslieaibin.github.io/2022/05/14/Netty/02.%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>https://leslieaibin.github.io/2022/05/14/Netty/02.%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</id>
    <published>2022-05-14T01:15:42.000Z</published>
    <updated>2022-05-14T10:47:45.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO-多路复用实现机制"><a href="#IO-多路复用实现机制" class="headerlink" title="IO 多路复用实现机制"></a>IO 多路复用实现机制</h1><h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><p>IO 多路复用有三种实现，在介绍select、poll、epoll之前，首先介绍一下Linux操作系统中<strong>基础的概念</strong>：</p><ul><li><p>  用户空间和内核空间</p></li><li><p>  进程切换</p></li><li><p>  进程的阻塞</p></li><li><p>  文件描述符</p></li><li><p>  缓存 I/O</p></li></ul><h3 id="用户空间-内核空间"><a href="#用户空间-内核空间" class="headerlink" title="用户空间 / 内核空间"></a>用户空间 / 内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p><p>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的，并且进程切换是非常耗费资源的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li><p> 保存处理机上下文，包括程序计数器和其他寄存器。</p></li><li><p> 更新PCB信息。</p></li><li><p> 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</p></li><li><p> 选择另一个进程执行，并更新其PCB。</p></li><li><p> 更新内存管理的数据结构。</p></li><li><p> 恢复处理机上下文。</p></li></ol><h3 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得了CPU资源），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><h3 id="缓存I-O"><a href="#缓存I-O" class="headerlink" title="缓存I/O"></a>缓存I/O</h3><p>缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p><strong>缓存 I/O 的缺点：</strong></p><p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h2 id="什么是IO多路复用？"><a href="#什么是IO多路复用？" class="headerlink" title="什么是IO多路复用？"></a>什么是IO多路复用？</h2><ul><li><p>  IO 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；</p></li><li><p>  一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</p></li><li><p>  没有文件句柄就绪就会阻塞应用程序，交出CPU。</p></li></ul><blockquote><p>多路是指网络连接，复用指的是同一个线程</p></blockquote><h2 id="为什么有IO多路复用机制？"><a href="#为什么有IO多路复用机制？" class="headerlink" title="为什么有IO多路复用机制？"></a>为什么有IO多路复用机制？</h2><p>没有IO多路复用机制时，有BIO、NIO两种实现方式，但它们都有一些问题</p><h3 id="同步阻塞（BIO）"><a href="#同步阻塞（BIO）" class="headerlink" title="同步阻塞（BIO）"></a>同步阻塞（BIO）</h3><ul><li><p>服务端采用单线程，当 <code>accept</code> 一个请求后，在 <code>recv</code> 或 <code>send</code> 调用阻塞时，将无法 <code>accept</code> 其他请求（必须等上一个请求处理 <code>recv</code> 或 <code>send</code> 完 ）（无法处理并发）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// accept阻塞</span></span><br><span class="line">    client_fd = accept(listen_fd);</span><br><span class="line">    fds.append(client_fd);</span><br><span class="line">    <span class="keyword">for</span> (fd in fds) &#123;</span><br><span class="line">    <span class="comment">// recv阻塞（会影响上面的accept）</span></span><br><span class="line">        <span class="keyword">if</span> (recv(fd)) &#123;</span><br><span class="line">        <span class="comment">// logic</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>服务端采用多线程，当 accept 一个请求后，开启线程进行 recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销，10000个线程真正发生读写实际的线程数不会超过20%，每次accept都开一个线程也是一种资源浪费。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="comment">// accept阻塞</span></span><br><span class="line">  client_fd = accept(listen_fd)</span><br><span class="line">  <span class="comment">// 开启线程read数据（fd增多导致线程数增多）</span></span><br><span class="line">  <span class="function">newThread <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// recv阻塞（多线程不影响上面的accept）</span></span><br><span class="line">    <span class="keyword">if</span> (recv(fd)) &#123;</span><br><span class="line">      <span class="comment">// logic</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="同步非阻塞（NIO）"><a href="#同步非阻塞（NIO）" class="headerlink" title="同步非阻塞（NIO）"></a>同步非阻塞（NIO）</h3><ul><li><p>服务器端当 <code>accept</code> 一个请求后，加入 <code>fds</code> 集合，每次轮询一遍 <code>fds</code> 集合 <code>recv</code> (非阻塞)数据，没有数据则立即返回错误，每次轮询所有 fd （包括没有发生读写实际的 fd）会很浪费 CPU。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="comment">// accept非阻塞（cpu一直忙轮询）</span></span><br><span class="line">  client_fd = accept(listen_fd)</span><br><span class="line">  <span class="keyword">if</span> (client_fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 有人连接</span></span><br><span class="line">    fds.append(client_fd)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 无人连接</span></span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">for</span> (fd in fds) &#123;</span><br><span class="line">    <span class="comment">// recv非阻塞</span></span><br><span class="line">    setNonblocking(client_fd)</span><br><span class="line">    <span class="comment">// recv 为非阻塞命令</span></span><br><span class="line">    <span class="keyword">if</span> (len = recv(fd) &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 有读写数据</span></span><br><span class="line">      <span class="comment">// logic</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       无读写数据</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>服务器端采用单线程通过 <code>select/poll/epoll</code> 等系统调用获取 fd 列表，遍历有事件的 fd 进行 <code>accept/recv/send</code> ，使其能支持更多的并发连接请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 通过内核获取有读写事件发生的fd，只要有一个则返回，无则阻塞</span></span><br><span class="line">  <span class="comment">// 整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，accept/recv是不会阻塞</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="function">fd in <span class="title">select</span><span class="params">(fds)</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd == listen_fd) &#123;</span><br><span class="line">        client_fd = accept(listen_fd)</span><br><span class="line">        fds.append(client_fd)</span><br><span class="line">    &#125; elseif (len = recv(fd) &amp;&amp; len != -<span class="number">1</span>) &#123; </span><br><span class="line">      <span class="comment">// logic</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO多路复用的三种实现"><a href="#IO多路复用的三种实现" class="headerlink" title="IO多路复用的三种实现"></a>IO多路复用的三种实现</h2><ul><li><p>  select</p></li><li><p>  poll</p></li><li><p>  epoll</p></li></ul><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p><h4 id="select调用过程"><a href="#select调用过程" class="headerlink" title="select调用过程"></a>select调用过程</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514172305481.png" alt="image-20220514172305481"></p><p>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间</p><p>（2）注册回调函数__pollwait</p><p>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</p><p>（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</p><p>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</p><p>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</p><p>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</p><p>（8）把fd_set从内核空间拷贝到用户空间。</p><h4 id="select函数接口"><a href="#select函数接口" class="headerlink" title="select函数接口"></a>select函数接口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFDBITS (8 * sizeof(unsigned long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FDSET_LONGS (FD_SETSIZE/NFDBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构 (bitmap)</span></span><br><span class="line">typedefstruct &#123;</span><br><span class="line">    unsignedlong fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> max_fd, </span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *readset, </span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *writeset, </span></span></span><br><span class="line"><span class="function"><span class="params">    fd_set *exceptset, </span></span></span><br><span class="line"><span class="function"><span class="params">    struct timeval *timeout</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>                              <span class="comment">// 返回值就绪描述符的数目</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">FD_ZERO</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>   <span class="comment">// 清空集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>    <span class="comment">// 将给定的描述符加入集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>  <span class="comment">// 判断指定描述符是否在集合中 </span></span></span><br><span class="line"><span class="function"><span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>    <span class="comment">// 将给定的描述符从文件中删除</span></span></span><br></pre></td></tr></table></figure><h4 id="select使用示例"><a href="#select使用示例" class="headerlink" title="select使用示例"></a>select使用示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 这里进行一些初始化的设置，</span></span><br><span class="line"><span class="comment">   * 包括socket建立，地址的设置等,</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  fd_set read_fs, write_fs;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">0</span>;  <span class="comment">// 用于记录最大的fd，在轮询中时刻更新即可</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化比特位</span></span><br><span class="line">  FD_ZERO(&amp;read_fs);</span><br><span class="line">  FD_ZERO(&amp;write_fs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nfds = <span class="number">0</span>; <span class="comment">// 记录就绪的事件，可以减少遍历的次数</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="comment">// 每次需要把fd从用户态拷贝到内核态</span></span><br><span class="line">    nfds = select(max + <span class="number">1</span>, &amp;read_fd, &amp;write_fd, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">    <span class="comment">// 每次需要遍历所有fd，判断有无读写事件发生</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max &amp;&amp; nfds; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == listenfd) &#123;</span><br><span class="line">         --nfds;</span><br><span class="line">         <span class="comment">// 这里处理accept事件</span></span><br><span class="line">         FD_SET(i, &amp;read_fd);<span class="comment">//将客户端socket加入到集合中</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (FD_ISSET(i, &amp;read_fd)) &#123;</span><br><span class="line">        --nfds;</span><br><span class="line">        <span class="comment">// 这里处理read事件</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (FD_ISSET(i, &amp;write_fd)) &#123;</span><br><span class="line">         --nfds;</span><br><span class="line">        <span class="comment">// 这里处理write事件</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点"></a>select缺点</h4><ul><li> 每次调用select，都需要把被监控的fds集合从用户态空间拷贝到内核态空间，高并发场景下这样的拷贝会使得消耗的资源是很大的。</li><li> 能监听端口的数量有限，单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上为3264），当然我们可以对宏FD_SETSIZE进行修改，然后重新编译内核，但是性能可能会受到影响，一般该数和系统内存关系很大，具体数目可以<code>cat /proc/sys/fs/file-max</code>察看。32位机默认1024个，64位默认2048。 </li></ul><blockquote><p>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p></blockquote><ul><li>  对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发）</li></ul><blockquote><p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p></blockquote><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</p><h4 id="poll函数接口"><a href="#poll函数接口" class="headerlink" title="poll函数接口"></a>poll函数接口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;                         <span class="comment">// 需要监视的文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;                   <span class="comment">// 需要内核监视的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents;                  <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd fds[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="poll使用示例"><a href="#poll使用示例" class="headerlink" title="poll使用示例"></a>poll使用示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先宏定义长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_POLLFD_LEN 4096  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 在这里进行一些初始化的操作，</span></span><br><span class="line"><span class="comment">   * 比如初始化数据和socket等。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nfds = <span class="number">0</span>;</span><br><span class="line">  pollfd fds[MAX_POLLFD_LEN];</span><br><span class="line">  <span class="built_in">memset</span>(fds, <span class="number">0</span>, <span class="keyword">sizeof</span>(fds));</span><br><span class="line">  fds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">  fds[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line">  <span class="keyword">int</span> max  = <span class="number">0</span>;  <span class="comment">// 队列的实际长度，是一个随时更新的，也可以自定义其他的</span></span><br><span class="line">  <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> current_size = max;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="comment">// 每次需要把fd从用户态拷贝到内核态</span></span><br><span class="line">    nfds = poll(fds, max+<span class="number">1</span>, timeout);</span><br><span class="line">    <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123;</span><br><span class="line">        <span class="comment">// 这里处理accept事件</span></span><br><span class="line">        connfd = accept(listenfd);</span><br><span class="line">        <span class="comment">//将新的描述符添加到读描述符集合中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次需要遍历所有fd，判断有无读写事件发生</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; max; ++i) &#123;     </span><br><span class="line">      <span class="keyword">if</span> (fds[i].revents &amp; POLLRDNORM) &#123; </span><br><span class="line">         sockfd = fds[i].fd</span><br><span class="line">         <span class="keyword">if</span> ((n = read(sockfd, buf, MAXLINE)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里处理read事件</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                close(sockfd);</span><br><span class="line">                fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 这里处理write事件     </span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (--nfds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;       </span><br><span class="line">         &#125;   </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="poll缺点"><a href="#poll缺点" class="headerlink" title="poll缺点"></a>poll缺点</h4><p><strong>它没有最大连接数的限制</strong>，原因是它是基于链表来存储的，但是同样有缺点：</p><ul><li><p>  每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；</p></li><li><p>  对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时）</p></li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p><h4 id="epoll函数接口"><a href="#epoll函数接口" class="headerlink" title="epoll函数接口"></a>epoll函数接口</h4><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="comment">// 每一个epoll对象都有一个独立的eventpoll结构体</span></span><br><span class="line"><span class="comment">// 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件</span></span><br><span class="line"><span class="comment">// epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; <span class="comment">// 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>; <span class="comment">// epoll_ctl 负责把 socket 增加、删除到内核红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;<span class="comment">// epoll_wait 负责检测可读队列，没有可读 socket 则阻塞进程</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为红黑树元素个数)。</p><p>而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p><p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p><pre><code>struct epitem&#123;    struct rb_node  rbn;//红黑树节点    struct list_head    rdllink;//双向链表节点    struct epoll_filefd  ffd;//事件句柄信息    struct eventpoll *ep;//指向其所属的eventpoll对象    struct epoll_event event;//期待发生的事件类型&#125;</code></pre><p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514174104753.png" alt="image-20220514174104753"><strong>从上面的讲解可知：通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。</strong>讲解完了Epoll的机理，我们便能很容易掌握epoll的用法了。一句话描述就是：三步曲。</p><ul><li><p>  第一步：epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。</p></li><li><p>  第二步：epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。</p></li><li><p>  第三部：epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。</p></li></ul><h4 id="epoll使用示例"><a href="#epoll使用示例" class="headerlink" title="epoll使用示例"></a>epoll使用示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 在这里进行一些初始化的操作，</span></span><br><span class="line"><span class="comment">   * 比如初始化数据和socket等。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核中创建ep对象</span></span><br><span class="line">    epfd=epoll_create(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">// 需要监听的socket放到ep中</span></span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&amp;ev);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 阻塞获取</span></span><br><span class="line">      nfds = epoll_wait(epfd,events,<span class="number">20</span>,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i) &#123;</span><br><span class="line">          <span class="keyword">if</span>(events[i].data.fd==listenfd) &#123;</span><br><span class="line">              <span class="comment">// 这里处理accept事件</span></span><br><span class="line">              connfd = accept(listenfd);</span><br><span class="line">              <span class="comment">// 接收新连接写到内核对象中</span></span><br><span class="line">              epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev);</span><br><span class="line">          &#125; elseif (events[i].events&amp;EPOLLIN) &#123;</span><br><span class="line">              <span class="comment">// 这里处理read事件</span></span><br><span class="line">              read(sockfd, BUF, MAXLINE);</span><br><span class="line">              <span class="comment">//读完后准备写</span></span><br><span class="line">              epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">          &#125; elseif(events[i].events&amp;EPOLLOUT) &#123;</span><br><span class="line">              <span class="comment">// 这里处理write事件</span></span><br><span class="line">              write(sockfd, BUF, n);</span><br><span class="line">              <span class="comment">//写完后准备读</span></span><br><span class="line">              epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="epoll的优点"><a href="#epoll的优点" class="headerlink" title="epoll的优点"></a>epoll的优点</h4><ul><li><p>  没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；</p></li><li><p>  效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll；</p></li><li><p>  内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p></li></ul><h4 id="epoll缺点"><a href="#epoll缺点" class="headerlink" title="epoll缺点"></a>epoll缺点</h4><ul><li>  epoll只能工作在 linux 下</li></ul><h4 id="epoll-LT-与-ET-模式的区别"><a href="#epoll-LT-与-ET-模式的区别" class="headerlink" title="epoll LT 与 ET 模式的区别"></a>epoll LT 与 ET 模式的区别</h4><p>epoll 有 EPOLLLT 和 EPOLLET 两种触发模式，LT 是默认的模式，ET 是 “高速” 模式。</p><ul><li><p>  LT 模式下，只要这个 fd 还有数据可读，每次 epoll_wait 都会返回它的事件，提醒用户程序去操作；</p></li><li><p>  ET 模式下，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论 fd 中是否还有数据可读。所以在 ET 模式下，read 一个 fd 的时候一定要把它的 buffer 读完，或者遇到 EAGIN 错误。</p></li></ul><p>epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><h3 id="select-poll-epoll之间的区别"><a href="#select-poll-epoll之间的区别" class="headerlink" title="select/poll/epoll之间的区别"></a>select/poll/epoll之间的区别</h3><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220514174341258.png" alt="image-20220514174341258"></p><p>epoll是Linux目前大规模网络并发程序开发的首选模型。在绝大多数情况下性能远超select和poll。目前流行的高性能web服务器Nginx正式依赖于epoll提供的高效网络套接字轮询服务。但是，在并发连接不高的情况下，多线程+阻塞I/O方式可能性能更好。</p><h4 id="支持一个进程所能打开的最大连接数"><a href="#支持一个进程所能打开的最大连接数" class="headerlink" title="支持一个进程所能打开的最大连接数"></a>支持一个进程所能打开的最大连接数</h4><ul><li><p>  select：单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32_32，同理64位机器上FD_SETSIZE为32_64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p></li><li><p>  poll：poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p></li><li><p>  epoll：虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接。</p></li></ul><h4 id="FD剧增后带来的IO效率问题"><a href="#FD剧增后带来的IO效率问题" class="headerlink" title="FD剧增后带来的IO效率问题"></a>FD剧增后带来的IO效率问题</h4><ul><li><p>  select：因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</p></li><li><p>  poll：同上</p></li><li><p>  epoll：因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</p></li></ul><h4 id="消息传递方式"><a href="#消息传递方式" class="headerlink" title="消息传递方式"></a>消息传递方式</h4><ul><li><p>  select：内核需要将消息传递到用户空间，都需要内核拷贝动作</p></li><li><p>  poll：同上</p></li><li><p>  epoll：epoll通过内核和用户空间共享一块内存来实现的。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><h2 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h2><h3 id="nginx-redis-所使用的IO模型是什么？"><a href="#nginx-redis-所使用的IO模型是什么？" class="headerlink" title="nginx/redis 所使用的IO模型是什么？"></a>nginx/redis 所使用的IO模型是什么？</h3><h4 id="Nginx的IO模型"><a href="#Nginx的IO模型" class="headerlink" title="Nginx的IO模型"></a>Nginx的IO模型</h4><p>Nginx 支持多种并发模型，并发模型的具体实现根据系统平台而有所不同。</p><p>在支持多种并发模型的平台上，nginx 自动选择最高效的模型。但我们也可以使用 use 指令在配置文件中显式地定义某个并发模型。</p><p><strong>NGINX中支持的并发模型：</strong></p><h5 id="1、select"><a href="#1、select" class="headerlink" title="1、select"></a>1、select</h5><p>IO多路复用、标准并发模型。在编译 nginx 时，如果所使用的系统平台没有更高效的并发模型，select 模块将被自动编译。configure 脚本的选项：–with-select_module 和 –without-select_module 可被用来强制性地开启或禁止 select 模块的编译</p><h5 id="2、poll"><a href="#2、poll" class="headerlink" title="2、poll"></a>2、poll</h5><p>IO多路复用、标准并发模型。与 select 类似，在编译 nginx 时，如果所使用的系统平台没有更高效的并发模型，poll 模块将被自动编译。configure 脚本的选项：–with-poll_module 和 –without-poll_module 可用于强制性地开启或禁止 poll 模块的编译</p><h5 id="3、epoll"><a href="#3、epoll" class="headerlink" title="3、epoll"></a>3、epoll</h5><p>IO多路复用、高效并发模型，可在 Linux 2.6+ 及以上内核可以使用</p><h5 id="4、kqueue"><a href="#4、kqueue" class="headerlink" title="4、kqueue"></a>4、kqueue</h5><p>IO多路复用、高效并发模型，可在 FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0, and Mac OS X 平台中使用</p><h5 id="5、-dev-poll"><a href="#5、-dev-poll" class="headerlink" title="5、/dev/poll"></a>5、/dev/poll</h5><p>高效并发模型，可在 Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+, and Tru64 UNIX 5.1A+ 平台使用</p><h5 id="6、eventport"><a href="#6、eventport" class="headerlink" title="6、eventport"></a>6、eventport</h5><p>高效并发模型，可用于 Solaris 10 平台，PS：由于一些已知的问题，建议 使用/dev/poll替代。</p><h4 id="Redis-IO多路复用技术"><a href="#Redis-IO多路复用技术" class="headerlink" title="Redis IO多路复用技术"></a>Redis IO多路复用技术</h4><p>redis 是一个单线程却性能非常好的内存数据库， 主要用来作为缓存系统。redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。</p><p><strong>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</strong></p><p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 <strong>I/O 多路复用</strong> 就是为了解决这个问题而出现的。</p><p>redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。</p><h3 id="epoll-水平触发（LT）与-边缘触发（ET）的区别？"><a href="#epoll-水平触发（LT）与-边缘触发（ET）的区别？" class="headerlink" title="epoll 水平触发（LT）与 边缘触发（ET）的区别？"></a>epoll 水平触发（LT）与 边缘触发（ET）的区别？</h3><p>EPOLL事件有两种模型：</p><ul><li><p>  Edge Triggered (ET) 边缘触发只有数据到来,才触发,不管缓存区中是否还有数据。</p></li><li><p>  Level Triggered (LT) 水平触发只要有数据都会触发。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IO-多路复用实现机制&quot;&gt;&lt;a href=&quot;#IO-多路复用实现机制&quot; class=&quot;headerlink&quot; title=&quot;IO 多路复用实现机制&quot;&gt;&lt;/a&gt;IO 多路复用实现机制&lt;/h1&gt;&lt;h2 id=&quot;概念说明&quot;&gt;&lt;a href=&quot;#概念说明&quot; class=&quot;</summary>
      
    
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://leslieaibin.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>02.RocketMQ部署</title>
    <link href="https://leslieaibin.github.io/2022/03/17/RocketMq/02.RocketMq%E9%83%A8%E7%BD%B2/"/>
    <id>https://leslieaibin.github.io/2022/03/17/RocketMq/02.RocketMq%E9%83%A8%E7%BD%B2/</id>
    <published>2022-03-17T11:15:42.000Z</published>
    <updated>2022-05-14T08:56:43.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h1><p>部署条件：</p><ul><li><strong>JDK 1.8.0_322</strong></li><li><strong>Maven Apache Maven 3.5.4</strong></li></ul><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>打开 <a href="http://rocketmq.apache.org/release_notes/">RocketMQ release_notes</a> 页面，我们可以看到 RocketMQ 所有的发布版本。这里，我们选择最新的 <a href="http://rocketmq.apache.org/release_notes/release-notes-4.6.0/">RocketMQ 4.6.0</a> 版本。点击进入该版本的发布页面后，我们可以看到两种发布版本：</p><ul><li>Source: <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.6.0/rocketmq-all-4.6.0-source-release.zip">rocketmq-all-4.6.0-source-release.zip</a></li><li>Binary: <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.6.0/rocketmq-all-4.6.0-bin-release.zip">rocketmq-all-4.6.0-bin-release.zip</a></li></ul><p>一般情况下，我们可以直接使用 Binary 版本，它是 RocketMQ 已经编译好，可以直接使用的 RocketMQ 软件包。</p><p>这里，我们想带着胖友们编译一次 RocketMQ 源码，所以使用 Source 版本。下面，我们开始下载 RocketMQ 4.6.0 Source 源码。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget wget http://mirror.bit.edu.cn/apache/rocketmq/4.9.3/rocketmq-all-4.9.3-source-release.zip</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> unzip rocketmq-all-4.9.3-source-release.zip</span></span><br></pre></td></tr></table></figure><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><p>使用 Maven 编译 RocketMQ 源码。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 RocketMQ 源码目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> rocketmq-all-4.9.3-source-release</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Maven 编译 RocketMQ ，并跳过测试。耐心等待...</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mvn -Prelease-all -DskipTests clean install -U</span></span><br></pre></td></tr></table></figure><p>编译完成，在我们进入 distribution 目录下，就可以看到 RocketMQ 的发布包了。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 distribution 目录下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> distribution/target/rocketmq-4.9.3/rocketmq-4.9.3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">40 -rwxr-xr-x   1 yunai  staff  17336 Nov 19 20:59 LICENSE</span><br><span class="line"> 8 -rwxr-xr-x   1 yunai  staff   1338 Nov 19 20:59 NOTICE</span><br><span class="line">16 -rwxr-xr-x   1 yunai  staff   4225 Nov 19 20:59 README.md</span><br><span class="line"> 0 drwxr-xr-x   6 yunai  staff    192 Dec  3 12:48 benchmark # 性能基准测试</span><br><span class="line"> 0 drwxr-xr-x  30 yunai  staff    960 Nov 19 20:59 bin # 执行脚本</span><br><span class="line"> 0 drwxr-xr-x  12 yunai  staff    384 Nov 19 20:59 conf # 配置文件</span><br><span class="line"> 0 drwxr-xr-x  36 yunai  staff   1152 Dec  3 12:48 lib # RocketMQ jar 包</span><br></pre></td></tr></table></figure><h2 id="启动Namesrv"><a href="#启动Namesrv" class="headerlink" title="启动Namesrv"></a>启动Namesrv</h2><p>启动一个 RocketMQ Namesrv 服务。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure><p>启动完成后，查看日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 Namesrv 日志。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tail -f ~/logs/rocketmqlogs/namesrv.log</span></span><br><span class="line"></span><br><span class="line">2019-12-03 12:58:04 INFO main - The Name Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure><ul><li>默认情况下，Namesrv 日志文件所在地址为 <code>~/logs/rocketmqlogs/namesrv.log</code> 。如果想要自定义，可以通过 <code>conf/logback_namesrv.xml</code> 配置文件来进行修改。</li></ul><p>本人是Mac m1 芯片可能会出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动RocketMQ报错：Please set the JAVA_HOME variable in your environment, We need java <span class="number">64</span></span><br></pre></td></tr></table></figure><p>解决方法：</p><p><a href="https://blog.csdn.net/suiyu_eran/article/details/104432164">https://blog.csdn.net/suiyu_eran/article/details/104432164</a></p><h2 id="启动-Broker"><a href="#启动-Broker" class="headerlink" title="启动 Broker"></a>启动 Broker</h2><p>在 <code>conf</code> 目录下，RocketMQ 提供了多种 Broker 的配置文件：</p><ul><li><code>broker.conf</code> ：单主，异步刷盘。</li><li><code>2m/</code> ：双主，异步刷盘。</li><li><code>2m-2s-async/</code> ：两主两从，异步复制，异步刷盘。</li><li><code>2m-2s-sync/</code> ：两主两从，同步复制，异步刷盘。</li><li><code>dledger/</code> ：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/dledger/deploy_guide.md">Dledger 集群</a>，至少三节点。</li></ul><p>这里，我们只启动一个 RocketMQ Broker 服务，所以使用 <code>broker.conf</code> 配置文件。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -c conf/broker.conf  -n 127.0.0.1:9876 &amp;</span><br></pre></td></tr></table></figure><ul><li><p>通过 <code>-c</code> 参数，配置读取的主 Broker 配置。</p></li><li><p>通过 <code>-n</code> 参数，设置 RocketMQ Namesrv 地址。</p></li><li><p>如果胖友的服务器的存相对小，可以修改下 <code>bin/runbroker.sh</code> 脚本，将 Broker JVM 内存调小。如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g&quot;</span><br></pre></td></tr></table></figure></li></ul><p>启动完成后，查看日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br><span class="line"></span><br><span class="line">2019-12-03 14:27:07 INFO main - The broker[broker-a, 192.168.3.44:10911] boot success. serializeType=JSON and name server is 127.0.0.1:9876</span><br></pre></td></tr></table></figure><ul><li>默认情况下，Broker 日志文件所在地址为 <code>~/logs/rocketmqlogs/broker.log</code> 。如果想要自定义，可以通过 <code>conf/logback_broker.xml</code> 配置文件来进行修改。</li></ul><h2 id="测试发送消息"><a href="#测试发送消息" class="headerlink" title="测试发送消息"></a>测试发送消息</h2><p>通过使用 <code>bin/tools.sh</code> 工具类，实现测试发送消息。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//查看broker配置</span><br><span class="line">sh ./bin/mqbroker -m</span><br><span class="line"></span><br><span class="line">//关闭broker</span><br><span class="line">sh bin/mqshutdown broker</span><br><span class="line"></span><br><span class="line">//将本机远程ip写入配置文件中</span><br><span class="line">echo &#x27;brokerIP1=111.231.XX.XX&#x27; &gt; conf/broker.properties </span><br><span class="line"></span><br><span class="line">//重新启动broker  最好用这个命令</span><br><span class="line">nohup sh bin/mqbroker -n 111.231.XX.XX:9876 -c conf/broker.conf autoCreateTopicEnable=true &amp;</span><br></pre></td></tr></table></figure><p>如果发送成功，我们会看到大量成功的发送日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SendResult [sendStatus=SEND_OK, msgId=FE800000000000004F2B5386138462F500000D7163610D67E7F100F4, offsetMsgId=C0A8032C00002A9F000000000000D7EE, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=0], queueOffset=61]</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=FE800000000000004F2B5386138462F500000D7163610D67E7F200F5, offsetMsgId=C0A8032C00002A9F000000000000D8D1, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=1], queueOffset=61]</span><br></pre></td></tr></table></figure><ul><li>通过发送结果为 <code>sendStatus=SEND_OK</code> 状态，说明消息都发送成功了。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 发送的启动地址</span></span><br><span class="line">/Users/leslie/rocketmq-all-4.9.3/distribution/target/rocketmq-4.9.3/rocketmq-4.9.3</span><br></pre></td></tr></table></figure><h2 id="测试消费消息"><a href="#测试消费消息" class="headerlink" title="测试消费消息"></a>测试消费消息</h2><p>通过使用 <code>bin/tools.sh</code> 工具类，实现测试消费消息。命令行操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置 Namesrv 服务器的地址</span></span><br><span class="line">export NAMESRV_ADDR=127.0.0.1:9876</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行消费者 Consumer 消费测试消息</span></span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure><p>如果消费成功，我们会看到大量成功的消费日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConsumeMessageThread_4 Receive New Messages: [MessageExt [queueId=2, storeSize=227, queueOffset=131, sysFlag=0, bornTimestamp=1575354513732, bornHost=/192.168.3.44:55510, storeTimestamp=1575354513733, storeHost=/192.168.3.44:10911, msgId=C0A8032C00002A9F000000000001D1FC, commitLogOffset=119292, bodyCRC=1549304357, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=&#x27;TopicTest&#x27;, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=145, CONSUME_START_TIME=1575354867104, UNIQ_KEY=FE800000000000004F2B5386138462F500000D7163610D67E944020E, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 53, 50, 54], transactionId=&#x27;null&#x27;&#125;]]</span><br><span class="line">ConsumeMessageThread_3 Receive New Messages: [MessageExt [queueId=2, storeSize=227, queueOffset=130, sysFlag=0, bornTimestamp=1575354513729, bornHost=/192.168.3.44:55510, storeTimestamp=1575354513729, storeHost=/192.168.3.44:10911, msgId=C0A8032C00002A9F000000000001CE70, commitLogOffset=118384, bodyCRC=1530218044, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=&#x27;TopicTest&#x27;, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=145, CONSUME_START_TIME=1575354867103, UNIQ_KEY=FE800000000000004F2B5386138462F500000D7163610D67E941020A, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 53, 50, 50], transactionId=&#x27;null&#x27;&#125;]]</span><br></pre></td></tr></table></figure><ul><li>通过 <code>ConsumeMessageThread_4</code> 和 <code>ConsumeMessageThread_3</code> 线程名，我们可以看出，目前是进行并发消费消息。</li></ul><h1 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h1><h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建 DefaultMQProduer 对象</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;Please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 设置RocketMQ Namesrv的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 启动producer 生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 4. 创建 Message消息</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                        <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                        (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 5. 同步message发送消息</span></span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">                <span class="comment">// 6. 打印发送的结果</span></span><br><span class="line">                System.out.println(sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7. 关闭 producer 生产者</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化一个 Producer 生产者。</p><ul><li>1处，创建 DefaultMQProducer 对象，这里设置的生产者分组是 <code>&quot;please_rename_unique_group_name&quot;</code> 。</li><li>2处，设置 设置 <code>producer</code> 的 RocketMQ Namesrv 地址。这里，是艿艿额外添加的代码。</li><li>3处，启动 <code>producer</code> 生产者。</li></ul><p>使用 Producer 发送 1000 条消息。</p><ul><li><p>4处，创建 Message 消息。这里设置了其 Topic 为 <code>&quot;TopicTest&quot;</code>，Tag 为 <code>TagA</code>、消息体 Body 为 <code>&quot;Hello RocketMQ&quot;</code> 的二进制数组。</p></li><li><p>5 处，调用生产者的 <code>#send(Message msg)</code> 方法，<strong>同步</strong>发送消息，等待发送结果。RocketMQ Producer 一共有三种发送消息的方式，除了我们这里看到的同步发送消息之外，还有<strong>异步</strong>发送消息(可见 <a href="https://github.com/apache/rocketmq/blob/master/example/src/main/java/org/apache/rocketmq/example/simple/AsyncProducer.java">AsyncProducer</a> 示例)，和 <strong>Oneway</strong> 发送消息。</p></li><li><p>6处，打印发送结果。</p></li><li><p>7处，关闭 <code>producer</code> 生产者。</p></li></ul><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建DefaultMQPushConsumer 对象</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;Please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 设置RocketMQ Namesrv 地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 设置消费进度， 从Topic最初位置开始</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// 4. 订阅TopicTest主题</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 添加消息监听器</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="comment">// 返回成功</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//6. 启动producer 消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 打印 Consumer 启动完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>1 处，创建 DefaultMQPushConsumer 对象，这里设置的消费者分组是 <code>&quot;please_rename_unique_group_name&quot;</code> 。注意，消费者分组的概念：</p><blockquote><p>FROM <a href="https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md">概念(Concept)</a></p><p>同一类 Consumer 的集合，这类 Consumer 通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。</p><p>要注意的是，消费者组的消费者实例必须订阅完全相同的 Topic 。</p><p>RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p><ul><li>在集群消费下，同一条消息<strong>只</strong>会被<strong>相同</strong>消费者分组的<strong>一个</strong>消费者所消费。</li><li>在广播消费下，同一条消息会被<strong>相同</strong>消费者分组的<strong>所有</strong>消费者所消费。</li><li>在当前示例里，我们采用的是 DefaultMQPushConsumer 的默认消费方式，集群消费。</li></ul></blockquote></li><li><p>2处，设置 <code>consumer</code> 的 RocketMQ Namesrv 地址。这里，是艿艿额外添加的代码。</p></li><li><p>3处，设置一个新的消费集群，初始的消费进度。目前有三个选项：</p><ul><li><code>CONSUME_FROM_FIRST_OFFSET</code> ：每个 Topic 队列的第一条消息。</li><li><code>CONSUME_FROM_LAST_OFFSET</code> ：每个 Topic 队列的最后一条消息。</li><li><code>CONSUME_FROM_TIMESTAMP</code> ：每个 Topic 队列的指定时间开始的消息。</li><li>注意，只针对<strong>新的</strong>消费集群。如果一个集群每个 Topic 已经有消费进度，则继续使用该消费进度。仔细理解一下哈~</li></ul></li><li><p>4处，设置订阅 <code>&quot;TopicTest&quot;</code> 主题的消息。有一定一定要注意！！！<strong>消费者组的消费者实例必须订阅完全相同的 Topic + Tag</strong> 。</p></li><li><p>5处，添加消息监听器。这里我们采用的是 <a href="https://github.com/apache/rocketmq/blob/master/client/src/main/java/org/apache/rocketmq/client/consumer/listener/MessageListenerConcurrently.java">MessageListenerConcurrently</a> <strong>并发</strong>消费消息的监听器。如果胖友需要实现<strong>顺序</strong>消费消息，需要使用 <a href="https://github.com/apache/rocketmq/blob/master/client/src/main/java/org/apache/rocketmq/client/consumer/listener/MessageListenerOrderly.java">MessageListenerOrderly</a> <strong>顺序</strong>消费的监听器。</p></li><li><p>6处，启动 <code>consumer</code> 消费者。此时，Consumer 就开始正式的消费消息啦。。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单机部署&quot;&gt;&lt;a href=&quot;#单机部署&quot; class=&quot;headerlink&quot; title=&quot;单机部署&quot;&gt;&lt;/a&gt;单机部署&lt;/h1&gt;&lt;p&gt;部署条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JDK 1.8.0_322&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;st</summary>
      
    
    
    
    <category term="RocketMQ" scheme="https://leslieaibin.github.io/categories/RocketMQ/"/>
    
    
    <category term="RocketMQ" scheme="https://leslieaibin.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>01.RocketMQ概述</title>
    <link href="https://leslieaibin.github.io/2022/03/17/RocketMq/01.RocketMq%E5%85%A5%E9%97%A8/"/>
    <id>https://leslieaibin.github.io/2022/03/17/RocketMq/01.RocketMq%E5%85%A5%E9%97%A8/</id>
    <published>2022-03-17T01:15:42.000Z</published>
    <updated>2022-05-14T08:56:38.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>阿里巴巴消息中间件起源于 2001 年的五彩石项目， Notify 在这期间应运而生，用于交易核心消息的流转 。</p><ul><li><p>2010 年， B2B 开始大规模使用 ActiveMQ 作为消息内核，随着阿里业务的快速发展，急需一款支持顺序消息，拥有海量消息堆积能力的消息中间件， MetaQ 1.0 在 2011年诞生 。</p></li><li><p>2012年， MetaQ已经发展到了3.0版本，并抽象出了通用的消息引擎 RocketMQ。 随后，对 RocketMQ 进行了开源 ，阿里的消息中间件正式走人了 公众视野 。</p></li><li><p>2015年， RocketMQ已经经历了多年双十一的洗礼，在可用性、 可靠性以 及稳定性等方面都有出色的表现。与此同时 ，云计算大行其道， 阿里消息中间 件基于 RocketMQ推出了 Aliware MQ 1.0，开始为阿里云上成千上万家企业提 供消息服务 。</p></li><li><p>2016 年， MetaQ 在双十一期间承载了万亿级消息的流转，跨越了一个新的里程碑 ，同时 RocketMQ 进入Apache 孵化 。</p></li><li><p>2016年11月，阿里巴巴正式将RocketMQ捐献给Apache基金会，</p></li><li><p>2017年9月从Apache社区正式毕业，成为Apache的顶级开源项目。毕业之后RocketMQ受到了更为广泛的关注，除中国之外、日本、新加坡、泰国、俄罗斯、德国、美国、加拿大等国家也在关注RocketMQ。</p></li><li><p>2017年10月，我们提出OpenMessaging，OpenMessaging是一个消息标准，最初阿里有许多消息中间件，中间存在几个问题：</p><ul><li>面对不同的消息中间件，用户学习成本较高。</li><li>迁移成本非常高，且结果不统一。</li></ul></li><li><p>2018年我们提出RocketMQ 5.0，可能会做一些架构计算分离，包括协议可插拔，支持IoT的一些场景，目前我们正在演进该版本。</p></li></ul><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220317145623986.png" alt="image-20220317145623986"></p><p><strong>产生原因：</strong></p><p>淘宝内部的交易系统使用了淘宝自主研发的 Notify 消息中间件，使用 MySQL 作为消息存储媒介，可完全水平扩容。</p><p>为了进一步降低成本，我们认为存储部分可以进一步优化。2011 年初，Linkin 开源了 Kafka 这个优秀的消息中间件，淘宝中间件团队在对 Kafka 做过充分 Review 之后， Kafka 无限消息堆积，高效的持久化速度吸引了我们。</p><p>但是，同时发现这个消息系统主要定位于日志传输，对于使用在淘宝交易、订单、充值等场景下还有诸多特性不满足，为此我们重新用 Java 语言编写了 RocketMQ ，定位于非日志的可靠消息传输（日志场景也 OK）。</p><p>目前 RocketMQ 在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理， binglog 分发等场景。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="消息模型（Message-Model）"><a href="#消息模型（Message-Model）" class="headerlink" title="消息模型（Message Model）"></a>消息模型（Message Model）</h2><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p><h2 id="消息生产者（Producer）"><a href="#消息生产者（Producer）" class="headerlink" title="消息生产者（Producer）"></a>消息生产者（Producer）</h2><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p><h2 id="消息消费者（Consumer）"><a href="#消息消费者（Consumer）" class="headerlink" title="消息消费者（Consumer）"></a>消息消费者（Consumer）</h2><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p><h2 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）"></a>主题（Topic）</h2><p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p><h2 id="代理服务器（Broker-Server）"><a href="#代理服务器（Broker-Server）" class="headerlink" title="代理服务器（Broker Server）"></a>代理服务器（Broker Server）</h2><p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p><h2 id="名字服务（Name-Server）"><a href="#名字服务（Name-Server）" class="headerlink" title="名字服务（Name Server）"></a>名字服务（Name Server）</h2><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p><h2 id="拉取式消费（Pull-Consumer）"><a href="#拉取式消费（Pull-Consumer）" class="headerlink" title="拉取式消费（Pull Consumer）"></a>拉取式消费（Pull Consumer）</h2><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p><h2 id="推动式消费（Push-Consumer）"><a href="#推动式消费（Push-Consumer）" class="headerlink" title="推动式消费（Push Consumer）"></a>推动式消费（Push Consumer）</h2><p>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p><h2 id="生产者组（Producer-Group）"><a href="#生产者组（Producer-Group）" class="headerlink" title="生产者组（Producer Group）"></a>生产者组（Producer Group）</h2><p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p><h2 id="消费者组（Consumer-Group）"><a href="#消费者组（Consumer-Group）" class="headerlink" title="消费者组（Consumer Group）"></a>消费者组（Consumer Group）</h2><p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p><h2 id="集群消费（Clustering）"><a href="#集群消费（Clustering）" class="headerlink" title="集群消费（Clustering）"></a>集群消费（Clustering）</h2><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p><h2 id="广播消费（Broadcasting）"><a href="#广播消费（Broadcasting）" class="headerlink" title="广播消费（Broadcasting）"></a>广播消费（Broadcasting）</h2><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p><h2 id="普通顺序消息（Normal-Ordered-Message）"><a href="#普通顺序消息（Normal-Ordered-Message）" class="headerlink" title="普通顺序消息（Normal Ordered Message）"></a>普通顺序消息（Normal Ordered Message）</h2><p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p><h2 id="严格顺序消息（Strictly-Ordered-Message）"><a href="#严格顺序消息（Strictly-Ordered-Message）" class="headerlink" title="严格顺序消息（Strictly Ordered Message）"></a>严格顺序消息（Strictly Ordered Message）</h2><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p><h2 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）"></a>消息（Message）</h2><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p><h2 id="标签（Tag）"><a href="#标签（Tag）" class="headerlink" title="标签（Tag）"></a>标签（Tag）</h2><p>为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p><h1 id="相关特性"><a href="#相关特性" class="headerlink" title="相关特性"></a>相关特性</h1><h2 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h2><p>消息的发布是指某个生产者向某个topic发送消息；消息的订阅是指某个消费者关注了某个topic中带有某些tag的消息，进而从该topic消费数据。</p><h2 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h2><p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ可以严格的保证消息有序。</p><p>顺序消息分为全局顺序消息与分区顺序消息，全局顺序是指某个Topic下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</p><ul><li>全局顺序 对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。 适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</li><li>分区顺序 对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。 Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。 适用场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</li></ul><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>RocketMQ的消费者可以根据Tag进行消息过滤，也支持自定义属性过滤。消息过滤目前是在Broker端实现的，优点是减少了对于Consumer无用消息的网络传输，缺点是增加了Broker的负担、而且实现相对复杂。</p><h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><p>RocketMQ支持消息的高可靠，影响消息可靠性的几种情况：</p><ol><li>Broker非正常关闭</li><li>Broker异常Crash</li><li>OS Crash</li><li>机器掉电，但是能立即恢复供电情况</li><li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</li><li>磁盘设备损坏</li></ol><p>1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p><p>5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。</p><h2 id="至少一次"><a href="#至少一次" class="headerlink" title="至少一次"></a>至少一次</h2><p>至少一次(At least Once)指每个消息必须投递一次。Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。</p><h2 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h2><p>回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ支持按照时间回溯消费，时间维度精确到毫秒。</p><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>RocketMQ事务消息（Transactional Message）是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ的事务消息提供类似 X/Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致。</p><h2 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h2><p>定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。 broker有配置项messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。可以配置自定义messageDelayLevel。注意，messageDelayLevel是broker的属性，不属于某个topic。发消息时，设置delayLevel等级即可：msg.setDelayLevel(level)。level有以下三种情况：</p><ul><li>level == 0，消息为非延迟消息</li><li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1s</li><li>level &gt; maxLevel，则level== maxLevel，例如level==20，延迟2h</li></ul><p>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p><p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p><h2 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h2><p>Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p><ul><li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。</li><li>由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</li></ul><p>RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p><h2 id="消息重投"><a href="#消息重投" class="headerlink" title="消息重投"></a>消息重投</h2><p>生产者在发送消息时，同步消息失败会重投，异步消息有重试，oneway没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在RocketMQ中是无法避免的问题。消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer负载变化也会导致重复消息。如下方法可以设置消息重试策略：</p><ul><li>retryTimesWhenSendFailed:同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed + 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。</li><li>retryTimesWhenSendAsyncFailed:异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</li><li>retryAnotherBrokerWhenNotStoreOK:消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。十分重要消息可以开启。</li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>生产者流控，因为broker处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</p><p>生产者流控：</p><ul><li>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认为1000ms，返回流控。</li><li>如果开启transientStorePoolEnable == true，且broker为异步刷盘的主机，且transientStorePool中资源不足，拒绝当前send请求，返回流控。</li><li>broker每隔10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsInSendQueue，默认200ms，拒绝当前send请求，返回流控。</li><li>broker通过拒绝send 请求方式实现流量控制。</li></ul><p>注意，生产者流控，不会尝试消息重投。</p><p>消费者流控：</p><ul><li>消费者本地缓存消息数超过pullThresholdForQueue时，默认1000。</li><li>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB。</li><li>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认2000。</li></ul><p>消费者流控的结果是降低拉取频率。</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p><p>RocketMQ将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。在RocketMQ中，可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p> <img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220317152620545.png" alt="image-20220317152620545"></p><ul><li>生产者（Producer）：负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。</li><li>消费者（Consumer）：负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。</li><li>消息服务器（Broker）：是消息存储中心，主要作用是接收来自 Producer 的消息并存储， Consumer 从这里取得消息。</li><li>名称服务器（NameServer）：用来保存 Broker 相关 Topic 等元信息并给 Producer ，提供 Consumer 查找 Broker 信息。</li></ul><h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220317152958574.png" alt="image-20220317152958574"></p><p>1、启动 <strong>Namesrver</strong>，Namesrver起来后监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心。</p><p>2、<strong>Broker</strong> 启动，跟所有的 Namesrver 保持长连接，定时发送心跳包。</p><blockquote><p>心跳包中，包含当前 Broker 信息(IP+端口等)以及存储所有 Topic 信息。 注册成功后，Namesrver 集群中就有 Topic 跟 Broker 的映射关系。</p></blockquote><p>3、收发消息前，先创建 Topic 。创建 Topic 时，需要指定该 Topic 要存储在哪些 Broker上。也可以在发送消息时自动创建Topic。</p><p>4、<strong>Producer</strong> 发送消息。</p><blockquote><p>启动时，先跟 Namesrver 集群中的其中一台建立长连接，并从Namesrver 中获取当前发送的 Topic 存在哪些 Broker 上，然后跟对应的 Broker 建立长连接，直接向 Broker 发消息。</p></blockquote><p>5、<strong>Consumer</strong> 消费消息。</p><blockquote><p>Consumer 跟 Producer 类似。跟其中一台 Namesrv 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始消费消息。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>目前 RocketMQ 4 的中文文档很少，所以英文不太好的胖友，后续推荐看看如下资料：</p><ul><li><a href="http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408164726/RocketMQ_userguide.pdf">《RocketMQ 用户指南》</a> 基于 RocketMQ 3 的版本。</li><li><a href="http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408165024/RocketMQ_design.pdf">《RocketMQ 原理简介》</a> 基于 RocketMQ 3 的版本。</li><li><a href="http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408164929/RocketMQ_experience.pdf">《RocketMQ 最佳实践》</a> 基于 RocketMQ 3 的版本。</li><li><a href="https://github.com/apache/rocketmq/tree/master/docs/cn">《RocketMQ 开发者指南》</a> 基于 RocketMQ 4 的版本。</li><li><a href="https://help.aliyun.com/product/29530.html?spm=a2c4g.11186623.6.540.68cc5b3aZYDU2Y">《阿里云 —— 消息队列 MQ》</a> 阿里云的消息队列，就是 RocketMQ 的云服务。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;阿里巴巴消息中间件起源于 2001 年的五彩石项目， Notify 在这期间应运而生，用于交易核心消息的流转 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="RocketMQ" scheme="https://leslieaibin.github.io/categories/RocketMQ/"/>
    
    
    <category term="RocketMQ" scheme="https://leslieaibin.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>8.select poll epoll 区别</title>
    <link href="https://leslieaibin.github.io/2022/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.select%20poll%20%E5%92%8C%20epoll%E5%8C%BA%E5%88%AB/"/>
    <id>https://leslieaibin.github.io/2022/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.select%20poll%20%E5%92%8C%20epoll%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-10T16:15:42.000Z</published>
    <updated>2022-05-14T09:03:08.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="select、poll和epoll区别"><a href="#select、poll和epoll区别" class="headerlink" title="select、poll和epoll区别"></a>select、poll和epoll区别</h1><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic2.zhimg.com/v2-3c486898d786b26259c6abd6854794f5_b.jpg"></p><p>select单个进程可监视的fd数量受到限制，epoll和select都可实现同时监听多个I/O事件的状态。</p><ul><li>  select 基于轮训机制</li><li>  epoll基于操作系统支持的I/O通知机制 epoll支持水平触发和边沿触发两种模式。</li></ul><h2 id="1-select"><a href="#1-select" class="headerlink" title="1 select"></a>1 select</h2><p>select本质上是通过设置或检查存放fd标志位的数据结构进行下一步处理。 这带来缺点：</p><ul><li>  单个进程可监视的fd数量被限制，即能监听端口的数量有限 单个进程所能打开的最大连接数有<code>FD_SETSIZE</code>宏定义，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上FD_SETSIZE为3264），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试 一般该数和系统内存关系很大，具体数目可以<code>cat /proc/sys/fs/file-max</code>察看。32位机默认1024个，64位默认2048。</li></ul><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-62bedee13b5fa6c4022ade31c942316c_b.png"></p><ul><li>  对socket是线性扫描，即轮询，效率较低： 仅知道有I/O事件发生，却不知是哪几个流，只会无差异轮询所有流，找出能读数据或写数据的流进行操作。同时处理的流越多，无差别轮询时间越长 - O(n)。</li></ul><p>当socket较多时，每次select都要通过遍历<code>FD_SETSIZE</code>个socket，不管是否活跃，这会浪费很多CPU时间。如果能给 socket 注册某个回调函数，当他们活跃时，自动完成相关操作，即可避免轮询，这就是<strong>epoll</strong>与<strong>kqueue</strong>。</p><h2 id="1-1-调用过程"><a href="#1-1-调用过程" class="headerlink" title="1.1 调用过程"></a>1.1 调用过程</h2><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-7a9905f316445b3d7f7287d80a6fe460_b.jpg"></p><pre><code>asmlinkage long sys_poll(struct pollfd * ufds, unsigned int nfds, long timeout)&#123;    int i, j, fdcount, err;    struct pollfd **fds;    struct poll_wqueues table, *wait;    int nchunks, nleft;    /* Do a sanity check on nfds ... */    if (nfds &gt; NR_OPEN)        return -EINVAL;    if (timeout) &#123;        /* Careful about overflow in the intermediate values */        if ((unsigned long) timeout &lt; MAX_SCHEDULE_TIMEOUT / HZ)            timeout = (unsigned long)(timeout*HZ+999)/1000+1;        else /* Negative or overflow */            timeout = MAX_SCHEDULE_TIMEOUT;    &#125;    // 2. 注册回调函数__pollwait    poll_initwait(&amp;table);    wait = &amp;table;    if (!timeout)        wait = NULL;    err = -ENOMEM;    fds = NULL;    if (nfds != 0) &#123;        fds = (struct pollfd **)kmalloc(            (1 + (nfds - 1) / POLLFD_PER_PAGE) * sizeof(struct pollfd *),            GFP_KERNEL);        if (fds == NULL)            goto out;    &#125;    nchunks = 0;    nleft = nfds;    while (nleft &gt; POLLFD_PER_PAGE) &#123; /* allocate complete PAGE_SIZE chunks */        fds[nchunks] = (struct pollfd *)__get_free_page(GFP_KERNEL);        if (fds[nchunks] == NULL)            goto out_fds;        nchunks++;        nleft -= POLLFD_PER_PAGE;    &#125;    if (nleft) &#123; /* allocate last PAGE_SIZE chunk, only nleft elements used */        fds[nchunks] = (struct pollfd *)__get_free_page(GFP_KERNEL);        if (fds[nchunks] == NULL)            goto out_fds;    &#125;    err = -EFAULT;    for (i=0; i &lt; nchunks; i++)        //         if (copy_from_user(fds[i], ufds + i*POLLFD_PER_PAGE, PAGE_SIZE))            goto out_fds1;    if (nleft) &#123;        if (copy_from_user(fds[nchunks], ufds + nchunks*POLLFD_PER_PAGE,                 nleft * sizeof(struct pollfd)))            goto out_fds1;    &#125;    fdcount = do_poll(nfds, nchunks, nleft, fds, wait, timeout);    /* OK, now copy the revents fields back to user space. */    for(i=0; i &lt; nchunks; i++)        for (j=0; j &lt; POLLFD_PER_PAGE; j++, ufds++)            __put_user((fds[i] + j)-&gt;revents, &amp;ufds-&gt;revents);    if (nleft)        for (j=0; j &lt; nleft; j++, ufds++)            __put_user((fds[nchunks] + j)-&gt;revents, &amp;ufds-&gt;revents);    err = fdcount;    if (!fdcount &amp;&amp; signal_pending(current))        err = -EINTR;out_fds1:    if (nleft)        free_page((unsigned long)(fds[nchunks]));out_fds:    for (i=0; i &lt; nchunks; i++)        free_page((unsigned long)(fds[i]));    if (nfds != 0)        kfree(fds);out:    poll_freewait(&amp;table);    return err;&#125;static int do_poll(unsigned int nfds, unsigned int nchunks, unsigned int nleft,     struct pollfd *fds[], struct poll_wqueues *wait, long timeout)&#123;    int count;    poll_table* pt = &amp;wait-&gt;pt;    for (;;) &#123;        unsigned int i;        set_current_state(TASK_INTERRUPTIBLE);        count = 0;        for (i=0; i &lt; nchunks; i++)            do_pollfd(POLLFD_PER_PAGE, fds[i], &amp;pt, &amp;count);        if (nleft)            do_pollfd(nleft, fds[nchunks], &amp;pt, &amp;count);        pt = NULL;        if (count || !timeout || signal_pending(current))            break;        count = wait-&gt;error;        if (count)            break;        timeout = schedule_timeout(timeout);    &#125;    current-&gt;state = TASK_RUNNING;    return count;&#125;</code></pre><ol><li> 使用copy_from_user从用户空间拷贝fd_set到内核空间</li><li> 注册回调函数<code>__pollwait</code></li></ol><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-d4a98237f706b112ab6c6a6a94b6539c_b.jpg"></p><ol><li><p> 遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll，udp_poll或datagram_poll）</p></li><li><p> 以tcp_poll为例，核心实现就是<code>__pollwait</code>，即上面注册的回调函数</p></li><li><p> <code>__pollwait</code>，就是把current（当前进程）挂到设备的等待队列，不同设备有不同等待队列，如tcp_poll的等待队列是sk-&gt;sk_sleep（把进程挂到等待队列中并不代表进程已睡眠）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒。</p></li><li><p> poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值</p></li><li><p> 若遍历完所有fd，还没返回一个可读写的mask掩码，则调schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。若超过一定超时时间（schedule_timeout指定），还没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有无就绪的fd</p></li><li><p> 把fd_set从内核空间拷贝到用户空间</p></li></ol><h2 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 缺点</h2><p>内核需要将消息传递到用户空间，都需要内核拷贝动作。需要维护一个用来存放大量fd的数据结构，使得用户空间和内核空间在传递该结构时复制开销大。</p><ul><li>  每次调用select，都需把fd集合从用户态拷贝到内核态，fd很多时开销就很大</li><li>  同时每次调用select都需在内核遍历传递进来的所有fd，fd很多时开销就很大</li><li>  select支持的文件描述符数量太小了，默认最大支持1024个</li><li>  主动轮询效率很低</li></ul><h2 id="2-poll"><a href="#2-poll" class="headerlink" title="2 poll"></a>2 poll</h2><p>和select类似，只是描述fd集合的方式不同，poll使用<code>pollfd</code>结构而非select的<code>fd_set</code>结构。 管理多个描述符也是进行轮询，根据描述符的状态进行处理，但<strong>poll没有最大文件描述符数量的限制</strong>。</p><p>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><ul><li><p>  它将用户传入的数组拷贝到内核空间</p></li><li><p>  然后查询每个fd对应的设备状态：</p></li><li><p>  如果设备就绪 在设备等待队列中加入一项继续遍历</p></li><li><p>  若遍历完所有fd后，都没发现就绪的设备 挂起当前进程，直到设备就绪或主动超时，被唤醒后它又再次遍历fd。这个过程经历多次无意义的遍历。</p></li></ul><p>没有最大连接数限制，因其基于链表存储，其缺点：</p><ul><li>  大量fd数组被整体复制于用户态和内核地址空间间，而不管是否有意义</li><li>  如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd</li></ul><p>所以又有了epoll模型。</p><h2 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3 epoll"></a>3 epoll</h2><p>epoll模型修改主动轮询为被动通知，当有事件发生时，被动接收通知。所以epoll模型注册套接字后，主程序可做其他事情，当事件发生时，接收到通知后再去处理。</p><p>可理解为<strong>event poll</strong>，epoll会把哪个流发生哪种I/O事件通知我们。所以epoll是事件驱动（每个事件关联fd），此时我们对这些流的操作都是有意义的。复杂度也降到O(1)。</p><pre><code>asmlinkage int sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)&#123;    int error;    struct file *file, *tfile;    struct eventpoll *ep;    struct epitem *epi;    struct epoll_event epds;    error = -EFAULT;    if (copy_from_user(&amp;epds, event, sizeof(struct epoll_event)))        goto eexit_1;    /* Get the &quot;struct file *&quot; for the eventpoll file */    error = -EBADF;    file = fget(epfd);    if (!file)        goto eexit_1;    /* Get the &quot;struct file *&quot; for the target file */    tfile = fget(fd);    if (!tfile)        goto eexit_2;    /* The target file descriptor must support poll */    error = -EPERM;    if (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)        goto eexit_3;    /*     * We have to check that the file structure underneath the file descriptor     * the user passed to us _is_ an eventpoll file. And also we do not permit     * adding an epoll file descriptor inside itself.     */    error = -EINVAL;    if (file == tfile || !IS_FILE_EPOLL(file))        goto eexit_3;    /*     * At this point it is safe to assume that the &quot;private_data&quot; contains     * our own data structure.     */    ep = file-&gt;private_data;    /*     * Try to lookup the file inside our hash table. When an item is found     * ep_find() increases the usage count of the item so that it won&#39;t     * desappear underneath us. The only thing that might happen, if someone     * tries very hard, is a double insertion of the same file descriptor.     * This does not rapresent a problem though and we don&#39;t really want     * to put an extra syncronization object to deal with this harmless condition.     */    epi = ep_find(ep, tfile);    error = -EINVAL;    switch (op) &#123;    case EPOLL_CTL_ADD:        if (!epi) &#123;            epds.events |= POLLERR | POLLHUP;            error = ep_insert(ep, &amp;epds, tfile);        &#125; else            error = -EEXIST;        break;    case EPOLL_CTL_DEL:        if (epi)            error = ep_remove(ep, epi);        else            error = -ENOENT;        break;    case EPOLL_CTL_MOD:        if (epi) &#123;            epds.events |= POLLERR | POLLHUP;            error = ep_modify(ep, epi, &amp;epds);        &#125; else            error = -ENOENT;        break;    &#125;    /*     * The function ep_find() increments the usage count of the structure     * so, if this is not NULL, we need to release it.     */    if (epi)        ep_release_epitem(epi);eexit_3:    fput(tfile);eexit_2:    fput(file);eexit_1:    DNPRINTK(3, (KERN_INFO &quot;[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %u) = %d\n&quot;,             current, epfd, op, fd, event-&gt;events, error));    return error;&#125;</code></pre><p>​    </p><h2 id="3-1-触发模式"><a href="#3-1-触发模式" class="headerlink" title="3.1 触发模式"></a>3.1 触发模式</h2><p><strong>EPOLLLT</strong>和<strong>EPOLLET</strong>两种：</p><ul><li>  LT，默认的模式（水平触发） 只要该fd还有数据可读，每次 <code>epoll_wait</code> 都会返回它的事件，提醒用户程序去操作，</li><li>  ET是“高速”模式（边缘触发）</li></ul><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic2.zhimg.com/v2-310cc7857eabd42e324c109b5ca85b1d_b.png"></p><p>只会提示一次，直到下次再有数据流入之前都不会再提示，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读完，即读到read返回值小于请求值或遇到EAGAIN错误</p><p>epoll使用“事件”的就绪通知方式，通过<code>epoll_ctl</code>注册fd，一旦该fd就绪，内核就会采用类似回调机制激活该fd，<code>epoll_wait</code>便可收到通知。</p><h3 id="EPOLLET触发模式的意义"><a href="#EPOLLET触发模式的意义" class="headerlink" title="EPOLLET触发模式的意义"></a>EPOLLET触发模式的意义</h3><p>若用<code>EPOLLLT</code>，系统中一旦有大量无需读写的就绪文件描述符，它们每次调用<code>epoll_wait</code>都会返回，这大大降低处理程序检索自己关心的就绪文件描述符的效率。 而采用<code>EPOLLET</code>，当被监控的文件描述符上有可读写事件发生时，<code>epoll_wait</code>会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用<code>epoll_wait</code>时，它不会通知你，即只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。这比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。</p><h2 id="3-2-优点"><a href="#3-2-优点" class="headerlink" title="3.2 优点"></a>3.2 优点</h2><ul><li>  没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</li><li>  效率提升，不是轮询，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数 即Epoll最大的优点就在于它只关心“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll</li><li>  内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li><li>  epoll通过内核和用户空间共享一块内存来实现的</li></ul><p>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现。</p><p>select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p><ul><li>  对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</li><li>  对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。</li><li>  对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>select，poll，epoll都是IO多路复用机制，即可以监视多个描述符，一旦某个描述符就绪（读或写就绪），能够通知程序进行相应读写操作。 但select，poll，epoll本质上都是<strong>同步I/O</strong>，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><ul><li>  select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</li><li>  select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;select、poll和epoll区别&quot;&gt;&lt;a href=&quot;#select、poll和epoll区别&quot; class=&quot;headerlink&quot; title=&quot;select、poll和epoll区别&quot;&gt;&lt;/a&gt;select、poll和epoll区别&lt;/h1&gt;&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Ping的原理</title>
    <link href="https://leslieaibin.github.io/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.Ping%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.Ping%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2022-03-08T01:15:42.000Z</published>
    <updated>2022-03-08T02:37:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ping-的工作原理"><a href="#ping-的工作原理" class="headerlink" title="ping 的工作原理"></a>ping 的工作原理</h1><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="IP协议的助手-——-ICMP-协议"><a href="#IP协议的助手-——-ICMP-协议" class="headerlink" title="IP协议的助手 —— ICMP 协议"></a>IP协议的助手 —— ICMP 协议</h3><p>ping 是基于 <code>ICMP</code> 协议工作的，所以要明白 ping 的工作，首先我们先来熟悉 <strong>ICMP 协议</strong>。</p><blockquote><p>ICMP 是什么？</p></blockquote><p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。</p><p>里面有个关键词 —— <strong>控制</strong>，如何控制的呢？</p><p>网络包在复杂的网络传输环境里，常常会遇到各种问题。当遇到问题的时候，总不能死的不明不白，没头没脑的作风不是计算机网络的风格。所以需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。</p><blockquote><p>ICMP 功能都有啥？</p></blockquote><p><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/4.jpg" title="ICMP 目标不可达消息"></p><p>ICMP 目标不可达消息</p><p>如上图例子，主机 <code>A</code> 向主机 <code>B</code> 发送了数据包，由于某种原因，途中的路由器 <code>2</code> 未能发现主机 <code>B</code> 的存在，这时，路由器 <code>2</code> 就会向主机 <code>A</code> 发送一个 <code>ICMP</code> 目标不可达数据包，说明发往主机 <code>B</code> 的包未能成功。</p><p>ICMP 的这种通知消息会使用 <code>IP</code> 进行发送 。</p><p>因此，从路由器 <code>2</code> 返回的 ICMP 包会按照往常的路由控制先经过路由器 <code>1</code> 再转发给主机 <code>A</code> 。收到该 ICMP 包的主机 <code>A</code> 则分解 ICMP 的首部和数据域以后得知具体发生问题的原因。</p><blockquote><p>ICMP 包头格式</p></blockquote><p>ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/5.jpg" title="ICMP 报文">ICMP 报文</p><p>ICMP 包头的<strong>类型</strong>字段，大致可以分为两大类：</p><ul><li>  一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>  另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/6.jpg" title="常见的 ICMP 类型">常见的 ICMP 类型</p><h3 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h3><blockquote><p>回送消息 —— 类型 <code>0</code> 和 <code>8</code></p></blockquote><p><strong>回送消息</strong>用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，<code>ping</code> 命令就是利用这个消息实现的。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/7.jpg" title="ICMP 回送消息">ICMP 回送消息</p><p>可以向对端主机发送<strong>回送请求</strong>的消息（<code>ICMP Echo Request Message</code>，类型 <code>8</code>），也可以接收对端主机发回来的<strong>回送应答</strong>消息（<code>ICMP Echo Reply Message</code>，类型 <code>0</code>）。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/8.jpg" title="ICMP 回送请求和回送应答报文">ICMP 回送请求和回送应答报文</p><p>相比原生的 ICMP，这里多了两个字段：</p><ul><li>  <strong>标识符</strong>：用以区分是哪个应用程序发 ICMP 包，比如用进程 <code>PID</code> 作为标识符；</li><li>  <strong>序号</strong>：序列号从 <code>0</code> 开始，每发送一次新的回送请求就会加 <code>1</code>， 可以用来确认网络包是否有丢失。</li></ul><p>在<strong>选项数据</strong>中，<code>ping</code> 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。</p><h3 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h3><p>接下来，说明几个常用的 ICMP 差错报文的例子：</p><ul><li>  目标不可达消息 —— 类型 为 <code>3</code></li><li>  原点抑制消息 —— 类型 <code>4</code></li><li>  重定向消息 —— 类型 <code>5</code></li><li>  超时消息 —— 类型 <code>11</code></li></ul><blockquote><p>目标不可达消息（Destination Unreachable Message） —— 类型为 <code>3</code></p></blockquote><p>IP 路由器无法将 IP 数据包发送给目标地址时，会给发送端主机返回一个<strong>目标不可达</strong>的 ICMP 消息，并在这个消息中显示不可达的具体原因，原因记录在 ICMP 包头的<strong>代码</strong>字段。</p><p>由此，根据 ICMP 不可达的具体消息，发送端主机也就可以了解此次发送<strong>不可达的具体原因</strong>。</p><p>举例 6 种常见的目标不可达类型的<strong>代码</strong>：</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/9.jpg" title="目标不可达类型的常见代码号">目标不可达类型的常见代码号</p><ul><li>  网络不可达代码为 <code>0</code></li><li>  主机不可达代码为 <code>1</code></li><li>  协议不可达代码为 <code>2</code></li><li>  端口不可达代码为 <code>3</code></li><li>  需要进行分片但设置了不分片位代码为 <code>4</code></li></ul><p>为了给大家说清楚上面的目标不可达的原因，<strong>小林牺牲自己给大家送 5 次外卖。</strong></p><p>为什么要送外卖？别问，问就是为 <code>35</code> 岁的老林做准备 …</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/10.jpg" title="外卖员 —— 小林">外卖员 —— 小林</p><h6 id="a-网络不可达代码为-0"><a href="#a-网络不可达代码为-0" class="headerlink" title="a. 网络不可达代码为 0"></a>a. 网络不可达代码为 0</h6><p><em>外卖版本：</em></p><p>小林第一次送外卖时，小区里只有 A 和 B 区两栋楼，但送餐地址写的是 C 区楼，小林表示头上很多问号，压根就没这个地方。</p><p><em>正常版本：</em></p><p>IP 地址是分为网络号和主机号的，所以当路由器中的路由器表匹配不到接收方 IP 的网络号，就通过 ICMP 协议以<strong>网络不可达</strong>（<code>Network Unreachable</code>）的原因告知主机。</p><p>自从不再有网络分类以后，网络不可达也渐渐不再使用了。</p><h6 id="b-主机不可达代码为-1"><a href="#b-主机不可达代码为-1" class="headerlink" title="b. 主机不可达代码为 1"></a>b. 主机不可达代码为 1</h6><p><em>外卖版本：</em></p><p>小林第二次送外卖时，这次小区有 5 层楼高的 C 区楼了，找到地方了，但送餐地址写的是 C 区楼 601 号房 ，说明找不到这个房间。</p><p><em>正常版本：</em></p><p>当路由表中没有该主机的信息，或者该主机没有连接到网络，那么会通过 ICMP 协议以<strong>主机不可达</strong>（<code>Host Unreachable</code>）的原因告知主机。</p><h6 id="c-协议不可达代码为-2"><a href="#c-协议不可达代码为-2" class="headerlink" title="c. 协议不可达代码为 2"></a>c. 协议不可达代码为 2</h6><p><em>外卖版本：</em></p><p>小林第三次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，但是一开门人家是外国人说的是英语，我说的是中文！语言不通，外卖送达失败~</p><p><em>正常版本：</em></p><p>当主机使用 TCP 协议访问对端主机时，能找到对端的主机了，可是对端主机的防火墙已经禁止 TCP 协议访问，那么会通过 ICMP 协议以<strong>协议不可达</strong>的原因告知主机。</p><h6 id="d-端口不可达代码为-3"><a href="#d-端口不可达代码为-3" class="headerlink" title="d. 端口不可达代码为 3"></a>d. 端口不可达代码为 3</h6><p><em>外卖版本：</em></p><p>小林第四次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，房间里的人也是说中文的人了，但是人家说他要的不是外卖，而是快递。。。</p><p><em>正常版本：</em></p><p>当主机访问对端主机 8080 端口时，这次能找到对端主机了，防火墙也没有限制，可是发现对端主机没有进程监听 8080 端口，那么会通过 ICMP 协议以<strong>端口不可达</strong>的原因告知主机。</p><h6 id="e-需要进行分片但设置了不分片位代码为-4"><a href="#e-需要进行分片但设置了不分片位代码为-4" class="headerlink" title="e. 需要进行分片但设置了不分片位代码为 4"></a>e. 需要进行分片但设置了不分片位代码为 4</h6><p><em>外卖版本：</em></p><p>小林第五次送外卖时，这次是个吃播博主点了 100 份外卖，但是吃播博主要求一次性要把全部外卖送达，小林的一台电动车装不下呀，这样就没办法送达了。</p><p><em>正常版本：</em></p><p>发送端主机发送 IP 数据报时，将 IP 首部的<strong>分片禁止标志位</strong>设置为<code>1</code>。根据这个标志位，途中的路由器遇到超过 MTU 大小的数据包时，不会进行分片，而是直接抛弃。</p><p>随后，通过一个 ICMP 的不可达消息类型，<strong>代码为 4</strong> 的报文，告知发送端主机。</p><blockquote><p>原点抑制消息（ICMP Source Quench Message） —— 类型 <code>4</code></p></blockquote><p>在使用低速广域线路的情况下，连接 WAN 的路由器可能会遇到网络拥堵的问题。</p><p><code>ICMP</code> 原点抑制消息的目的就是<strong>为了缓和这种拥堵情况</strong>。</p><p>当路由器向低速线路发送数据时，其发送队列的缓存变为零而无法发送出去时，可以向 IP 包的源地址发送一个 ICMP <strong>原点抑制消息</strong>。</p><p>收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况，从而增大 IP 包的传输间隔，减少网络拥堵的情况。</p><p>然而，由于这种 ICMP 可能会引起不公平的网络通信，一般不被使用。</p><blockquote><p>重定向消息（ICMP Redirect Message） —— 类型 <code>5</code></p></blockquote><p>如果路由器发现发送端主机使用了「不是最优」的路径发送数据，那么它会返回一个 ICMP <strong>重定向消息</strong>给这个主机。</p><p>在这个消息中包含了<strong>最合适的路由信息和源数据</strong>。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息告知发送端，让它下次发给另外一个路由器。</p><p>好比，小林本可以过条马路就能到的地方，但小林不知道，所以绕了一圈才到，后面小林知道后，下次小林就不会那么<strong>傻</strong>再绕一圈了。</p><blockquote><p>超时消息（ICMP Time Exceeded Message） —— 类型 <code>11</code></p></blockquote><p>IP 包中有一个字段叫做 <code>TTL</code> （<code>Time To Live</code>，生存周期），它的<strong>值随着每经过一次路由器就会减 1，直到减到 0 时该 IP 包会被丢弃。</strong></p><p>此时，路由器将会发送一个 ICMP <strong>超时消息</strong>给发送端主机，并通知该包已被丢弃。</p><p>设置 IP 包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免 IP 包无休止地在网络上被转发。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/11.jpg" title="ICMP 时间超过消息">ICMP 时间超过消息</p><p>此外，有时可以用 TTL 控制包的到达范围，例如设置一个<strong>较小的 TTL 值</strong>。</p><hr><h3 id="ping-——-查询报文类型的使用"><a href="#ping-——-查询报文类型的使用" class="headerlink" title="ping —— 查询报文类型的使用"></a>ping —— 查询报文类型的使用</h3><p>接下来，我们重点来看 <code>ping</code> 的<strong>发送和接收过程</strong>。</p><p>同个子网下的主机 A 和 主机 B，主机 A 执行<code>ping</code> 主机 B 后，我们来看看其间发送了什么？</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/12.jpg" title="主机 A ping 主机 B">主机 A ping 主机 B</p><p>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包。</p><p>ICMP 数据包内包含多个字段，最重要的是两个：</p><ul><li>  第一个是<strong>类型</strong>，对于回送请求消息而言该字段为 <code>8</code>；</li><li>  另外一个是<strong>序号</strong>，主要用于区分连续 ping 的时候发出的多个数据包。</li></ul><p>每发出一个请求数据包，序号会自动加 <code>1</code>。为了能够计算往返时间 <code>RTT</code>，它会在报文的数据部分插入发送时间。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/13.jpg" title="主机 A 的 ICMP 回送请求报文">主机 A 的 ICMP 回送请求报文</p><p>然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为<strong>目的地址</strong>，本机 IP 地址作为<strong>源地址</strong>，<strong>协议</strong>字段设置为 <code>1</code> 表示是 <code>ICMP</code> 协议，再加上一些其他控制信息，构建一个 <code>IP</code> 数据包。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/14.jpg" title="主机 A 的 IP 层数据包">主机 A 的 IP 层数据包</p><p>接下来，需要加入 <code>MAC</code> 头。如果在本地 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 <code>ARP</code> 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/15.jpg" title="主机 A 的 MAC 层数据包">主机 A 的 MAC 层数据包</p><p>主机 <code>B</code> 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。</p><p>接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p><p>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去给主机 A。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/16.jpg" title="主机 B 的 ICMP 回送响应报文">主机 B 的 ICMP 回送响应报文</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</p><p>此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p>针对上面发送的事情，总结成了如下图：</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/17.png" title="主机 A ping 主机 B 期间发送的事情">主机 A ping 主机 B 期间发送的事情</p><p>当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。</p><p>但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据目标 IP 地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址。</p><p>说了这么多，可以看出 ping 这个程序是<strong>使用了 ICMP 里面的 ECHO REQUEST（类型为 8 ） 和 ECHO REPLY （类型为 0）</strong>。</p><h3 id="traceroute-——-差错报文类型的使用"><a href="#traceroute-——-差错报文类型的使用" class="headerlink" title="traceroute —— 差错报文类型的使用"></a>traceroute —— 差错报文类型的使用</h3><p>有一款充分利用 ICMP <strong>差错报文类型</strong>的应用叫做 <code>traceroute</code>（在UNIX、MacOS中是这个命令，而在Windows中对等的命令叫做 tracert ）。</p><p><em>1. traceroute 作用一</em></p><p>traceroute 的第一个作用就是<strong>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</strong></p><p>traceroute 的参数指向某个<strong>目的 IP 地址</strong>：</p><pre><code>traceroute 192.168.1.100</code></pre><blockquote><p>这个作用是如何工作的呢？</p></blockquote><p>它的原理就是利用 IP 包的<strong>生存期限</strong> 从 <code>1</code> 开始按照顺序递增的同时发送 <strong>UDP 包</strong>，强制接收 <strong>ICMP 超时消息</strong>的一种方法。</p><p>比如，将 TTL 设置 为 <code>1</code>，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是<strong>时间超时</strong>。</p><p>接下来将 TTL 设置为 <code>2</code>，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。</p><p>这样的过程，traceroute 就可以拿到了所有的路由器 IP。</p><p>当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。</p><blockquote><p>发送方如何知道发出的 UDP 包是否到达了目的主机呢？</p></blockquote><p>traceroute 在发送 <code>UDP</code> 包时，会填入一个<strong>不可能的端口号</strong>值作为 UDP 目标端口号（大于 <code>3000</code> ）。当目的主机，收到 UDP 包后，会返回 ICMP 差错报文消息，但这个差错报文消息的类型是「<strong>端口不可达</strong>」。</p><p>所以，<strong>当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。</strong></p><p><em>2. traceroute 作用二</em></p><p>traceroute 还有一个作用是<strong>故意设置不分片，从而确定路径的 MTU</strong>。</p><blockquote><p>这么做是为了什么？</p></blockquote><p>这样做的目的是为了<strong>路径MTU发现</strong>。</p><p>因为有的时候我们并不知道路由器的 <code>MTU</code> 大小，以太网的数据链路上的 <code>MTU</code> 通常是 <code>1500</code> 字节，但是非以外网的 <code>MTU</code> 值就不一样了，所以我们要知道 <code>MTU</code> 的大小，从而控制发送的包大小。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/ping/18.jpg" title="MTU 路径发现（UDP的情况下）">MTU 路径发现（UDP的情况下）</p><p>它的工作原理如下：</p><p>首先在发送端主机发送 <code>IP</code> 数据报时，将 <code>IP</code> 包首部的<strong>分片禁止标志位设置为 1</strong>。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。</p><p>随后，通过一个 ICMP 的不可达消息将<strong>数据链路上 MTU 的值</strong>一起给发送主机，不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」。</p><p>发送主机端每次收到 ICMP 差错报文时就<strong>减少</strong>包的大小，以此来定位一个合适的 <code>MTU</code> 值，以便能到达目标主机。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ping-的工作原理&quot;&gt;&lt;a href=&quot;#ping-的工作原理&quot; class=&quot;headerlink&quot; title=&quot;ping 的工作原理&quot;&gt;&lt;/a&gt;ping 的工作原理&lt;/h1&gt;&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP/IP" scheme="https://leslieaibin.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://leslieaibin.github.io/2021/12/23/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://leslieaibin.github.io/2021/12/23/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-12-22T16:15:42.000Z</published>
    <updated>2022-02-18T08:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p><p>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p>如何解决：将这些算法封装成一个一个的类，任意地替换。</p><p>关键代码：实现同一个接口。</p><p>应用实例： </p><ul><li><p>诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 </p></li><li><p>旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 </p></li><li><p>JAVA AWT 中的 LayoutManager。</p><p>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p></li></ul><p>使用场景： </p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </li><li>一个系统需要动态地在几种算法中选择一种。 </li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li></ul><p>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><p>实现：</p><p>首先创建一个接口用于运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运算接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有4个实现类分别是加减乘除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationDivision</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 / num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我需要一个类来封装这个接口以及具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());</span><br><span class="line">System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());</span><br><span class="line">System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());</span><br><span class="line">System.out.println(<span class="string">&quot;10 * 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationDivision());</span><br><span class="line">System.out.println(<span class="string">&quot;10 / 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><p>1、知道OO基础，并不足以让你设计出良好的））系统。</p><p>2、良好的OO设计必须具备可复用、可扩充、可维护三个特性。</p><p>3、模式可以让我们建造出具有良好OO设计质量的系统。</p><p>4、模式被认为是历经验证的OO设计经验。</p><p>5、模式不是代码，而是针对设计问题的通用解决方案。你可把它们应该到特定的应用中！</p><p>6、模式不是被发明、而是被发现。</p><p>7、大多数的模式和原则，都着眼于软件变化的主题。</p><p>8、大多数的模式都允许系统局部改变独立于其他部分。</p><p>9、我们常把系统中会变化的部分抽出来封装。</p><p>10、模式让开发人员之间有共享的语言，能够最大化沟通的价值。</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式定义了对象之间的一对多依赖，这样一来当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p><p>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p>何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p><p>如何解决：使用面向对象技术，可以将这种依赖关系弱化。</p><p>关键代码：在抽象类里有一个 ArrayList 存放观察者们。</p><p>应用实例： </p><ul><li><p>拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 </p></li><li><p>西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p><p>优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p><p>缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p></li></ul><p>使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p><p>注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p><p>实现：</p><p>首先创建观察者接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 观察者，所有的观察者都需要实现update方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzf</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer left,Integer right)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">   主题模式接口：</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 主题接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzf</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 用于注册观察者</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 删除观察者</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 当状态更新时这个方法会被调用通知所有观察者</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">      &#125;</span><br><span class="line">      主题实现类，里面存放了一个维护Observer(观察者)的列表：</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 主题的实现类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzf</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationData</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ArrayList&lt;Observer&gt; observersList=<span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">   <span class="keyword">private</span> Integer left;</span><br><span class="line">   <span class="keyword">private</span> Integer right;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   observersList.add(o);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   <span class="keyword">int</span> i=observersList.indexOf(o);</span><br><span class="line">   <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">   observersList.remove(i);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   <span class="keyword">for</span>(Observer o:observersList)</span><br><span class="line">   o.update(left, right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 当状态改变时调用notifyObserver，执行观察者方法</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Changed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      notifyObserver();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">(Integer left,Integer right)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.left=left;</span><br><span class="line">   <span class="keyword">this</span>.right=right;</span><br><span class="line">   Changed();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面实现三个Observer的实现类分别实现加减乘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 观察者实现类并将自身注册入Subject</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @author zzf </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @date 2018年10月17日 上午8:57:05 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer left;</span><br><span class="line">  <span class="keyword">private</span> Integer right;</span><br><span class="line">  <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AddDisplay</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subject=subject;</span><br><span class="line">  subject.registerObserver(<span class="keyword">this</span>);<span class="comment">//将自身注册入主题</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer left, Integer right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">this</span>.left=left;</span><br><span class="line">  <span class="keyword">this</span>.right=right;</span><br><span class="line">  display();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Add:&quot;</span>+(left+right));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @author zzf </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @date 2018年10月17日 上午9:04:19 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubstractDisplay</span>  <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer left;</span><br><span class="line">  <span class="keyword">private</span> Integer right;</span><br><span class="line">  <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubstractDisplay</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subject=subject;</span><br><span class="line">  subject.registerObserver(<span class="keyword">this</span>);<span class="comment">//将自身注册入主题</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer left, Integer right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">this</span>.left=left;</span><br><span class="line">  <span class="keyword">this</span>.right=right;</span><br><span class="line">  display();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Substract:&quot;</span>+(left-right));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *观察者的实现类（乘法）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @author zzf </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @date 2018年10月17日 上午9:11:32 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiplyDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer left;</span><br><span class="line">  <span class="keyword">private</span> Integer right;</span><br><span class="line">  <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MultiplyDisplay</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subject=subject;</span><br><span class="line">  subject.registerObserver(<span class="keyword">this</span>);<span class="comment">//将自身注册入主题</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer left, Integer right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">this</span>.left=left;</span><br><span class="line">  <span class="keyword">this</span>.right=right;</span><br><span class="line">  display();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Multiply:&quot;</span>+(left*right));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面创建一个测试类，将三个观察者的实现类注册入主题模式：</p><ul><li><pre><code class="java">/* * @author zzf * @date 2018年10月17日 上午9:05:48   */  public class Operation &#123;  public static void main(String[] args) &#123;      //创建主题      OperationData operationData=new OperationData();</code></pre></li></ul><pre><code>//将观察者的实现类注册入主题AddDisplay addDisplay=new AddDisplay(operationData);SubstractDisplay substractDisplay=new SubstractDisplay(operationData);MultiplyDisplay multiplyDisplay=new MultiplyDisplay(operationData);operationData.setChanged(5,5);operationData.setChanged(10, 3);&#125;&#125;</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.通过Java API里面的java.util包内自带的Observer接口和Observable类实现观察者模式（详细请阅读源码实现原理很简单）</span><br><span class="line"></span><br><span class="line">首先通过继承java.util.Observable来实现主题的实现类</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">import java.util.Observable;</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line"></span><br><span class="line">* @author zzf </span><br><span class="line"></span><br><span class="line">* @date 2018年10月17日 下午2:26:34 </span><br><span class="line">  *&#x2F;</span><br><span class="line">  public class OperationData extends Observable&#123;</span><br><span class="line"></span><br><span class="line">  private Integer left;</span><br><span class="line">  private Integer right;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line"></span><br><span class="line">   * 当状态改变时调用notifyObserver，执行观察者方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">     public void Changed() &#123;</span><br><span class="line">     setChanged();&#x2F;&#x2F;将changed设置为true</span><br><span class="line">     notifyObservers();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  public void setChanged(Integer left,Integer right) &#123;</span><br><span class="line">  this.left&#x3D;left;</span><br><span class="line">  this.right&#x3D;right;</span><br><span class="line">  Changed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Integer getLeft() &#123;</span><br><span class="line">  return left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setLeft(Integer left) &#123;</span><br><span class="line">  this.left &#x3D; left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Integer getRight() &#123;</span><br><span class="line">  return right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setRight(Integer right) &#123;</span><br><span class="line">  this.right &#x3D; right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过实现java.util.Observer来实现观察类：</p><pre><code>private Integer left;private Integer right;private Observable observable;public MultiplyDisplay(Observable observable) &#123;    this.observable=observable;    observable.addObserver(this);//将自身注册入主题&#125;@Overridepublic void update(Observable o, Object arg) &#123;    // TODO Auto-generated method stub    if(o instanceof OperationData) &#123;        OperationData operationData = (OperationData)o;        this.left=operationData.getLeft();        this.right=operationData.getRight();        display();    &#125;&#125;public void display() &#123;    System.out.println(&quot;Multiply:&quot;+(left*right));&#125;</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @author zzf </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* @date 2018年10月17日 下午2:31:37 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer left;</span><br><span class="line">  <span class="keyword">private</span> Integer right;</span><br><span class="line">  <span class="keyword">private</span> Observable observable;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AddDisplay</span><span class="params">(Observable observable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.observable=observable;</span><br><span class="line">  observable.addObserver(<span class="keyword">this</span>);<span class="comment">//将自身注册入主题</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">if</span>(o <span class="keyword">instanceof</span> OperationData) &#123;</span><br><span class="line">  OperationData operationData = (OperationData)o;</span><br><span class="line">  <span class="keyword">this</span>.left=operationData.getLeft();</span><br><span class="line">  <span class="keyword">this</span>.right=operationData.getRight();</span><br><span class="line">  display();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Add:&quot;</span>+(left+right));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><p>1、观察者模式定义了对象之间一对多的关系。</p><p>2、主题（可观察者）用一个共同的接口来更新观察者。</p><p>3、观察者和可观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</p><p>4、使用哦此模式时，你可从被观察者处推或拉数据。</p><p>5、有多个观察者模式时，不可以依赖特定的通知次序。</p><p>6、要注意java.util.Observable实现上带来的一些问题（是一个类非接口，违反了针对接口编程）。</p><p>7、如果有必要，可以实现自己的Observable。</p><p>8、Swing中运用了大量观察者模式，许多GUI框架也是如此。</p><p>参考：<a href="https://www.w3cschool.cn/shejimoshi/strategy-pattern.html">https://www.w3cschool.cn/shejimoshi/strategy-pattern.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h1&gt;&lt;p&gt;策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。&lt;/p&gt;
&lt;p&gt;意图：定</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>海量数据处理</title>
    <link href="https://leslieaibin.github.io/2021/12/19/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2021/12/19/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2021-12-18T16:15:42.000Z</published>
    <updated>2022-02-13T08:08:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="海量数据处理的问题总结"><a href="#海量数据处理的问题总结" class="headerlink" title="海量数据处理的问题总结"></a>海量数据处理的问题总结</h1><p>所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。</p><p>解决办法呢？针对时间，需要采用巧妙的算法配合合适的数据结构，如<code>Bloom filter</code>/<code>Hash</code>/<code>bit-map</code>/<code>堆</code>/<code>数据库</code>或<code>倒排索引</code>/<code>trie</code>树。针对空间，大而化小，分而治之（<code>hash</code>映射可以做到）。</p><p>至于所谓的单机及集群问题，单机就是处理装载数据的机器有限(只要考虑CPU、内存、硬盘间的数据交互)。而集群，机器有多台，适合分布式处理、并行计算(更多考虑节点和节点间的数据交互)。</p><h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p><h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。</p><pre><code>5,000,000,000 * 64B ≈ 5GB * 64 = 320GB</code></pre><p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用分治策略，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p>思路如下：</p><p>首先遍历文件 a，对遍历到的 URL 求<code>hash(URL) % 1000</code>，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p><p>接着遍历<code>ai (i∈[0,999])</code>，把 URL 存储到一个<code>HashSet</code>集合中。然后遍历 bi 中每个 URL，看在<code>HashSet</code>集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p><p>方法总结</p><ul><li>  分而治之，进行哈希取余；</li><li>  对每个子文件进行<code>HashSet</code>统计。</li></ul><h1 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p><h2 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h2><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用分治策略，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p><p>思路如下：</p><p>首先遍历大文件，对遍历到的每个词x，执行<code>hash(x) % 5000</code>，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p><p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用<code>HashMap</code>来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 map.put(x, 1)；若存在，则执行<code>map.put(x, map.get(x) + 1)</code>，将该词频数加 1。</p><p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个小顶堆来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个小顶堆，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为小顶堆，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p><h2 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h2><ul><li>  分而治之，进行哈希取余；</li><li>  使用<code>HashMap</code>统计频数；</li><li>  求解最大的<code>TopN</code>个，用小顶堆；求解最小的<code>TopN</code>个，用大顶堆。</li></ul><h1 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。</p><h2 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h2><p>这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用<code>HashMap</code>统计重复 IP 的次数，最后计算出重复次数最多的 IP。</p><p>注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。</p><h2 id="方法总结-1"><a href="#方法总结-1" class="headerlink" title="方法总结"></a>方法总结</h2><ul><li>  分而治之，进行哈希取余；</li><li>  使用<code>HashMap</code>统计频数；</li><li>  求解最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。</li></ul><h1 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p><h2 id="解答思路-3"><a href="#解答思路-3" class="headerlink" title="解答思路"></a>解答思路</h2><h3 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h3><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用<code>HashSet</code>/<code>HashMap</code>找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p><h3 id="方法二：位图法"><a href="#方法二：位图法" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h3><p>位图，就是用一个或多个<code>bit</code>来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p><p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p><p>假设我们要对 [0,7] 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p><pre><code>0 0 0 0 0 0 0 0</code></pre><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p><pre><code>0 0 0 0 1 0 1 0</code></pre><p>依次遍历，结束后，位数组是这样的：</p><pre><code>0 1 1 0 1 1 1 0</code></pre><p>每个为 1 的位，它的下标都表示了一个数：</p><pre><code>for i in range(8):    if bits[i] == 1:        print(i)</code></pre><p>这样我们其实就已经实现了排序。</p><p>对于整数相关的算法的求解，位图法是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 2^32。</p><p>那么对于这道题，我们用 2 个 bit 来表示各个数字的状态：</p><ul><li>  00 表示这个数字没出现过；</li><li>  01 表示这个数字出现过一次（即为题目所找的不重复整数）；</li><li>  10 表示这个数字出现了多次。</li></ul><p>那么这 2^32 个整数，总共所需内存为 2^32*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p><p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p><h2 id="方法总结-2"><a href="#方法总结-2" class="headerlink" title="方法总结"></a>方法总结</h2><p>判断数字是否重复的问题，位图法是一种非常高效的方法。</p><h1 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 40 亿个不重复的没排过序的<code>unsigned int</code>型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？</p><h2 id="解答思路-4"><a href="#解答思路-4" class="headerlink" title="解答思路"></a>解答思路</h2><h3 id="方法一：分治法-1"><a href="#方法一：分治法-1" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h3><p>依然可以用分治法解决，方法与前面类似，就不再次赘述了。</p><h3 id="方法二：位图法-1"><a href="#方法二：位图法-1" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h3><p>40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b ≈ 512M。</p><p>我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。</p><h2 id="方法总结-3"><a href="#方法总结-3" class="headerlink" title="方法总结"></a>方法总结</h2><p>判断数字是否存在、判断数字是否重复的问题，位图法是一种非常高效的方法。</p><h1 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询床的长度不超过 255 字节。</p><p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p><h2 id="解答思路-5"><a href="#解答思路-5" class="headerlink" title="解答思路"></a>解答思路</h2><p>每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。</p><h3 id="方法一：分治法-2"><a href="#方法一：分治法-2" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h3><p>分治法依然是一个非常实用的方法。</p><p>划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。</p><p>方法可行，但不是最好，下面介绍其他方法。</p><h3 id="方法二：HashMap-法"><a href="#方法二：HashMap-法" class="headerlink" title="方法二：HashMap 法"></a>方法二：HashMap 法</h3><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个<code>HashMap</code>中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。</p><p>思路如下：</p><p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 O(N)。</p><p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p><p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 O(Nlog10)。</p><h3 id="方法三：前缀树法"><a href="#方法三：前缀树法" class="headerlink" title="方法三：前缀树法"></a>方法三：前缀树法</h3><p>方法二使用了<code>HashMap</code>来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p><p>思路如下：</p><p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p><p>最后依然使用小顶堆来对字符串的出现次数进行排序。</p><h2 id="方法总结-4"><a href="#方法总结-4" class="headerlink" title="方法总结"></a>方法总结</h2><p>前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。</p><h1 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。</p><h2 id="解答思路-6"><a href="#解答思路-6" class="headerlink" title="解答思路"></a>解答思路</h2><p>这道题本质还是求解数据重复的问题，对于这类问题，一般首先考虑位图法。</p><p>对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。</p><p>思路如下：</p><p>申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。</p><h2 id="方法总结-5"><a href="#方法总结-5" class="headerlink" title="方法总结"></a>方法总结</h2><p>求解数据重复问题，记得考虑位图法。</p><h1 id="题目8"><a href="#题目8" class="headerlink" title="题目8"></a>题目8</h1><p>题目描述 从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 (N+1)/2 个数；当样本数为偶数时，中位数为 第 N/2 个数与第 1+N/2 个数的均值。</p><h2 id="解答思路-7"><a href="#解答思路-7" class="headerlink" title="解答思路"></a>解答思路</h2><p>如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 O(NlogN)。这里使用其他方法。</p><h3 id="方法一：双堆法"><a href="#方法一：双堆法" class="headerlink" title="方法一：双堆法"></a>方法一：双堆法</h3><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。</p><p>若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。</p><p>以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法适用于数据量较小的情况。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。</p><h3 id="方法二：分治法"><a href="#方法二：分治法" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h3><p>分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。</p><p>对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。</p><p>划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。</p><p>提示，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。 对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。</p><p>注意，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。</p><h2 id="方法总结-6"><a href="#方法总结-6" class="headerlink" title="方法总结"></a>方法总结</h2><p>分治法，真香！</p><h1 id="题目9"><a href="#题目9" class="headerlink" title="题目9"></a>题目9</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。</p><h2 id="解答思路-8"><a href="#解答思路-8" class="headerlink" title="解答思路"></a>解答思路</h2><p>如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。</p><h3 id="方法一：HashMap法"><a href="#方法一：HashMap法" class="headerlink" title="方法一：HashMap法"></a>方法一：<code>HashMap</code>法</h3><p>如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的<code>HashMap</code>中。接着就可以按照 query 出现的次数进行排序。</p><h3 id="方法二：分治法-1"><a href="#方法二：分治法-1" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h3><p>分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 hash(query) % 10 把这些 query 划分到 10 个小文件中。之后对每个小文件使用<code>HashMap</code>统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。</p><p>接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。</p><h2 id="方法总结-7"><a href="#方法总结-7" class="headerlink" title="方法总结"></a>方法总结</h2><ul><li>  内存若够，直接读入进行排序；</li><li>  内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。</li></ul><h1 id="题目10"><a href="#题目10" class="headerlink" title="题目10"></a>题目10</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？</p><h2 id="解答思路-9"><a href="#解答思路-9" class="headerlink" title="解答思路"></a>解答思路</h2><p>对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：</p><p>首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。</p><p>接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。</p><p>重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。</p><p>为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。</p><h2 id="方法总结-8"><a href="#方法总结-8" class="headerlink" title="方法总结"></a>方法总结</h2><p>求 TopK，不妨考虑一下堆排序？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;海量数据处理的问题总结&quot;&gt;&lt;a href=&quot;#海量数据处理的问题总结&quot; class=&quot;headerlink&quot; title=&quot;海量数据处理的问题总结&quot;&gt;&lt;/a&gt;海量数据处理的问题总结&lt;/h1&gt;&lt;p&gt;所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>定位问题</title>
    <link href="https://leslieaibin.github.io/2021/12/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://leslieaibin.github.io/2021/12/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-17T16:15:42.000Z</published>
    <updated>2022-02-13T08:24:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定位问题的先决条件"><a href="#定位问题的先决条件" class="headerlink" title="定位问题的先决条件"></a>定位问题的先决条件</h3><p>需要有详细的日志记录，提前告警的监控平台，事发现场保留</p><blockquote><p>日志 ：业务日志，中间件日志<br>监控 ：CPU、内存、磁盘、网络，类加载、GC、线程等<br>快照 ：-XX:+HeapDumpOnOutOfMemoryError 和 -XX:HeapDumpPath</p></blockquote><h3 id="分析问题，解决问题的思路"><a href="#分析问题，解决问题的思路" class="headerlink" title="分析问题，解决问题的思路"></a>分析问题，解决问题的思路</h3><blockquote><p>经验+直觉，快速定位 &gt; 逐一排查，传输链路 &gt; 寻找规律 不要轻易怀疑监控。考虑资源。优先保证系统能正常运行。保留现场，事后排查定位问题。</p></blockquote><blockquote><p>逐一排查，传输链路，通过日志或工具逐一排查</p><ol><li>内部原因，是否是客户端或者前端问题，程序发布后的Bug，回滚后可以立即解决</li><li>外部原因，比如服务，第三方服务，主机、组件的问题。<ol><li>服务：错误日志邮件提醒或elk快速定位问题，查看gc日志</li><li>第三方服务：单独调用测试，联系第三方加急解决</li><li>主机： CPU相关问题，可以使用 top、vmstat、pidstat、ps 等工具排查； 内存相关问题，可以使用 free、top、ps、vmstat、cachestat、sar 等工具排查；IO 相关问题，可以使用 lsof、iostat、pidstat、sar、iotop、df、du 等工具排查；网络相关问题，可以使用 ifconfig、ip、nslookup、dig、ping、tcpdump、iptables等工具排查。</li><li>组件：查看日志输出，使用命令查看运行情况</li></ol></li><li>因为系统资源不够造成系统假死的问题，通常需要先通过重启和扩容解决问题，之后再进行分析，系统资源不够，一般体现在 CPU 使用高、 内存泄漏或OOM 的问题、IO问题、网络相关问题这四个方面</li></ol></blockquote><h3 id="分析问题的方法"><a href="#分析问题的方法" class="headerlink" title="分析问题的方法"></a>分析问题的方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jps -v 查看java进程</span><br><span class="line">jinfo -flags pid 查看运行参数</span><br><span class="line">jstat -gc 8544 5000 100，将每隔5s采样一次pid为8544的gc，输出100次</span><br><span class="line"></span><br><span class="line">jmap -dump:live,format=b,file=dump.hprof 29170 </span><br><span class="line"><span class="meta">#</span><span class="bash">生成虚拟机的内存转储快照 注意线上可能会触发线上gc</span></span><br><span class="line">jmap -heap 29170</span><br><span class="line">jmap -histo:live 29170 | more</span><br><span class="line">jmap -permstat 29170</span><br><span class="line"></span><br><span class="line">jstack -l 29170 |more 显示虚拟机的线程快照</span><br><span class="line"></span><br><span class="line">df -h # 磁盘 </span><br><span class="line">free -m / -h # 内存</span><br><span class="line">top cpu  # cpu          </span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="线上cpu100-报警（找出最耗时CPU进程-线程-堆栈-代码）"><a href="#线上cpu100-报警（找出最耗时CPU进程-线程-堆栈-代码）" class="headerlink" title="线上cpu100%报警（找出最耗时CPU进程-线程-堆栈-代码）"></a>线上cpu100%报警（找出最耗时CPU进程-线程-堆栈-代码）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">方法1：原生工具，慢</span><br><span class="line">top -c #显示完整信息  P：cpu使用排序 M：内存使用排序</span><br><span class="line">top -Hp 10765 ，#显示一个进程的线程运行信息列表  -H 显示线程信息，-p指定pid &amp; P</span><br><span class="line">printf &quot;%x\n&quot; 10804    转16进制   2f71</span><br><span class="line">jstack 12084 | grep &#x27;0x2f71&#x27; -C5 --color 查看堆栈，找到线程在干嘛</span><br><span class="line"></span><br><span class="line">方法2：</span><br><span class="line">使用提前准备好的sh脚本，可以一条命名查看当前出事的线程代码，快，推荐</span><br><span class="line">sh show-busy-java-threads.sh &gt; a.txt #查询java耗时线程前5个</span><br><span class="line">sh show-busy-java-threads.sh -p &gt; a.txt #查询指定进程</span><br><span class="line"></span><br><span class="line">方法3：</span><br><span class="line">使用arthas，工具内置很多功能，比如可以查看源码，判断是否发布成功，可以用来排查疑难问题</span><br><span class="line">curl -O https://alibaba.github.io/arthas/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br><span class="line">dashboard</span><br><span class="line">thread -8</span><br><span class="line">jad com.xx.xx.xx.xxximp 查看线上类代码</span><br><span class="line">watch com.xx.xx.xx.xxximp doTask &#x27;&#123;params&#125;&#x27; &#x27;#cost&gt;100&#x27; -x 2 </span><br><span class="line"><span class="meta">#</span><span class="bash">观察会慢在什么入参上，监控耗时超过100毫秒的 doTask方法的入参，并且输出入参，展开2层入参参数</span></span><br><span class="line">ognl #查询某静态字段的值</span><br><span class="line"></span><br><span class="line">定位到堆栈就可以定位到出问题代码的行号，然后找对应的发布分支代码该行号即可</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="线上内存OOM"><a href="#线上内存OOM" class="headerlink" title="线上内存OOM"></a>线上内存OOM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">某Java服务（假设PID&#x3D;12084）出现了OOM，最常见的原因为：</span><br><span class="line">1. 有可能是内存分配确实过小，而正常业务使用了大量内存</span><br><span class="line">2. 某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽未调用close()，dispose()释放资源，例如：文件io，网络io</span><br><span class="line">3. 某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程（没有用线程池），不断发起网络连接等</span><br><span class="line">总结：本身资源不够，申请资源太多，资源耗尽</span><br><span class="line"></span><br><span class="line">分析工具：</span><br><span class="line">jvisualvm（直方图），MAT（优先，直方图，跟踪内存使用的引用关系），JProfiler</span><br><span class="line"></span><br><span class="line">线下分析：</span><br><span class="line">服务挂掉之后有保留文件：直接下载dump文件导入mat分析</span><br><span class="line">java -jar -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;</span><br><span class="line"></span><br><span class="line">线上分析：</span><br><span class="line">1. 确认是不是内存本身就分配过小</span><br><span class="line">jmap -heap 12084</span><br><span class="line"></span><br><span class="line">2. 找到最耗内存的对象</span><br><span class="line">jmap -histo:live 12084 | head -n 10  #该命令会强制执行一次fgc</span><br><span class="line"></span><br><span class="line">jmap -dump:format&#x3D;b,file&#x3D;&#x2F;opt&#x2F;dump.hprof &#123;pid&#125; #以二进制输出档当前内存的堆情况，</span><br><span class="line">然后可以导入MAT等工具进行</span><br><span class="line">tar –czf dump.tar.gz dump.hprof</span><br><span class="line"></span><br><span class="line">3. 确认进程创建的线程数，以及网络连接数，如果资源耗尽，也可能出现OOM</span><br><span class="line">ll &#x2F;proc&#x2F;17306&#x2F;fd | wc -l</span><br><span class="line">ll &#x2F;proc&#x2F;17306&#x2F;task | wc -l</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="如何防止线上问题发生"><a href="#如何防止线上问题发生" class="headerlink" title="如何防止线上问题发生"></a>如何防止线上问题发生</h3><blockquote><p>数据库：上线一个定时监控和杀掉慢SQL的脚本。这个脚本每分钟执行一次，检测上一分钟内，有没有执行时间超过一分钟（这个阈值可以根据实际情况调整）的慢SQL，如果有大事务自己觉得该阈值的合理性，如果发现，直接杀掉这个会话</p></blockquote><blockquote><p>cpu或者内存的使用率上做报警，大于90%的时候可以dump和jstack一次，甚至jstat也可以做，然后95%的时候也同样执行一次，甚至98或者99的时候也可以做一次，这样不仅可以保留现场，同时还可以对比</p></blockquote><blockquote><p>完善的服务报错日志监控，可选elfk+日志监控或sentry</p></blockquote><blockquote><p>完善的流程机制。完善的主机，中间件监控报警机制</p></blockquote><h3 id="遇到过的线上问题以及解决思路"><a href="#遇到过的线上问题以及解决思路" class="headerlink" title="遇到过的线上问题以及解决思路"></a>遇到过的线上问题以及解决思路</h3><blockquote><p><a href="https://link.juejin.cn/?target=https://chenyongjun.vip/articles/76">Zuul 网关不响应任何请求，zuul假死</a></p></blockquote><blockquote><p>App打不开，请求超时，访问数据库超时，数据库cpu飙升有规律，在某个时间点才飙升，去调度中心找该时间断的的定时任务，排查是异步转账开多了线程导致的</p></blockquote><h3 id="工具汇总"><a href="#工具汇总" class="headerlink" title="工具汇总"></a>工具汇总</h3><ul><li>去哪儿bistour</li><li>mat 分析堆快照</li><li>arthas <a href="https://link.juejin.cn/?target=https://arthas.aliyun.com/doc/quick-start.html">arthas.aliyun.com/doc/quick-s…</a></li><li><a href="https://link.juejin.cn/?target=https://gceasy.io">gceasy.io</a> #在线gc日志，dump文件分析</li><li><a href="https://link.juejin.cn/?target=https://fastthread.io">fastthread.io</a> #在线gc日志，dump文件分析</li><li><a href="https://link.juejin.cn/?target=https://console.perfma.com">console.perfma.com</a> #在线生成jvm参数</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://link.juejin.cn/?target=https://www.bbsmax.com/A/6pdD7b2X5w/">www.bbsmax.com/A/6pdD7b2X5…</a></li><li><a href="https://link.juejin.cn/?target=https://cloud.tencent.com/developer/article/1600345">cloud.tencent.com/developer/a…</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定位问题的先决条件&quot;&gt;&lt;a href=&quot;#定位问题的先决条件&quot; class=&quot;headerlink&quot; title=&quot;定位问题的先决条件&quot;&gt;&lt;/a&gt;定位问题的先决条件&lt;/h3&gt;&lt;p&gt;需要有详细的日志记录，提前告警的监控平台，事发现场保留&lt;/p&gt;
&lt;blockquot</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>bitMap讲解</title>
    <link href="https://leslieaibin.github.io/2021/12/14/java%E5%9F%BA%E7%A1%80/bitMap%E8%AE%B2%E8%A7%A3/"/>
    <id>https://leslieaibin.github.io/2021/12/14/java%E5%9F%BA%E7%A1%80/bitMap%E8%AE%B2%E8%A7%A3/</id>
    <published>2021-12-14T01:15:42.000Z</published>
    <updated>2021-12-14T14:59:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><ol><li>在实际项目中，我们经常需要聚合统计，比如统计一个年龄在20-30，喜欢看技术书籍，喜欢听音乐，喜欢宅在家的程序员等等一系列标签的用户。 如果使用mysql求并集，首先语句随着标签变长而变长，其次聚合，分组，去重严重影响语句性能。这种情况如何解决？</li><li>比如现在比较火的面试题，在10亿整数中找出100个重复的数，或者任意给定一个整数，判断是否在这个10亿数中。</li></ol><h3 id="bitMap原理"><a href="#bitMap原理" class="headerlink" title="bitMap原理"></a>bitMap原理</h3><p>bitMap就是使用bit位来标记元素，key为该元素，value一般为0或者1，大大节省存储空间.</p><p>现在有(2, 3, 4, 5，7)5个数，任意给定一个在0-7范围内的数字，判断是否在此集合中：</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20211214225035132.png" alt="image-20211214225035132"></p><ul><li><p>创建一个范围为(0-7)的Byte类型数组，将集合数字对应数组的bit位置置1；</p></li><li><p>然后遍历该Byte数组，如果Byte数组位置为1即代表该数存在。</p></li><li><p>同理对于10亿整数也可以这样处理，一个int型数字4个字节，32bit，如果使用bit标记正整数，就可以节省32倍的内存空间。</p></li><li><p>10亿数字，40亿字节，320亿bit，需要大约4g内存，使用bitMap标记，只需要125M内存空间即可存储，大大节省内存空间。</p></li></ul><p>以上和桶排序排序的思想非常相似。</p><h3 id="bitMap实际运用"><a href="#bitMap实际运用" class="headerlink" title="bitMap实际运用"></a>bitMap实际运用</h3><p>对于1千万数据，判断任意给定的数是否在其中？<br> 分治思想<br> 使用int数组作为bitMap。<br> 将数组分成32组，每组内有(0-31)个位置，如果给定数组在指定数组中的bit是0，则不存在。</p><ol><li>求十进制数在对应数组a中的下标<br> a[i] = a[N/32]</li><li>求int[]中bit位置<br> index = a[i] % 32</li></ol><p>上述两个运算可以改成位运算，因为位运算的效率非常高，占用cpu的时钟周期非常少。<br> 结论：对于2的倍数，%2^n = &amp;(2^n-1),模运算等于与预算，例：a % 16 = a &amp; 15,这里的15做与运算时需要化成16进制，即0x0F.</p><p>在10000000个范围为[1-100000]数中，给定指定一个数，判断是否在这个集合中</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMapActual</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1千万数据集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bitmap数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[N/<span class="number">32</span> + <span class="number">1</span>]; <span class="comment">//int 等于32个bit 所以数据长度为(N/32+1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为集合数据加标记</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addValue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定位数组编号 相当于n/32</span></span><br><span class="line">        <span class="keyword">int</span> row = n &gt;&gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定位数组内slot位置 相当于n%32</span></span><br><span class="line">        <span class="keyword">int</span> offset = n &amp; <span class="number">0x1F</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组slot置1</span></span><br><span class="line">        a[row] |= <span class="number">1</span> &lt;&lt; offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断给定数字是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定位数组编号</span></span><br><span class="line">        <span class="keyword">int</span> row = n &gt;&gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定位数组内slot位置</span></span><br><span class="line">        <span class="keyword">int</span> offset = n &amp; <span class="number">0x1F</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 &lt;&lt; position 将a[i]中左移position求与,slot位置有值返回true</span></span><br><span class="line">        <span class="keyword">return</span> (a[row] &amp; ( <span class="number">1</span> &lt;&lt; offset)) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一个长度为N的数组</span></span><br><span class="line">        <span class="keyword">int</span> num[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//随机数范围是(0-100000)</span></span><br><span class="line">            <span class="keyword">int</span> item = random.nextInt(<span class="number">100000</span>);</span><br><span class="line">            num[i] = item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BitMapActual map = <span class="keyword">new</span> BitMapActual();</span><br><span class="line">        <span class="comment">//置1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            map.addValue(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.exits(temp))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;temp:&quot;</span> + temp + <span class="string">&quot;has already exists&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;temp:&quot;</span> + temp + <span class="string">&quot;has no exists&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;小知识&quot;&gt;&lt;a href=&quot;#小知识&quot; class=&quot;headerlink&quot; title=&quot;小知识&quot;&gt;&lt;/a&gt;小知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在实际项目中，我们经常需要聚合统计，比如统计一个年龄在20-30，喜欢看技术书籍，喜欢听音乐，喜欢宅在家的程序员等等一系</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>反射机制</title>
    <link href="https://leslieaibin.github.io/2021/12/12/java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/"/>
    <id>https://leslieaibin.github.io/2021/12/12/java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/</id>
    <published>2021-12-12T01:15:42.000Z</published>
    <updated>2022-02-14T08:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC框架手撕之路—java反射以及动态代理机制"><a href="#RPC框架手撕之路—java反射以及动态代理机制" class="headerlink" title="RPC框架手撕之路—java反射以及动态代理机制"></a>RPC框架手撕之路—java反射以及动态代理机制</h1><p>在上一篇文章中，我们提到了，RPC框架所需要的java基础，第一点就是java的动态代理机制，动态代理机制的基础是反射，无论是在实际编程或者是面试时，都是java知识的重中之重。</p><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>在运行状态中，对于任意一个类，都能够知道这一个类的所有属性和方法，对于任意一个对象都能够通过反射机制调用一个类的任意方法，这种动态获取类信息以及动态调用类方法的功能称为java的反射机制。</p><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>1、动态的创建类的实例，将类绑定到现有对象中，或从现有对象中获取类型。 2、应用程序需要在运行时从某个特定的程序集中载入一个特定的类。</p><p>个人理解的反射机制就是，某些类在程序运行的一开始并没有加载，但是随着程序的运行，我们发现这些类也需要用到，此时就可以通过反射机制，来获取到类的属性和方法。</p><h2 id="代理模式："><a href="#代理模式：" class="headerlink" title="代理模式："></a>代理模式：</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>委托模式，是为某个对象提供一个代理对象，并且由代理对象控制对原对象的访问。代理模式通俗来讲就是我们生活中常见的中介。代理模式可以提供非常好的访问控制，应用比较广泛。</p><p>而其中的代理模式中的动态代理不仅在rpc远程访问中有重要的应用，同样在Spring AOP和其他应用中也起到了很重要的作用。</p><p>代理模式的通用类图：</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-hello-world.oss-cn-beijing.aliyuncs.com/imgs/173d2f9e1a2f5a8f6d0010cb64a7677c.png"></p><p><strong>Subject：</strong> 抽象主题角色：可以是抽象类，也可以是接口。抽象主题是一个普通的业务类型，无特殊要求。</p><p><strong>RealSubject：</strong> 具体主题角色：也叫做被委托角色或被代理角色，是业务逻辑的具体执行者。</p><p><strong>Proxy：</strong> 代理主题角色：也叫做委托类或代理类。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后处理工作。</p><p>按照代理创建的时期来进行分类，可以分为动态代理和静态代理。</p><h3 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h3><p>一个代理类只能实现一种抽象主题角色，在程序运行之前，代理类.class文件就已经被创建，代理类和委托类的关系在运行前就确定。</p><h3 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h3><p>一个代理类通过反射机制，可以实现多种不类型的抽象主题角色。动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。以下为动态代理概括图： <img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-hello-world.oss-cn-beijing.aliyuncs.com/imgs/cb919ba78df42f8a74cbc96a317ed2d1.png"></p><p>实现代码块如下：</p><p><strong>抽象角色类实现</strong>(动态代理的抽象决策类只能使用接口)：</p><pre><code>public interface Subject &#123;    /**     * 接口方法，抽象主题类     */    public void request();&#125;</code></pre><p><strong>具体决策类实现：</strong></p><pre><code>public class ConcreteSubject implements Subject&#123;    /**     * 具体业务实现逻辑     */    @Override    public void request() &#123;        //业务处理逻辑        System.out.println(&quot;逻辑执行&quot;);    &#125;&#125;</code></pre><p><strong>动态创建代理对象的类</strong>(代理类，使用反射机制):</p><pre><code>import lombok.extern.slf4j.Slf4j;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;</code></pre><p>​<br>    public class ProxyHandler implements InvocationHandler {<br>        /**<br>         *<br>         * @param proxy<br>         * @param method<br>         * @param args<br>         * @return<br>         * @throws Throwable<br>         */</p><pre><code>    /**     *目标对象     */    private Object target;    /**     */    public Object newProxyInstance(Object target)&#123;       this.target = target;       Object result = Proxy.newProxyInstance(target.getClass().getClassLoader(),               target.getClass().getInterfaces(),this);       return result;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        //TODO原对象方法调用添加的预处理逻辑        Object ret = null;        try&#123;            //调用目标方法            ret = method.invoke(target, args);        &#125;catch (Exception e)&#123;            //log(&quot;调用&#123;&#125;.&#123;&#125;发生异常&quot;, target.getClass().getName(), method.getName(), e);            throw e;        &#125;        return ret;    &#125;&#125;</code></pre><p><strong>客户端类</strong>：</p><pre><code>import lombok.extern.slf4j.Slf4j;import java.util.logging.Logger;</code></pre><p>​<br>    public class Client {<br>        public static void main(String[] args){<br>            System.out.println(“开始”);<br>            ProxyHandler handler = new ProxyHandler();<br>            Subject subject = (Subject) handler.newProxyInstance(new ConcreteSubject());<br>            subject.request();<br>            System.out.println(“结束”);<br>        }<br>    }</p><p>运行结果： <img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-hello-world.oss-cn-beijing.aliyuncs.com/imgs/943b059667471fd616a3c403f1f574b0.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RPC框架手撕之路—java反射以及动态代理机制&quot;&gt;&lt;a href=&quot;#RPC框架手撕之路—java反射以及动态代理机制&quot; class=&quot;headerlink&quot; title=&quot;RPC框架手撕之路—java反射以及动态代理机制&quot;&gt;&lt;/a&gt;RPC框架手撕之路—java</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis缓存与数据库一致性问题</title>
    <link href="https://leslieaibin.github.io/2021/11/30/Redis/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%20Redis%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/"/>
    <id>https://leslieaibin.github.io/2021/11/30/Redis/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%20Redis%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/</id>
    <published>2021-11-30T01:15:42.000Z</published>
    <updated>2021-12-08T15:17:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做系统优化时，想到了将数据进行分级存储的思路。因为在系统中会存在一些数据，有些数据的实时性要求不高，比如一些配置信息。</p><p>基本上配置了很久才会变一次。而有一些数据实时性要求非常高，比如订单和流水的数据。所以这里根据数据要求实时性不同将数据分为三级。</p><ul><li>第1级：订单数据和支付流水数据；这两块数据对实时性和精确性要求很高，所以不添加任何缓存，读写操作将直接操作数据库。</li><li>第2级：用户相关数据；这些数据和用户相关，具有读多写少的特征，所以我们使用redis进行缓存。</li><li>第3级：支付配置信息；这些数据和用户无关，具有数据量小，频繁读，几乎不修改的特征，所以我们使用本地内存进行缓存。</li></ul><p>但是只要使用到缓存，无论是本地内存做缓存还是使用 redis 做缓存，那么就会存在数据同步的问题，因为配置信息缓存在内存中，而内存时无法感知到数据在数据库的修改。这样就会造成数据库中的数据与缓存中数据不一致的问题。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>那么我们这里列出来所有策略，并且讨论他们优劣性。</p><ul><li><p>先更新数据库，后更新缓存</p></li><li><p>先更新数据库，后删除缓存</p></li><li><p>先更新缓存，后更新数据库</p></li><li><p>先删除缓存，后更新数据库</p></li></ul><h4 id="先更新数据库，后更新缓存"><a href="#先更新数据库，后更新缓存" class="headerlink" title="先更新数据库，后更新缓存"></a>先更新数据库，后更新缓存</h4><p>这种场景一般是没有人使用的，主要原因是在更新缓存那一步，为什么呢？因为有的业务需求缓存中存在的值并不是直接从数据库中查出来的，有的是需要经过一系列计算来的缓存值，那么这时候后你要更新缓存的话其实代价是很高的。如果此时有大量的对数据库进行写数据的请求，但是读请求并不多，那么此时如果每次写请求都更新一下缓存，那么性能损耗是非常大的。</p><p>举个例子比如在数据库中有一个值为 1 的值，此时我们有 10 个请求对其每次加一的操作，但是这期间并没有读操作进来，如果用了先更新数据库的办法，那么此时就会有十个请求对缓存进行更新，会有大量的冷数据产生，如果我们不更新缓存而是删除缓存，那么在有读请求来的时候那么就会只更新缓存一次。</p><h4 id="先更新缓存，后更新数据库"><a href="#先更新缓存，后更新数据库" class="headerlink" title="先更新缓存，后更新数据库"></a>先更新缓存，后更新数据库</h4><p>这一种情况应该不需要我们考虑了吧，和第一种情况是一样的。</p><h4 id="先删除缓存，后更新数据库"><a href="#先删除缓存，后更新数据库" class="headerlink" title="先删除缓存，后更新数据库"></a>先删除缓存，后更新数据库</h4><p>该方案也会出问题，具体出现的原因如下。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078252.png" alt="先删除缓存，后更新数据库"></p><p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p><ol><li>请求 A 会先删除 Redis 中的数据，然后去数据库进行更新操作</li><li>此时请求 B 看到 Redis 中的数据时空的，会去数据库中查询该值，补录到 Redis 中</li><li>但是此时请求 A 并没有更新成功，或者事务还未提交</li></ol><p>那么这时候就会产生数据库和 Redis 数据不一致的问题。如何解决呢？其实最简单的解决办法就是延时双删的策略。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078256.png" alt="延时双删"></p><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。具体步骤是：</p><ul><li>先删除缓存</li><li>再写数据库</li><li>休眠500毫秒（根据具体的业务时间来定）</li><li>再次删除缓存。</li></ul><p>但是上述的保证事务提交完以后再进行删除缓存还有一个问题，就是如果你使用的是 Mysql 的读写分离的架构的话，那么其实主从同步之间也会有时间差。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078251.png" alt="主从同步时间差"></p><p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p><ol><li>请求 A 更新操作，删除了 Redis</li><li>请求主库进行更新操作，主库与从库进行同步数据的操作</li><li>请 B 查询操作，发现 Redis 中没有数据</li><li>去从库中拿去数据</li><li>此时同步数据还未完成，拿到的数据是旧数据</li></ol><p>此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078255.png" alt="从主库中拿数据"></p><h4 id="先更新数据库，后删除缓存"><a href="#先更新数据库，后删除缓存" class="headerlink" title="先更新数据库，后删除缓存"></a>先更新数据库，后删除缓存</h4><p>问题：这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078254.png" alt="先更新数据库，后删除缓存"></p><p>此时解决方案就是利用消息队列进行删除的补偿。具体的业务逻辑用语言描述如下：</p><ol><li>请求 A 先对数据库进行更新操作</li><li>在对 Redis 进行删除操作的时候发现报错，删除失败</li><li>此时将Redis 的 key 作为消息体发送到消息队列中</li><li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</li></ol><p>但是这个方案会有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078253.png" alt="利用订阅 binlog 删除缓存"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每种方案各有利弊，比如在第三种先删除缓存，后更新数据库这个方案我们最后讨论了要更新 Redis 的时候强制走主库查询就能解决问题，那么这样的操作会对业务代码进行大量的侵入，但是不需要增加的系统，不需要增加整体的服务的复杂度。</p><p>最后一种方案我们最后讨论了利用订阅 binlog 日志进行搭建独立系统操作 Redis，这样的缺点其实就是增加了系统复杂度。其实每一次的选择都需要我们对于我们的业务进行评估来选择，没有一种技术是对于所有业务都通用的。没有最好的，只有最适合我们的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在做系统优化时，想到了将数据进行分级存储的思路。因为在系统中会存在一些数据，有些数据的实时性要求不高，比如一些配置信息。&lt;/p&gt;
&lt;p&gt;基本上配置了很久才会变一次。而有一些数据实时性要求非常高，比如订单和流水的数据。所以这里根据数据要求实时性不同将数据分为三级。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>超卖问题</title>
    <link href="https://leslieaibin.github.io/2021/11/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E8%B6%85%E5%8D%96%E8%AE%A8%E8%AE%BA/"/>
    <id>https://leslieaibin.github.io/2021/11/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E8%B6%85%E5%8D%96%E8%AE%A8%E8%AE%BA/</id>
    <published>2021-11-17T16:15:42.000Z</published>
    <updated>2022-02-12T12:29:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见写法安全性及效率分析"><a href="#常见写法安全性及效率分析" class="headerlink" title="常见写法安全性及效率分析"></a>常见写法安全性及效率分析</h1><p>假设我们的商品表的schema是下面这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`goods`</span> (<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span><span class="string">``</span><span class="string">` `</span><span class="string">&#x27;自增id&#x27;</span><span class="string">``</span>,<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span><span class="string">``</span><span class="string">` `</span><span class="string">&#x27;&#x27;</span><span class="string">` `</span><span class="keyword">COMMENT</span><span class="string">` `</span><span class="string">&#x27;商品名称&#x27;</span><span class="string">``</span>,<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="string">`available`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span><span class="string">``</span><span class="string">` `</span><span class="string">&#x27;0&#x27;</span><span class="string">` `</span><span class="keyword">COMMENT</span><span class="string">` `</span><span class="string">&#x27;库存剩余量&#x27;</span><span class="string">``</span>,<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="string">`stock`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span><span class="string">``</span><span class="string">` `</span><span class="string">&#x27;0&#x27;</span><span class="string">` `</span><span class="keyword">COMMENT</span><span class="string">` `</span><span class="string">&#x27;总库存量&#x27;</span><span class="string">``</span>,<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">``</span><span class="string">&#x27;商品表&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="设置为字段无符号解决"><a href="#设置为字段无符号解决" class="headerlink" title="设置为字段无符号解决"></a>设置为字段无符号解决</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="keyword">select</span> available <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line">if(num &gt; 0)&#123;</span><br><span class="line">   affectRows = udpate goods <span class="keyword">set</span> available = available - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line">   if(affectRows == 1)&#123;</span><br><span class="line">       return ok ;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       return fatal ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这种做法大家的想法是我们将库存字段设置成无符号类型，这样当库存字段在sql执行时候被置为负数的时候mysql就会报错，那么affectRow就会是0或者可以捕获到这个异常，从而实现并发下的数据安全。</strong></p><h4 id="解法释义"><a href="#解法释义" class="headerlink" title="解法释义"></a>解法释义</h4><p>实际上这段代码是危险的，因为在不同版本的mysql和配置下，这段代码的表现完全不同。具体的情况会出现3种不同的结果：</p><ul><li>  代码正常运行，执行update的时候报错</li><li>  代码最终执行结果出现了 -1</li><li>  最终update操作之后，available变成了一个很大的数目</li></ul><p>为什么会出现这三种情况呢？</p><p>我想在学习开始学习计算机的时候都讲过计算机的加减法计算方法。</p><p><code>思考一下，无符号2 减去 无符号3 在计算机中的运算是什么样的？</code></p><p><code>2 - 3 = 2 + (-3)</code></p><p><code>假设我们的计算机是4位的,2的补码表示:0010,-3的补码表示为1011</code></p><p><code>那么加和的结果是</code></p><p><code>0010</code></p><p><code>1011 +</code></p><p><code>------</code></p><p><code>1111 =</code></p><p><code>1111解释为有符号数是多少呢？ -1</code></p><p><code>1111解释为无符号数是多少呢？ 15</code></p><p>所以呢？如果mysql不做任何处理的话，你的无符号数减法的结果不会报错，最终你算出来的库存还是一个非常大的值(可怕)。<br>但是幸运的是mysql 后来的版本帮你做了这件事情(具体哪个版本我也不清楚)，所以如果是mysql做了无符号检测的话，如果减出的结果是负值，会报错，这是大多数人期待的结果。-1这种情况是需要你设置一下sqlmode的，这也是会出现的情况。</p><h4 id="解法总结"><a href="#解法总结" class="headerlink" title="解法总结"></a>解法总结</h4><ul><li>  这个办法很多人用的时候没问题，那只能说明可能是机缘巧合，但是对于业务代码而言，不能靠碰运气，需要消除不确定性、缩小迁移成本。</li><li>  如果你想采用这种办法，辛苦你把你们msyql相应的版本及配置搞清楚，确定无符号在你所在的版本会出现什么结果。</li></ul><h2 id="select-for-update（感觉并不能保证原子性）"><a href="#select-for-update（感觉并不能保证原子性）" class="headerlink" title="select for update（感觉并不能保证原子性）"></a>select for update（感觉并不能保证原子性）</h2><h4 id="解法释义-1"><a href="#解法释义-1" class="headerlink" title="解法释义"></a>解法释义</h4><p>读取时候就开始加排他锁也是网上常见的办法之一，具体实现如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran ;</span><br><span class="line">num = <span class="keyword">select</span> avaliable <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xxx <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">if (num &gt;= 0)&#123;</span><br><span class="line">   affectNum = udpate goods <span class="keyword">set</span> available = available - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line">   <span class="keyword">commit</span> ;</span><br><span class="line"> return affectNum ;</span><br><span class="line">&#125;else&#123;</span><br><span class="line"> <span class="keyword">rollback</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该解法在用户读取的时候对相应的数据加排他锁，保证自己在更新的时候该行的数据不会被别的进程更改.所有写请求及排他锁加锁都会被阻塞。</p><p>想想这样的情况，A进程执行过程中，出现死机的情况导致commit/rollback请求没有被发送到mysqlserver，那么所有请求都会锁等待。</p><h4 id="解法总结-1"><a href="#解法总结-1" class="headerlink" title="解法总结"></a>解法总结</h4><ul><li><p>  低流量可以采用这种办法来保证数据的安全性</p></li><li><p>性能低下，平均需要发送4次mysql请求，同时会造成所有同类请求锁等待。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3></li><li><p>  select for udpate 需要在显式的指定在事务代码块执行，不然不会起作用。很多网友都理所当然的人为select for update直接就可以加排他锁</p></li><li><p>  排他锁的释放是在rollback/commit 动作完成才会释放，不是在update操作之后。mysql innodb执行两段锁协议，加锁阶段只加锁，解锁阶段只解锁。</p></li></ul><h2 id="采用事务，先查后写再查，确保没问题"><a href="#采用事务，先查后写再查，确保没问题" class="headerlink" title="采用事务，先查后写再查，确保没问题"></a>采用事务，先查后写再查，确保没问题</h2><h4 id="解法释义-2"><a href="#解法释义-2" class="headerlink" title="解法释义"></a>解法释义</h4><p>这时候的available设置为有符号类型，解决方案一的问题</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran ;</span><br><span class="line"></span><br><span class="line">num = <span class="keyword">select</span> available <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line"></span><br><span class="line">if(num &gt; 0)&#123;</span><br><span class="line">   //实际需要关心这里的返回值，这里不考虑</span><br><span class="line"></span><br><span class="line">   udpate goods <span class="keyword">set</span> available = available - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line"></span><br><span class="line">   num_afterupdate = <span class="keyword">select</span> available <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line"></span><br><span class="line">   if(num_afterupdate &lt; 0 )&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">rollback</span> ;</span><br><span class="line"></span><br><span class="line">   &#125;else&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">commit</span> ;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解法区分于第一种的办法在于，加了事务、available类型更改、采用了更新后确认的形式，尝试解决问题。</p><p>我们都知道数据库的事务隔离级别有4种：<br><strong>RU，RC，RR，Serializable。</strong><br>我们常见的innodb中RR模式是可以保证可重复读，意思是在同一个事务内部，多次读取的结果是一致的。那么最后一次的读取对于RR隔离级别实际上是无效的。<br>RC模式下，这个代码是可用的，每次请求可以确保自己的进程不会超发。</p><h4 id="解法总结-2"><a href="#解法总结-2" class="headerlink" title="解法总结"></a>解法总结</h4><ul><li>  RR、RC模式下结果不一致.RR下不可保证安全、RC可以。</li><li>  性能不高，一次业务请求到mysql的转化为 1 : 5。</li><li>  这种解法就像老奶奶锁门，总是不放心自己到底锁了没有，走了几步再回来看看，实际上有些时候是徒劳。</li></ul><h2 id="update语句增加available查询条件"><a href="#update语句增加available查询条件" class="headerlink" title="update语句增加available查询条件"></a>update语句增加available查询条件</h2><h4 id="解法释义-3"><a href="#解法释义-3" class="headerlink" title="解法释义"></a>解法释义</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udpate goods <span class="keyword">set</span> available = available - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = xx<span class="string">` `</span><span class="keyword">and</span><span class="string">` `</span>available - <span class="number">1</span> &gt;= <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p>大家有的另一个误区是单条语句不是事务，实际上单条sql也是一个事务。-<br>问题的关键就集中在怎么证明这句的安全性的。-<br>我们都知道update操作对于id为主键索引的情况下，是会对数据加行锁。-<br>其实update操作在mysql内部也是一个先查后改的过程，这个过程如果是原子的，那么可以保证update语句是串行的，那我们就来看一下update语句在mysql内部的执行过程。-</p><p>那么对于上面这个语句，一样遵循两段锁协议。-<br>update执行的过程，会去查询满足条件的行并加锁，这个加锁是innodb做的，那么就可以保证别的事务必须等到该事务执行完了之后才能获得锁，此时拿到最新数据。</p><h4 id="解法总结-3"><a href="#解法总结-3" class="headerlink" title="解法总结"></a>解法总结</h4><ul><li>  语句安全、效率最优（我的认知里）</li></ul><h2 id="采用设置库存而不是扣减库存"><a href="#采用设置库存而不是扣减库存" class="headerlink" title="采用设置库存而不是扣减库存"></a>采用设置库存而不是扣减库存</h2><p>这几天我把类似的文章几乎翻了一遍，唯一看到批评我的上一条做法的是我的那个做法是不具备幂等性的。</p><blockquote><ul><li>  所谓幂等性就是，同一个用户对同一连接的访问不会产生副作用。比如上一条的方案，如果记录用户的操作和扣减库存不是原子操作的话，就有可能出现的问题是，库存扣减成功了，但是用户记录失败了，那么用户重复请求，就会出现多次减库存的问题。</li></ul></blockquote><p>那么他们的解法是这样的，采用设置而不是扣减，代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num_old = <span class="keyword">select</span> available <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xx<span class="string">` `</span><span class="keyword">and</span><span class="string">` `</span>available &gt;= <span class="number">1</span> ;</span><br><span class="line">num_new = num_old - 1 ;</span><br><span class="line"><span class="keyword">update</span> goods <span class="keyword">set</span> <span class="keyword">num</span>=num_new <span class="keyword">where</span> <span class="keyword">id</span>=xx<span class="string">` `</span><span class="keyword">and</span><span class="string">` `</span><span class="keyword">num</span>=num_old ;</span><br></pre></td></tr></table></figure><p>这段代码也是安全的，采用的是乐观锁的理念来完成的操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>  上面的做法，最后两个是相对安全的，但是你的库存字段还是要设置为无符号，关于是否幂等，要看结合请求看，不是单个扣减块代码。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>  <a href="http://hedengcheng.com/?p=771">何登成的技术博客</a>mysql udpate流程学习</li><li>  <a href="http://www.10tiao.com/html/249/201706/2651960197/1.html">幂等性做法来源</a>使用设置库存代替库存扣减</li><li>  <a href="http://www.cnblogs.com/blankqdb/archive/2012/11/03/blank_qdb.html">mysql 无符号问题</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见写法安全性及效率分析&quot;&gt;&lt;a href=&quot;#常见写法安全性及效率分析&quot; class=&quot;headerlink&quot; title=&quot;常见写法安全性及效率分析&quot;&gt;&lt;/a&gt;常见写法安全性及效率分析&lt;/h1&gt;&lt;p&gt;假设我们的商品表的schema是下面这样的：&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>消息队列幂等性</title>
    <link href="https://leslieaibin.github.io/2021/11/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%8E%E6%A0%B7%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>https://leslieaibin.github.io/2021/11/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%8E%E6%A0%B7%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7/</id>
    <published>2021-11-12T01:15:42.000Z</published>
    <updated>2022-02-13T10:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ消费幂等性"><a href="#RabbitMQ消费幂等性" class="headerlink" title="RabbitMQ消费幂等性"></a>RabbitMQ消费幂等性</h2><h3 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h3><blockquote><p>幂等性，简单来说就是<strong>对于同一个系统，在同样条件下，一次请求和重复多次请求对资源的影响是一致的，就称该操作为幂等的</strong>。比如说如果有一个接口是幂等的，当传入相同条件时，其效果必须是相同的。在RabbitMQ中消费幂等就是指给消费者发送多条同样的消息，消费者只会消费其中的一条。例如，在一次购物中提交订单进行支付时，当网络延迟等其他问题造成消费者重新支付，如果没有幂等性的支持，那么会对同一订单进行两次扣款，这是非常严重的，因此有了幂等性，当对同一个订单进行多次支付时，可以确保只对同一个订单扣款一次。</p></blockquote><h3 id="RabbitMQ消费幂等性-1"><a href="#RabbitMQ消费幂等性-1" class="headerlink" title="RabbitMQ消费幂等性"></a>RabbitMQ消费幂等性</h3><p>在正常情况下，消费者在消费消息的时候，当消费完毕后，会发送一个确认ack给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。而在前面保证生产端消息可靠性投递方案1中，当生产者发送消息给RabbitMQ后，在Broker返回确认ack之前，RabbitMQ出现了宕机（数据库保存的消息状态仍然为<code>“投递中”</code>），则该消息会被定时任务抓取并重新发送；或者当在网络延迟传输中，消费者出现异常或者消费者延迟消费，会造成进行RabbitMQ重试补偿，那么此时RabbitMQ中就可能会有两条消息，会造成消费者重复消费，此时消费端就需要做幂等性校验，让消费者只消费其中一条消息。实现消费端幂等性、保证同一消息不被重复消费下面介绍一种简单的方案。</p><ul><li><p>为了保证消息不被重复消费，首先要保证每个消息是唯一的，所以可以给每一个消息携带一个唯一的id，流程如下：</p><p>  1、消费者监听到消息后获取消息的MsgId（这个MsgId是我们自定义消息的字段，是主键），先去Redis中查询这个MsgId是否存在。也可以生产者发送消息时指给消息对象设置唯一的 MessageID，只有该 MessageID 没有被消费者存入到Redis中即该消息未被消费，这样重发的消息才能在重试机制中再次被消费。</p><p>  2、如果不存在，则正常消费消息，并把消息的id存入Redis中。</p><p>  3、如果存在则丢弃或者拒绝此消息并不返回队列。</p></li><li><p>代码：</p><p>  1.消费者</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessageFromQueue1</span><span class="params">(Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SetOperations&lt;String, Object&gt; ops = redisTemplate.opsForSet();</span><br><span class="line">    <span class="comment">//获取唯一Id</span></span><br><span class="line">    String msgID = message.getMessageProperties().getHeader(</span><br><span class="line">            <span class="string">&quot;spring_returned_message_correlation&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ops.pop(msgID)!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//该订单已经完成扣款，无需再进行扣款</span></span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行扣款操作</span></span><br><span class="line">        ..</span><br><span class="line">        ..</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将对应的订单id保存到redis中         </span></span><br><span class="line">        ops.add(msgID,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回确认ack</span></span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      </span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="消息队列如何限流？"><a href="#消息队列如何限流？" class="headerlink" title="消息队列如何限流？"></a>消息队列如何限流？</h2><p>消息队列限流是指在服务器面临巨额流量时，为了进行自保，进行的一种救急措施。</p><p>因为巨大的流量代表着非常多的消息，这些消息如果多到服务器处理不过来就会造成服务器瘫痪，影响用户体验，造成不良影响。</p><p>所以要进行一次降级操作，把处理不了的流量隔绝在系统之外，避免它们打垮系统。</p><p>基本上任何一个消息队列都有限流的功能，今天我们就来看看在<code>RabbitMQ</code>之中进行限流具体应该怎么做？</p><p>RabbitMQ提供了一种<code>QOS</code>(服务质量保证)功能，即在非自动确认消息的前提下，如果一定数目的消息还未被消费确认，则不进行新消息的消费。</p><h2 id="TTL消息-队列"><a href="#TTL消息-队列" class="headerlink" title="TTL消息/队列"></a>TTL消息/队列</h2><p><code>TTL</code>是Time To Live的缩写，也就是生存时间的意思，<code>RabbitMQ</code>支持消息的过期时间，在消息发送时可以进行指定，也支持队列的过期时间，从消息入队列开始计算，只要超过了队列的超时时间配置，那么消息会自动的清除。</p><p>设置队列的话就是整个队列的消息到时都会过期，设置消息的话就是单条消息到时自动过期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TTL队列示例</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">ttlQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置3s过期</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topicQueue1&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码就是演示如何创建一个TTL队列，需要放入参数才行，队列构造中的其他参数我为了方便直接填了false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTtl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String message = <span class="string">&quot;Hello 我是作者和耳朵，欢迎关注我。&quot;</span> + LocalDateTime.now().toString();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Message content : &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置过期3s</span></span><br><span class="line">    MessageProperties props = MessagePropertiesBuilder.newInstance()</span><br><span class="line">            .setExpiration(<span class="string">&quot;3000&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.send(Producer.QUEUE_NAME,<span class="keyword">new</span> Message(message.getBytes(StandardCharsets.UTF_8),props));</span><br><span class="line">    System.out.println(<span class="string">&quot;消息发送完毕。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="DLX死信队列"><a href="#DLX死信队列" class="headerlink" title="DLX死信队列"></a>DLX死信队列</h2><p><code>DLX死信队列</code>虽然叫队列，但其实指的是<code>Exchange</code>，或者说指的<code>Exchange</code>和它所属的<code>Queue</code>，他俩一块构成了死信队列。</p><p>当一条消息：</p><ul><li>消费被拒绝（basic.reject/basic.nack）并且requeue=false</li><li>TTL过期</li><li>要进入的队列达到最大长度</li></ul><p>这三种情况，就可以判定一条消息死了，这种消息如果我们没有做处理，它就会被自动删除。</p><p>但其实我们可以在队列上加上一个参数，使当队列中发现了<code>死亡的消息</code>之后会将它自动转发到某个<code>Exchange</code>，由指定的<code>Exchange</code>来处理这些死亡的消息。</p><p>这个处理死亡消息的<code>Exchange</code>和之前我们讲述的<code>Exchange</code>没什么区别，依然可以绑定队列然后进行消息消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DLX队列示例</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">dlxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 指定消息死亡后发送到ExchangeName=&quot;dlx.exchange&quot;的交换机去</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,<span class="string">&quot;dlx.exchange&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topicQueue1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上代码，就是设置了一个队列中的消息死亡后的去处，就等于消息死亡后给它不把它删掉而是做一次转发，发到其他<code>Exchange</code>去。</p><p>那这样搞有什么用呢？这就取决于业务需求了，不过下一节会用到它，接着往下看~</p><h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2><p><code>RabbitMQ</code>的基因中没有延时队列这回事，它不能直接指定一个队列类型为延时队列，然后去延时处理，但是经过上面两节的铺垫，我们可以将TTL+DLX相结合，这就能组成一个延时队列。</p><p>设想一个场景，下完订单之后15分钟未付款我们就要将订单关闭，这就是一个很经典的演示消费的场景，如果拿<code>RabbitMQ</code>来做，我们就需要结合TTL+DLX了。</p><p>先把订单消息设置好15分钟过期时间，然后过期后队列将消息转发给我们设置好的<code>DLX-Exchange</code>，<code>DLX-Exchange</code>再将分发给它绑定的队列，我们的消费者再消费这个队列中的消息，就做到了延时十五分钟消费。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RabbitMQ消费幂等性&quot;&gt;&lt;a href=&quot;#RabbitMQ消费幂等性&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ消费幂等性&quot;&gt;&lt;/a&gt;RabbitMQ消费幂等性&lt;/h2&gt;&lt;h3 id=&quot;什么是幂等性&quot;&gt;&lt;a href=&quot;#什么是</summary>
      
    
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>消息队列问题</title>
    <link href="https://leslieaibin.github.io/2021/11/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%A4%AA%E5%A4%9A%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>https://leslieaibin.github.io/2021/11/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%A4%AA%E5%A4%9A%E6%80%8E%E4%B9%88%E5%8A%9E/</id>
    <published>2021-11-11T01:15:42.000Z</published>
    <updated>2022-02-13T02:03:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MQ-的问题"><a href="#MQ-的问题" class="headerlink" title="MQ 的问题"></a>MQ 的问题</h2><p>任何技术都会有利有弊，MQ 给整体系统架构带来很多好处，但也会付出一定的代价。</p><p>MQ 主要引入了以下问题：</p><ul><li><p><strong>系统可用性降低</strong>：引入了 MQ 后，通信需要基于 MQ 完成，如果 MQ 宕机，则服务不可用。</p></li><li><p>系统复杂度提高</p><p>使用 MQ，需要关注一些新的问题：</p><ul><li>如何保证消息没有 <strong>重复消费</strong>？</li><li>如何处理 <strong>消息丢失</strong> 的问题？</li><li>如何保证传递 <strong>消息的顺序性</strong>？</li><li>如何处理大量 <strong>消息积压</strong> 的问题？</li></ul></li><li><p><strong>一致性问题</strong>：假设系统 A 处理完直接返回成功的结果给用户，用户认为请求成功。但如果此时，系统 BCD 中只要有任意一个写库失败，那么数据就不一致了。这种情况如何处理？</p></li></ul><p>下面，我们针对以上问题来一一分析。</p><h3 id="1-重复消费"><a href="#1-重复消费" class="headerlink" title="1. 重复消费"></a>1. 重复消费</h3><p><strong>如何保证消息不被重复消费</strong> 和 <strong>如何保证消息消费的幂等性</strong> 是同一个问题。</p><p>必须先明确产生重复消费的原因，才能对症下药。</p><h4 id="重复消费问题原因"><a href="#重复消费问题原因" class="headerlink" title="重复消费问题原因"></a>重复消费问题原因</h4><p>重复消费问题通常不是 MQ 来处理，而是由开发来处理的。</p><p>以 Kafka 举例，Kafka 每个 Partition 都是一个有序的、不可变的记录序列，不断追加到结构化的提交日志中。Partition 中为每条记录分配一个连续的 id 号，称为偏移量（Offset），用于唯一标识 Partition 内的记录。</p><p>Kafka 的客户端和 Broker 都会保存 Offset。客户端消费消息后，每隔一段时间，就把已消费的 Offset 提交给 Kafka Broker，表示已消费。</p><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210427194009.png" alt="img"></p><p>在这个过程中，如果客户端应用消费消息后，因为宕机、重启等情况而没有提交已消费的 Offset 。当系统恢复后，会继续消费消息，由于 Offset 未提交，就会出现重复消费的问题。</p><h4 id="重复消费解决方案"><a href="#重复消费解决方案" class="headerlink" title="重复消费解决方案"></a>重复消费解决方案</h4><p>应对重复消费问题，需要在业务层面，通过 <strong>幂等性设计</strong> 来解决。</p><p>MQ 重复消费不可怕，可怕的是没有应对机制，可以借鉴的思路有：</p><ul><li>如果是写关系型数据库，可以先根据主键查询，判断数据是否已存在，存在则更新，不存在则插入；</li><li>如果是写 Redis，由于 set 操作天然具有幂等性，所以什么都不用做；</li><li>如果是根据消息做较复杂的逻辑处理，可以在消息中加入全局唯一 ID，例如：订单 ID 等。在客户端存储中（Mysql、Redis 等）保存已消费消息的 ID。一旦接受到新消息，先判断消息中的 ID 是否在已消费消息 ID 表中存在，存在则不再处理，不存在则处理。</li></ul><p>在实际开发中，可以参考上面的例子，结合现实场景，设计合理的幂等性方案。</p><h3 id="2-消息丢失"><a href="#2-消息丢失" class="headerlink" title="2. 消息丢失"></a>2. 消息丢失</h3><p><strong>如何处理消息丢失的问题</strong> 和 <strong>如何保证消息不被重复消费</strong> 是同一个问题。关注点有：</p><ul><li>MQ Server 丢失数据</li><li>消费方丢失数据</li><li>生产方丢失数据</li></ul><h4 id="消费方丢失数据"><a href="#消费方丢失数据" class="headerlink" title="消费方丢失数据"></a>消费方丢失数据</h4><p>唯一可能导致消费方丢失数据的情况是：消费方设置了<strong>自动提交 Offset</strong>。一旦设置了自动提交 Offset，接受到消息后就会自动提交 Offset 给 Kafka ，Kafka 就认为消息已被消费。如果此时，消费方尚未来得及处理消息就挂了，那么消息就丢了。</p><p>解决方法就是：消费方关闭自动提交 Offset，处理完消息后<strong>手动提交 Offset</strong>。但这种情况下可能会出现重复消费的情形，需要自行保证幂等性。</p><h4 id="RabbitMq弄丢了数据"><a href="#RabbitMq弄丢了数据" class="headerlink" title="RabbitMq弄丢了数据"></a><strong>RabbitMq弄丢了数据</strong></h4><p>就是 RabbitMQ 自己弄丢了数据，这个你必须<strong>开启 RabbitMQ 的持久化</strong>，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，<strong>恢复之后会自动读取之前存储的数据</strong>，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，<strong>可能导致少量数据丢失</strong>，但是这个概率较小。</p><p>设置持久化有<strong>两个步骤</strong>：</p><ul><li>创建 queue 的时候将其设置为持久化<br>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li><li>第二个是发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2<br>就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li></ul><p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p><p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p><p>所以，持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code>，你也是可以自己重发的。</p><h4 id="生产方丢失数据"><a href="#生产方丢失数据" class="headerlink" title="生产方丢失数据"></a>生产方丢失数据</h4><p>如果按照上述的思路设置了 <code>acks=all</code>，生产方一定不会丢数据。</p><p>要求是，你的 Leader 接收到消息，所有的 Follower 都同步到了消息之后，才认为本生产消息成功了。如果未满足这个条件，生产者会自动不断的重试，重试无限次。</p><h3 id="3-消息的顺序性"><a href="#3-消息的顺序性" class="headerlink" title="3. 消息的顺序性"></a>3. 消息的顺序性</h3><p>要保证 MQ 的顺序性，势必要付出一定的代价，所以实施方案前，要先明确业务场景是不是有必要保证消息的顺序性。只有那些明确对消息处理顺序有要求的业务场景才值得去保证消息顺序性。</p><p>方案一</p><p>一个 Topic，一个 Partition，一个 Consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</p><p>方案二</p><ul><li>写入数据到 Partition 时指定一个全局唯一的 ID，例如订单 ID。发送方保证相同 ID 的消息有序的发送到同一个 Partition。</li><li>基于上一点，消费方从 Kafka Partition 中消费消息时，此刻一定是顺序的。但如果消费方式以并发方式消费消息，顺序就可能会被打乱。为此，还有做到以下几点：<ul><li>消费方维护 N 个缓存队列，具有相同 ID 的数据都写入同一个队列中；</li><li>创建 N 个线程，每个线程只负责从指定的一个队列中取数据。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210427194215.png" alt="img"></p><h3 id="4-消息积压"><a href="#4-消息积压" class="headerlink" title="4. 消息积压"></a>4. 消息积压</h3><p>假设一个 MQ 消费者可以一秒处理 1000 条消息，三个 MQ 消费者可以一秒处理 3000 条消息，那么一分钟的处理量是 18 万条。如果 MQ 中积压了几百万到上千万的数据，即使消费者恢复了，也需要大概很长的时间才能恢复过来。</p><p>对于产线环境来说，漫长的等待是不可接受的，所以面临这种窘境时，只能临时紧急扩容以应对了，具体操作步骤和思路如下：</p><ul><li>先修复 Consumer 的问题，确保其恢复消费速度，然后将现有 Consumer 都停掉。</li><li>新建一个 Topic，Partition 是原来的 10 倍，临时建立好原先 10 倍的 Queue 数量。</li><li>然后写一个临时的分发数据的 Consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 Queue。</li><li>接着临时征用 10 倍的机器来部署 Consumer ，每一批 Consumer 消费一个临时 Queue 的数据。这种做法相当于是临时将 Queue 资源和 Consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li><li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MQ-的问题&quot;&gt;&lt;a href=&quot;#MQ-的问题&quot; class=&quot;headerlink&quot; title=&quot;MQ 的问题&quot;&gt;&lt;/a&gt;MQ 的问题&lt;/h2&gt;&lt;p&gt;任何技术都会有利有弊，MQ 给整体系统架构带来很多好处，但也会付出一定的代价。&lt;/p&gt;
&lt;p&gt;MQ 主要引入</summary>
      
    
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Skip List--跳表</title>
    <link href="https://leslieaibin.github.io/2021/10/30/Redis/%E8%B7%B3%E8%A1%A8/"/>
    <id>https://leslieaibin.github.io/2021/10/30/Redis/%E8%B7%B3%E8%A1%A8/</id>
    <published>2021-10-30T01:15:42.000Z</published>
    <updated>2022-02-14T02:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Skip-List–跳表"><a href="#Skip-List–跳表" class="headerlink" title="Skip List–跳表"></a>Skip List–跳表</h1><p>跳表是一种神奇的数据结构，因为几乎所有版本的大学本科教材上都没有跳表这种数据结构，而且神书《算法导论》、《算法第四版》这两本书中也没有介绍跳表。但是跳表插入、删除、查找元素的时间复杂度跟红黑树都是一样量级的，时间复杂度都是O(logn)，而且跳表有一个特性是红黑树无法匹敌的（具体什么特性后面会提到）。所以在工业中，跳表也会经常被用到。废话不多说了，开始今天的跳表学习。</p><p>通过本文，你能 get 到以下知识：</p><ul><li>  什么是跳表？</li><li>  跳表的查找、插入、删除元素的流程</li><li>  跳表查找、插入、删除元素的时间复杂度</li><li>  跳表插入元素时，如何动态维护索引？</li><li>  为什么Redis选择使用跳表而不是红黑树来实现有序集合？</li><li>  工业上其他使用跳表的场景</li></ul><blockquote><p>友情提示：下文在跳表插入数据时，会讲述如何动态维护索引，实现比较简单，逻辑比较绕，不要放弃，加油！！！如果一遍看不懂没关系，可以选择暂时性的跳过，毕竟这块偏向于源码。但是读者必须知道跳表的查找、插入、删除的时间复杂度都是 O(logn)，而且可以按照范围区间查找元素，当工作中遇到某些场景时，需要想到可以使用跳表解决问题即可。毕竟平时的工作都是直接使用封装好的跳表，例如：java.util.concurrent 下的 ConcurrentSkipListMap()。</p></blockquote><h3 id="理解跳表，从单链表开始说起"><a href="#理解跳表，从单链表开始说起" class="headerlink" title="理解跳表，从单链表开始说起"></a>理解跳表，从单链表开始说起</h3><p>下图是一个简单的<strong>有序单链表</strong>，单链表的特性就是每个元素存放下一个元素的引用。即：通过第一个元素可以找到第二个元素，通过第二个元素可以找到第三个元素，依次类推，直到找到最后一个元素。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/37027.jpg"></p><p>跳表-原始链表.jpeg</p><p>现在我们有个场景，想快速找到上图链表中的 10 这个元素，只能从头开始遍历链表，直到找到我们需要找的元素。查找路径：1、3、4、5、7、8、9、10。这样的查找效率很低，平均时间复杂度很高O(n)。那有没有办法提高链表的查找速度呢？如下图所示，我们从链表中每两个元素抽出来，加一级索引，一级索引指向了原始链表，即：通过一级索引 7 的down指针可以找到原始链表的 7 。那现在怎么查找 10 这个元素呢？</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/60225.jpg"></p><p>跳表-一级索引.jpeg</p><p>先在索引找 1、4、7、9，遍历到一级索引的 9 时，发现 9 的后继节点是 13，比 10 大，于是不往后找了，而是通过 9 找到原始链表的 9，然后再往后遍历找到了我们要找的 10，遍历结束。有没有发现，加了一级索引后，查找路径：1、4、7、9、10，查找节点需要遍历的元素相对少了，我们不需要对 10 之前的所有数据都遍历，查找的效率提升了。</p><p>那如果加二级索引呢？如下图所示，查找路径：1、7、9、10。是不是找 10 的效率更高了？这就是跳表的思想，用“空间换时间”，通过给链表建立索引，提高了查找的效率。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/23212.jpg"></p><p>跳表-二级索引.jpeg</p><p>可能同学们会想，从上面案例来看，提升的效率并不明显，本来需要遍历8个元素，优化了半天，还需要遍历 4 个元素，其实是因为我们的数据量太少了，当数据量足够大时，效率提升会很大。如下图所示，假如有序单链表现在有1万个元素，分别是 0~9999。现在我们建了很多级索引，最高级的索引，就两个元素 0、5000，次高级索引四个元素 0、2500、5000、7500，依次类推，当我们查找 7890 这个元素时，查找路径为 0、5000、7500 … 7890，通过最高级索引直接跳过了5000个元素，次高层索引直接跳过了2500个元素，<strong>从而使得链表能够实现二分查找</strong>。由此可以看出，当元素数量较多时，索引提高的效率比较大，近似于二分查找。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/65247.jpg"></p><p>数据量增多后，索引效果图.png</p><p>到这里大家应该已经明白了什么是跳表。跳表是<strong>可以实现二分查找的有序链表</strong>。</p><h3 id="查找的时间复杂度"><a href="#查找的时间复杂度" class="headerlink" title="查找的时间复杂度"></a>查找的时间复杂度</h3><p>既然跳表可以提升链表查找元素的效率，那查找一个元素的时间复杂度到底是多少呢？查找元素的过程是从最高级索引开始，一层一层遍历最后下沉到原始链表。所以，时间复杂度 = 索引的高度 * 每层索引遍历元素的个数。</p><p>先来求跳表的索引高度。如下图所示，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/2k个元素。最高级索引一般有2个元素，即：最高级索引 h 满足 2 = n/2h，即 h = log2n - 1，最高级索引 h 为索引层的高度加上原始数据一层，跳表的总高度 h = log2n。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214100936207.png" alt="image-20220214100936207"></p><p>查找的时间复杂度证明.jpeg</p><p>我们看上图中加粗的箭头，表示查找元素 x 的路径，那查找过程中每一层索引最多遍历几个元素呢？</p><p>图中所示，现在到达第 k 级索引，我们发现要查找的元素 x 比 y 大比 z 小，所以，我们需要从 y 处下降到 k-1 级索引继续查找，k-1级索引中比 y 大比 z 小的只有一个 w，所以在 k-1 级索引中，我们遍历的元素最多就是 y、w、z，发现 x 比 w大比 z 小之后，再下降到 k-2 级索引。所以，k-2 级索引最多遍历的元素为 w、u、z。其实每级索引都是类似的道理，每级索引中都是两个结点抽出一个结点作为上一级索引的结点。 现在我们得出结论：当每级索引都是两个结点抽出一个结点作为上一级索引的结点时，每一层最多遍历3个结点。</p><p>跳表的索引高度 h = log2n，且每层索引最多遍历 3 个元素。所以跳表中查找一个元素的时间复杂度为 O(3*logn)，省略常数即：O(logn)。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>跳表通过建立索引，来提高查找元素的效率，就是典型的“空间换时间”的思想，所以在空间上做了一些牺牲，那空间复杂度到底是多少呢？</p><p>假如原始链表包含 n 个元素，则一级索引元素个数为 n/2、二级索引元素个数为 n/4、三级索引元素个数为 n/8 以此类推。所以，索引节点的总和是：n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2，**空间复杂度是 O(n)**。</p><p>如下图所示：如果每三个结点抽一个结点做为索引，索引总和数就是 n/3 + n/9 + n/27 + … + 9 + 3 + 1= n/2，减少了一半。所以我们可以通过较少索引数来减少空间复杂度，但是相应的肯定会造成查找效率有一定下降，我们可以根据我们的应用场景来控制这个阈值，看我们更注重时间还是空间。</p><p>![image-20220214100955292](/Users/leslie/Library/Application Support/typora-user-images/image-20220214100955292.png)</p><p>三个节点提取一个做索引.jpeg</p><p>But，索引结点往往只需要存储 key 和几个指针，并不需要存储完整的对象，所以当对象比索引结点大很多时，索引占用的额外空间就可以忽略了。举个例子：我们现在需要用跳表来给所有学生建索引，学生有很多属性：学号、姓名、性别、身份证号、年龄、家庭住址、身高、体重等。学生的各种属性只需要在原始链表中存储一份即可，我们只需要用学生的学号（int 类型的数据）建立索引，所以索引相对原始数据而言，占用的空间可以忽略。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入数据看起来也很简单，跳表的原始链表需要保持有序，所以我们会向查找元素一样，找到元素应该插入的位置。如下图所示，要插入数据6，整个过程类似于查找6，整个的查找路径为 1、1、1、4、4、5。查找到第底层原始链表的元素 5 时，发现 5 小于 6 但是后继节点 7 大于 6，所以应该把 6 插入到 5 之后 7 之前。整个时间复杂度为查找元素的时间复杂度 O(logn)。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101012915.png" alt="image-20220214101012915"></p><p>插入数据图示.jpeg</p><p>如下图所示，假如一直往原始列表中添加数据，但是不更新索引，就可能出现两个索引节点之间数据非常多的情况，极端情况，跳表退化为单链表，从而使得查找效率从 O(logn) 退化为 O(n)。那这种问题该怎么解决呢？我们需要在插入数据的时候，索引节点也需要相应的增加、或者重建索引，来避免查找效率的退化。那我们该如何去维护这个索引呢？</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101025149.png" alt="image-20220214101025149"></p><p>插入数据，不更新索引图示.jpeg</p><p>比较容易理解的做法就是完全重建索引，我们每次插入数据后，都把这个跳表的索引删掉全部重建，重建索引的时间复杂度是多少呢？因为索引的空间复杂度是 O(n)，即：索引节点的个数是 O(n) 级别，每次完全重新建一个 O(n) 级别的索引，时间复杂度也是 O(n) 。造成的后果是：为了维护索引，导致每次插入数据的时间复杂度变成了 O(n)。</p><p>那有没有其他效率比较高的方式来维护索引呢？假如跳表每一层的晋升概率是 1/2，最理想的索引就是在原始链表中每隔一个元素抽取一个元素做为一级索引。换种说法，<strong>我们在原始链表中随机的选 n/2 个元素做为一级索引是不是也能通过索引提高查找的效率呢？</strong> 当然可以了，因为一般随机选的元素相对来说都是比较均匀的。如下图所示，随机选择了n/2 个元素做为一级索引，虽然不是每隔一个元素抽取一个，但是对于查找效率来讲，影响不大，比如我们想找元素 16，仍然可以通过一级索引，使得遍历路径较少了将近一半。如果抽取的一级索引的元素恰好是前一半的元素 1、3、4、5、7、8，那么查找效率确实没有提升，但是这样的概率太小了。我们可以认为：当原始链表中<strong>元素数量足够大</strong>，且<strong>抽取足够随机</strong>的话，我们得到的索引是均匀的。我们要清楚设计良好的数据结构都是为了应对大数据量的场景，如果原始链表只有 5 个元素，那么依次遍历 5 个元素也没有关系，因为数据量太少了。所以，我们可以维护一个这样的索引：<strong>随机选 n/2 个元素做为一级索引、随机选 n/4 个元素做为二级索引、随机选 n/8 个元素做为三级索引，依次类推，一直到最顶层索引</strong>。这里每层索引的元素个数已经确定，且每层索引元素选取的足够随机，所以可以通过索引来提升跳表的查找效率。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101046805.png" alt="image-20220214101046805"></p><p>跳表-一级索引随机分布.jpg</p><p>那代码该如何实现，才能使跳表满足上述这个样子呢？可以在每次新插入元素的时候，尽量让该元素有 1/2 的几率建立一级索引、1/4 的几率建立二级索引、1/8 的几率建立三级索引，以此类推，就能满足我们上面的条件。现在我们就需要一个概率算法帮我们把控这个 1/2、1/4、1/8 … ，<strong>当每次有数据要插入时，先通过概率算法告诉我们这个元素需要插入到几级索引中</strong>，然后开始维护索引并把数据插入到原始链表中。下面开始讲解这个概率算法代码如何实现。</p><p>我们可以实现一个 randomLevel() 方法，该方法会随机生成 1~MAX_LEVEL 之间的数（MAX_LEVEL表示索引的最高层数），且该方法<strong>有 1/2 的概率返回 1、1/4 的概率返回 2、1/8的概率返回 3，以此类推</strong>。</p><ul><li>  randomLevel() 方法返回 1 表示当前插入的该元素不需要建索引，只需要存储数据到原始链表即可（概率 1/2）</li><li>  randomLevel() 方法返回 2 表示当前插入的该元素需要建一级索引（概率 1/4）</li><li>  randomLevel() 方法返回 3 表示当前插入的该元素需要建二级索引（概率 1/8）</li><li>  randomLevel() 方法返回 4 表示当前插入的该元素需要建三级索引（概率 1/16）</li><li>  。。。以此类推</li></ul><p>所以，通过 randomLevel() 方法，我们可以控制整个跳表各级索引中元素的个数。<strong>重点来了</strong>：randomLevel() 方法返回 2 的时候会建立一级索引，我们想要一级索引中元素个数占原始数据的 1/2，但是 randomLevel() 方法返回 2 的概率为 1/4，那是不是有矛盾呢？明明说好的 1/2，结果一级索引元素个数怎么变成了原始链表的 1/4？我们先看下图，应该就明白了。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101108858.png" alt="image-20220214101108858"></p><p>插入数据图示.jpeg</p><p>假设我们在插入元素 6 的时候，randomLevel() 方法返回 1，则我们不会为 6 建立索引。插入 7 的时候，randomLevel() 方法返回3 ，所以我们需要为元素 7 建立二级索引。这里我们发现了一个特点：当建立二级索引的时候，同时也会建立一级索引；当建立三级索引时，同时也会建立一级、二级索引。所以，一级索引中元素的个数等于 <em>[ 原始链表元素个数 ]</em> * _[ randomLevel() 方法返回值 &gt; 1 的概率 ]_。因为 randomLevel() 方法返回值 &gt; 1就会建索引，凡是建索引，无论几级索引必然有一级索引，<strong>所以一级索引中元素个数占原始数据个数的比率为 randomLevel() 方法返回值 &gt; 1 的概率</strong>。那 randomLevel() 方法返回值 &gt; 1 的概率是多少呢？因为 randomLevel() 方法随机生成 1~MAX_LEVEL 的数字，且 randomLevel() 方法返回值 1 的概率为 1/2，则 randomLevel() 方法返回值 &gt; 1 的概率为 1 - 1/2 = 1/2。即<strong>通过上述流程实现了一级索引中元素个数占原始数据个数的 1/2</strong>。</p><p>同理，当 randomLevel() 方法返回值 &gt; 2 时，会建立二级或二级以上索引，都会在二级索引中增加元素，因此<strong>二级索引中元素个数占原始数据的比率为 randomLevel() 方法返回值 &gt; 2 的概率</strong>。 randomLevel() 方法返回值 &gt; 2 的概率为 1 减去 randomLevel() = 1 或 =2 的概率，即 1 - 1/2 - 1/4 = 1/4。OK，达到了我们设计的目标：<strong>二级索引中元素个数占原始数据的 1/4</strong>。</p><p>以此类推，可以得出，遵守以下两个条件：</p><ul><li>  randomLevel() 方法，随机生成 1~MAX_LEVEL 之间的数（MAX_LEVEL表示索引的最高层数），且<strong>有 1/2的概率返回 1、1/4的概率返回 2、1/8的概率返回 3 …</strong></li><li>  randomLevel() 方法返回 1 不建索引、返回2建一级索引、返回 3 建二级索引、返回 4 建三级索引 …</li></ul><p>就可以满足我们想要的结果，即：一级索引中元素个数应该占原始数据的 1/2，二级索引中元素个数占原始数据的 1/4，三级索引中元素个数占原始数据的 1/8 ，依次类推，一直到最顶层索引。</p><p>但是问题又来了，怎么设计这么一个 randomLevel() 方法呢？直接撸代码：</p><pre><code>// 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：//        1/2 的概率返回 1//        1/4 的概率返回 2//        1/8 的概率返回 3 以此类推private int randomLevel() &#123;  int level = 1;  // 当 level &lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level + 1  while (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL)    level += 1;  return level;&#125;</code></pre><p>上述代码可以实现我们的功能，而且，我们的案例中晋升概率 SKIPLIST_P 设置的 1/2，即：每两个结点抽出一个结点作为上一级索引的结点。如果我们想节省空间利用率，可以适当的降低代码中的 SKIPLIST_P，从而减少索引元素个数，Redis 的 zset 中 SKIPLIST_P 设定的 0.25。下图所示，是Redis <a href="https://links.jianshu.com/go?to=https://github.com/antirez/redis/blob/unstable/src/t_zset.c">t_zset.c</a> 中 zslRandomLevel 函数的实现：</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101129643.png" alt="image-20220214101129643"></p><p>Redis 源码中 <code>(random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF)</code> 在功能上等价于我代码中的 <code>Math.random() &lt; SKIPLIST_P</code> ，只不过 Redis 作者 <a href="https://links.jianshu.com/go?to=https://github.com/antirez">antirez</a> 使用位运算来提高浮点数比较的效率。</p><p>整体思路大家应该明白了，那插入数据时维护索引的时间复杂度是多少呢？**元素插入到单链表的时间复杂度为 O(1)**，我们索引的高度最多为 logn，当插入一个元素 x 时，最坏的情况就是元素 x 需要插入到每层索引中，所以插入数据到各层索引中，最坏时间复杂度是 O(logn)。</p><p>过程大概理解了，再通过一个例子描述一下跳表插入数据的全流程。现在我们要插入数据 6 到跳表中，首先 randomLevel() 返回 3，表示<strong>需要建二级索引</strong>，即：一级索引和二级索引需要增加元素 6。该跳表目前最高三级索引，首先找到三级索引的 1，发现 6 比 1大比 13小，所以，从 1 下沉到二级索引。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101146750.png" alt="image-20220214101146750"></p><p>下沉到二级索引后，发现 6 比 1 大比 7 小，此时需要在二级索引中 1 和 7 之间加一个元素6 ，并从元素 1 继续下沉到一级索引。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101201432.png" alt="image-20220214101201432">插入数据且维护跳表图示2.jpeg</p><p>下沉到一级索引后，发现 6 比 1 大比 4 大，所以往后查找，发现 6 比 4 大比 7 小，此时需要在一级索引中 4 和 7 之间加一个元素 6 ，并把二级索引的 6 指向 一级索引的 6，最后，从元素 4 继续下沉到原始链表。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101216693.png" alt="image-20220214101216693"></p><p>下沉到原始链表后，就比较简单了，发现 4、5 比 6小，7比6大，所以将6插入到 5 和 7 之间即可，整个插入过程结束。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101229592.png" alt="image-20220214101229592">整个插入过程的路径与查找元素路径类似， 每层索引中插入元素的时间复杂度 O(1)，所以整个插入的时间复杂度是 O(logn)。</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>跳表删除数据时，要把索引中对应节点也要删掉。如下图所示，如果要删除元素 9，需要把原始链表中的 9 和第一级索引的 9 都删除掉。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101245553.png" alt="image-20220214101245553">跳表中，删除元素的时间复杂度是多少呢？</p><p>删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素 x，则执行删除操作。跳表中，每一层索引其实都是一个有序的单链表，单链表删除元素的时间复杂度为 O(1)，索引层数为 logn 表示最多需要删除 logn 个元素，所以删除元素的总时间包含 <em>查找元素的时间</em> 加 <em>删除 logn个元素的时间</em> 为 O(logn) + O(logn) = 2 O(logn)，忽略常数部分，删除元素的时间复杂度为 O(logn)。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p> 跳表是可以实现二分查找的有序链表；</p></li><li><p> 每个元素插入时随机生成它的level；</p></li><li><p> 最底层包含所有的元素；</p></li><li><p> 如果一个元素出现在level(x)，那么它肯定出现在x以下的level中；</p></li><li><p> 每个索引节点包含两个指针，一个向下，一个向右；（笔记目前看过的各种跳表源码实现包括Redis 的zset 都没有向下的指针，那怎么从二级索引跳到一级索引呢？留个悬念，看源码吧，文末有跳表实现源码）</p></li><li><p> 跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近；</p></li></ol><h3 id="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"><a href="#为什么Redis选择使用跳表而不是红黑树来实现有序集合？" class="headerlink" title="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"></a>为什么Redis选择使用跳表而不是红黑树来实现有序集合？</h3><p>Redis 中的有序集合(zset) 支持的操作：</p><ol><li><p> 插入一个元素</p></li><li><p> 删除一个元素</p></li><li><p> 查找一个元素</p></li><li><p> 有序输出所有元素</p></li><li><p> 按照范围区间查找元素（比如查找值在 [100, 356] 之间的数据）</p></li></ol><p>其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。</p><h3 id="工业上其他使用跳表的场景"><a href="#工业上其他使用跳表的场景" class="headerlink" title="工业上其他使用跳表的场景"></a>工业上其他使用跳表的场景</h3><p>在博客上从来没有见过有同学讲述 HBase MemStore 的数据结构，其实 HBase MemStore 内部存储数据就使用的跳表。为什么呢？HBase 属于 LSM Tree 结构的数据库，LSM Tree 结构的数据库有个特点，实时写入的数据先写入到内存，内存达到阈值往磁盘 flush 的时候，会生成类似于 StoreFile 的<strong>有序文件</strong>，而跳表恰好就是天然有序的，所以在 flush 的时候效率很高，而且跳表查找、插入、删除性能都很高，这应该是 HBase MemStore 内部存储数据使用跳表的原因之一。HBase 使用的是 java.util.concurrent 下的 ConcurrentSkipListMap()。</p><p>Google 开源的 key/value 存储引擎 LevelDB 以及 Facebook 基于 LevelDB 优化的 RocksDB 都是 LSM Tree 结构的数据库，他们内部的 MemTable 都是使用了跳表这种数据结构。</p><p>后期笔者还会输出一篇深入剖析 LSM Tree 的博客，到时候再结合场景分析为什么使用跳表。</p><p>参考：</p><p><a href="https://links.jianshu.com/go?to=https://github.com/antirez/redis/blob/unstable/src/t_zset.c">Redis zset源码</a></p><p><a href="https://links.jianshu.com/go?to=https://time.geekbang.org/column/article/42896">极客时间-数据结构与算法之美课程</a></p><ul><li>  王争老师的整套课程都很棒，对数据结构与算法想整体提高的同学可以订阅</li></ul><p><a href="https://links.jianshu.com/go?to=https://github.com/wangzheng0822/algo/blob/master/java/17_skiplist/SkipList.java">王争老师SkipList 实现</a></p><ul><li>  这个跳表实现相对简单，建议初学者参考，整个项目是王争老师极客时间课程配套的代码，其他数据结构实现也可以参考</li><li>  笔记在写本博客期间，向该项目提交了 pr，已被merge，模仿 redis 源码重新实现了 randomLevel() 方法，不过为了容易理解没有使用redis的位运算，之前的 randomLevel() 方法会导致索引冗余特别严重，5 级以下的索引中元素个数接近于所有元素的个数，有兴趣的同学可以继续深入研究</li></ul><p><a href="https://links.jianshu.com/go?to=https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5ac63d5188256255299d9c">源码 5：凌波微步 —— 探索「跳跃列表」内部结构</a></p><ul><li>  老钱的《Redis 深度历险》系列非常推荐</li></ul><p><a href="https://www.jianshu.com/p/dd01e8dc4d1f">拜托，面试别再问我跳表了！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Skip-List–跳表&quot;&gt;&lt;a href=&quot;#Skip-List–跳表&quot; class=&quot;headerlink&quot; title=&quot;Skip List–跳表&quot;&gt;&lt;/a&gt;Skip List–跳表&lt;/h1&gt;&lt;p&gt;跳表是一种神奇的数据结构，因为几乎所有版本的大学本科教材上都</summary>
      
    
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>10.分库分表</title>
    <link href="https://leslieaibin.github.io/2021/10/25/MySQL/10.%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>https://leslieaibin.github.io/2021/10/25/MySQL/10.%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2021-10-25T12:17:42.000Z</published>
    <updated>2022-02-13T01:59:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要拆分数据库？"><a href="#1-为什么要拆分数据库？" class="headerlink" title="1. 为什么要拆分数据库？"></a><strong>1. 为什么要拆分数据库？</strong></h2><p>单体项目在构建之初，<a href="https://link.zhihu.com/?target=https://coding.imooc.com/class/274.html?mc_marking=b9478d5f12bd4de1a83dc61bc224d99f&mc_channel=shouji">数据库</a>的负载和数据量都不大，所以不需要对数据库做拆分，小型财务系统、文书系统、ERP系统、OA系统，用一个MySQL数据库实例基本就够用了。</p><p>就像《淘宝技术这十年》里面说到的，电商业务的数据量增长飞快，所以最开始的PHP+MySQL的架构已经不能满足实际要求了，于是淘宝想到的第一个办法就是把MySQL替换成Oracle。但是没过了多久，在08年前后，单节点的Oracle数据库也不好用了，于是淘宝终于告别了单节点数据库，开始拆分数据库。从一个节点，变成多个节点。</p><p>拆分数据库是有讲究的，比如说拆分方法有两种：垂直切分和水平切分。那你是先水平切分还是垂直切分呢？顺序无所谓？不，顺序有所为，次序绝对不能错：先水平切分，然后垂直切分。</p><h2 id="2-什么是垂直切分？"><a href="#2-什么是垂直切分？" class="headerlink" title="2. 什么是垂直切分？"></a><strong>2. 什么是垂直切分？</strong></h2><p>垂直切分是根据业务来拆分数据库，同一类业务的数据表拆分到一个独立的数据库，另一类的数据表拆分到其他数据库。</p><p>比如说一个新零售的电商数据库，我们可以把跟商品相关的数据表拆分成一个数据库，然后在这些数据表的基础之上，构建出商品系统。比如用JAVA或者PHP语言，创建出一个商城系统。然后把跟进销存相关的数据表拆分到另外一个数据库上，再用程序构建出仓库系统。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-cb822f0a43ecbeeeef8ed3845a3fa278_1440w.jpg" alt="img"></p><p><strong>垂直切分解决了什么问题</strong></p><p>垂直切分可以降低单节点数据库的负载。原来所有数据表都放在一个数据库节点上，无疑所有的读写请求也都发到这个MySQL上面，所以数据库的负载太高。如果把一个节点的数据库拆分成多个MySQL数据库，这样就可以有效的降低每个MySQL数据库的负载。</p><p><strong>垂直切分不能解决什么问题</strong></p><p>垂直切分不能解决的是缩表，比如说商品表无论划分给哪个数据库节点，商品表的记录还是那么多，不管你把数据库垂直拆分的有多细致，每个数据表里面的数据量是没有变化的。</p><p>MySQL单表记录超过2000万，读写性能会下降的很快，因此说垂直切分并不能起到缩表的效果。</p><h2 id="3-什么是水平切分？"><a href="#3-什么是水平切分？" class="headerlink" title="3. 什么是水平切分？"></a><strong>3. 什么是水平切分？</strong></h2><p>水平切分是按照某个字段的某种规则，把数据切分到多张数据表。一张数据表化整为零，拆分成多张数据表，这样就可以起到缩表的效果了。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-e8376833abf17549ed97853ab7f71b90_1440w.jpg" alt="img"></p><p>很多人，都会水平切分存在误解，以为水平切分出来的数据表必须保存在不同的MySQL节点上。其实水平切分出来的数据表也可以保存在一个MySQL节点上面。不是水平切分一定需要多个MySQL节点。为什么这么说呢？</p><p>许多人不知道MySQL自带一种数据分区的技术，可以把一张表的数据，按照特殊规则，切分存储在不同的目录下。如果我们给Linux主机挂载了多块硬盘，我们完全可以利用MySQL分区技术，把一张表的数据切分存储在多个硬盘上。这样就由原来一块硬盘有限的IO能力，升级成了多个磁盘增强型的IO。如果你感兴趣数据分区的具体效果，可以看<a href="https://link.zhihu.com/?target=https://coding.imooc.com/class/274.html?mc_marking=b9478d5f12bd4de1a83dc61bc224d99f&mc_channel=shouji">《MySQL数据库集群》</a>这门实战课。</p><p><strong>水平切分的用途</strong></p><p>水平切分可以把数据切分到多张数据表，可以起到缩表的作用。</p><p>但是也不是所有的数据表都要做水平切分。数据量较大的数据表才需要做数据切分，比如说电商系统中的，用户表、商品表、产品表、地址表、订单表等等。有些数据表就不需要切分，因为数据量不多，比如说品牌表、供货商表、仓库表，这些都是不需要切分的。</p><p><strong>水平切分的缺点</strong></p><p>不同数据表的切分规则并不一致，要根据实际业务来确定。所以我们在选择数据库中间件产品的时候，就要选择切分规则丰富的产品。常见的数据库中间件有：MyCat、Atlas、ProxySQL等等。有些人觉得MyCat是Java语言开发的，就怀疑MyCat运行效率。其实数据库中间件的作用相当于SQL语句的路由器。你家路由器硬件配置不怎么高，但是不影响你享用百兆宽带。MyCat也是一个道理，它仅仅是起到SQL语句转发的作用，并不会实际执行SQL语句。我推荐使用MyCat最主要的原因是它自带了非常多的数据切分规则，我们可以按照主键求模切分数据，可以按照主键范围切分数据，还可以按照日期切分数据等等。因此说，为了满足业务的需要，MyCat目前来说算是非常不错的中间件产品。</p><p>水平切分的另一个缺点就是扩容比较麻烦，日积月累，分片迟早有不够用的时候。这时候不是首先选择增加新的集群分片。因为一个MySQL分片，需要4~8个MySQL节点（最小规模），增加一个分片的投入成本是很高的。所以正确的做法是做冷热数据分离，定期对分片中的数据归档。把过期的业务数据，从分片中转移到归档库。目前来说数据压缩比最高的MySQL引擎是TokuDB，而且带着事物的写入速度是InnoDB引擎的6-14倍。用TokuDB作为归档数据库最适合不过。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-90c4e1014db42321db91c4cf330f1168_1440w.jpg" alt="img"></p><h2 id="4-到底是应该先水平还是先垂直"><a href="#4-到底是应该先水平还是先垂直" class="headerlink" title="4. 到底是应该先水平还是先垂直"></a>4. 到底是应该先水平还是先垂直</h2><p><strong>感觉各有道理</strong>。但我支持先垂直，然后水平</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAT2NlYW4mJlN0YXI=,size_10,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><p>数据库拆分原则：</p><ul><li>优先考虑缓存降低对数据库的读操作</li><li>再考虑读写分离，降低数据库写操作</li><li>最后开始数据拆分：<ul><li>先按照业务垂直拆分</li><li>在考虑水平拆分：先分库（设置数据路由规则，把数据分配到不同的库中）</li><li>最后在考虑分表，单表拆分到数据1000万以内。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-为什么要拆分数据库？&quot;&gt;&lt;a href=&quot;#1-为什么要拆分数据库？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要拆分数据库？&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 为什么要拆分数据库？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;单体项目在构建之初，&lt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
