<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>1.Java集合-框架 | Mr.Ai</title><meta name="keywords" content="Collection"><meta name="author" content="Leslie"><meta name="copyright" content="Leslie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Java集合[1]–java集合分类之前大概分为三种，Set，List，Map三种，JDK5之后，增加Queue.主要由Collection和Map两个接口衍生出来,同时Collection接口继承Iterable接口，所以我们也可以说java里面的集合类主要是由Iterable和Map两个接口以及他们的子接口或者其实现类组成。我们可以认为Collection接口定义了单列集合的规范，每次只能存储">
<meta property="og:type" content="article">
<meta property="og:title" content="1.Java集合-框架">
<meta property="og:url" content="https://leslieaibin.github.io/2021/03/26/Collection/1.Java%E9%9B%86%E5%90%88-%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="Mr.Ai">
<meta property="og:description" content="Java集合[1]–java集合分类之前大概分为三种，Set，List，Map三种，JDK5之后，增加Queue.主要由Collection和Map两个接口衍生出来,同时Collection接口继承Iterable接口，所以我们也可以说java里面的集合类主要是由Iterable和Map两个接口以及他们的子接口或者其实现类组成。我们可以认为Collection接口定义了单列集合的规范，每次只能存储">
<meta property="og:locale">
<meta property="og:image" content="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/26.jpg?raw=true">
<meta property="article:published_time" content="2021-03-25T16:15:42.000Z">
<meta property="article:modified_time" content="2021-04-30T13:04:07.969Z">
<meta property="article:author" content="Leslie">
<meta property="article:tag" content="Collection">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/26.jpg?raw=true"><link rel="shortcut icon" href="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/01.jpg?raw=true"><link rel="canonical" href="https://leslieaibin.github.io/2021/03/26/Collection/1.Java%E9%9B%86%E5%90%88-%E6%A1%86%E6%9E%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-30 21:04:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Mr.Ai" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/01.jpg?raw=true" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">105</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-pen"></i><span> 自言自语</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/26.jpg?raw=true)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Mr.Ai</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-pen"></i><span> 自言自语</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">1.Java集合-框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-03-25T16:15:42.000Z" title="Created 2021-03-26 00:15:42">2021-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-04-30T13:04:07.969Z" title="Updated 2021-04-30 21:04:07">2021-04-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Collection/">Collection</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java集合-1-–java集合分类"><a href="#Java集合-1-–java集合分类" class="headerlink" title="Java集合[1]–java集合分类"></a>Java集合[1]–java集合分类</h1><p>之前大概分为三种，<code>Set</code>，<code>List</code>，<code>Map</code>三种，JDK5之后，增加<code>Queue</code>.主要由<code>Collection</code>和<code>Map</code>两个接口衍生出来,同时<code>Collection</code>接口继承<code>Iterable</code>接口，所以我们也可以说java里面的集合类主要是由<code>Iterable</code>和<code>Map</code>两个接口以及他们的子接口或者其实现类组成。我们可以认为<code>Collection</code>接口定义了单列集合的规范，每次只能存储一个元素，而<code>Map</code>接口定义了双列集合的规范，每次能存储一对元素。</p>
<p>Iterable接口:主要是实现遍历功能</p>
<ul>
<li>Collection接口: 允许重复<ul>
<li>Set接口：无序，元素不可重复,访问元素只能通过元素本身来访问。</li>
<li>List接口：有序且可重复，可以根据元素的索引来访问集合中的元素。</li>
<li>Queue接口：队列集合</li>
</ul>
</li>
</ul>
<p>Map接口：映射关系，简单理解为键值对&lt;Key，Value&gt;，Key不可重复，与<code>Collection</code>接口关系不大，只是个别函数使用到。</p>
<p>整个接口框架关系</p>
<p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20190414213527553.jpg" alt="20190414213527553"></p>
<h2 id="Iterable接口"><a href="#Iterable接口" class="headerlink" title="Iterable接口"></a>Iterable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个内部元素为T类型的迭代器（JDK1.5只有这个接口）</span></span><br><span class="line"><span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历内部元素，action意思为动作，指可以对每个元素进行操作（JDK1.8添加）</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并返回一个可分割迭代器（JDK1.8添加），分割的迭代器主要是提供可以并行遍历元素的迭代器，可以适应现在cpu多核的能力，加快速度。</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Java集合最源头的接口，实现这个接口的作用主要是集合对象可以通过迭代器去遍历每一个元素。</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>default void</code></td>
<td><code>forEachRemaining(Consumer&lt;? super E&gt; action)</code>  执行给定的每个剩余元素的动作，直到所有的元素都被处理或操作抛出异常。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>hasNext()</code>  返回 <code>true</code>如果迭代具有更多的元素。</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>next()</code>  返回迭代中的下一个元素。</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>remove()</code>  从基础集合中移除这个迭代器返回的最后一个元素（可选操作）。</td>
</tr>
</tbody></table>
<p> <strong>iterator方法</strong></p>
<p>遍历Collection的两种方式：</p>
<p>​        ① 使用迭代器Iterator  ② foreach循环（或增强for循环）</p>
<p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</p>
<p> GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;asdfg&quot;</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;zxcvb&quot;</span>));</span><br><span class="line">    coll.add(<span class="keyword">false</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iterator = coll.iterator();</span><br><span class="line">    <span class="comment">// hasNext():判断是否还下一个元素</span></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">// next():①指针下移  ②将下移以后集合位置上的元素返回</span></span><br><span class="line">        Object obj = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;zxcvb&quot;</span>.equals(obj))&#123;</span><br><span class="line">            <span class="comment">// 内部定义了remove(),可以在遍历的时候，删除集合中的元素。</span></span><br><span class="line">            iterator.remove(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator iterator1 = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator1.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*****************************************&quot;</span>);</span><br><span class="line">    <span class="comment">// for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//        // 错误方式一： 一次iterator.next()进行一次指针移动</span></span><br><span class="line">    <span class="comment">//        while(iterator.next() != null)&#123;</span></span><br><span class="line">    <span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        // 错误方式二： 一次coll.iterator()返回一个迭代器对象</span></span><br><span class="line">    <span class="comment">//        while(coll.iterator().hasNext())&#123;</span></span><br><span class="line">    <span class="comment">//            System.out.println(coll.iterator().next());</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。 这是由于<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37476508">Fail-fast</a>。</p>
<h3 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h3><p>其实就是把对每一个元素的操作当成了一个对象传递进来，对每一个元素进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">list.forEach(x -&gt; System.out.print(x));</span><br></pre></td></tr></table></figure>

<p>当然像ArrayList自然也是有自己的实现的，那我们就可以使用这样的写法,简洁优雅。forEach方法在java8中参数是<code>java.util.function.Consumer</code>,可以称为<strong>消费行为</strong>或者说<strong>动作</strong>类型。</p>
<h3 id="spliterator方法"><a href="#spliterator方法" class="headerlink" title="spliterator方法"></a>spliterator方法</h3><p>这是一个为了并行遍历数据元素而设计的迭代方法，返回的是<code>Spliterator</code>，是专门并行遍历的迭代器。以发挥多核时代的处理器性能，java默认在集合框架中提供了一个默认的<code>Spliterator</code>实现，底层也就是Stream.isParallel()实现的，我们可以看一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stream使用的就是spliterator</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="keyword">boolean</span> parallel)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReferencePipeline.Head&lt;&gt;(spliterator,</span><br><span class="line">                                        StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                        parallel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Collection接口："><a href="#Collection接口：" class="headerlink" title="Collection接口："></a>Collection接口：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span></span><br></pre></td></tr></table></figure>

<p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210326162900813.png" alt="image-20210326162900813"></p>
<p>Collection接口是Set,Queue,List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>add(E e)</code>  确保此集合包含指定的元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>addAll(Collection&lt;? extends E&gt; c)</code>  将指定集合中的所有元素添加到这个集合（可选操作）。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code>  从这个集合中移除所有的元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>contains(Object o)</code>  返回 <code>true</code>如果集合包含指定元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsAll(Collection&lt;?&gt; c)</code>  返回 <code>true</code>如果这个集合包含指定集合的所有元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object o)</code>  将指定的对象与此集合进行比较，以进行相等性。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>hashCode()</code>  返回此集合的哈希代码值。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code>  返回 <code>true</code>如果集合不包含任何元素。</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt;</code></td>
<td><code>iterator()</code>  返回此集合中的元素的迭代器。</td>
</tr>
<tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>parallelStream()</code>  返回一个可能并行 <code>Stream</code>与集合的来源。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>remove(Object o)</code>  从这个集合中移除指定元素的一个实例，如果它是存在的（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>removeAll(Collection&lt;?&gt; c)</code>  删除此集合中包含的所有元素（可选操作）的所有元素（可选操作）。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>removeIf(Predicate&lt;? super E&gt; filter)</code>  删除满足给定谓词的这个集合的所有元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>retainAll(Collection&lt;?&gt; c)</code>  仅保留包含在指定集合中的这个集合中的元素（可选操作）。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code>  返回此集合中的元素的数目。</td>
</tr>
<tr>
<td><code>default Spliterator&lt;E&gt;</code></td>
<td><code>spliterator()</code>  创建此集合中的元素的 <a href="../../java/util/Spliterator.html"><code>Spliterator</code></a>。</td>
</tr>
<tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>stream()</code>  返回一个序列 <code>Stream</code>与集合的来源。</td>
</tr>
<tr>
<td><code>Object[]</code></td>
<td><code>toArray()</code>  返回包含此集合中所有元素的数组。</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[]</code></td>
<td><code>toArray(T[] a)</code>  返回包含此集合中所有元素的数组；返回数组的运行时类型是指定的数组的运行时类型。</td>
</tr>
</tbody></table>
<p>可以看出Collection用法有：添加元素，删除元素，返回Collection集合的个数以及清空集合等。<br>其中重点介绍iterator()方法，该方法的返回值是Iterator<E>。</p>
<h3 id="List-extends-Collection"><a href="#List-extends-Collection" class="headerlink" title="List extends Collection"></a>List extends Collection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>继承于<code>Collection</code>接口，有顺序，取出的顺序与存入的顺序一致，有索引，可以根据索引获取数据，允许存储重复的元素，可以放入为null的元素。<br> 最常见的三个实现类就是<code>ArrayList</code>，<code>Vector</code>,<code>LinkedList</code>，<code>ArrayList</code>和<code>Vector</code>都是内部封装了对数组的操作，唯一不同的是，<code>Vector</code>是线程安全的，而<code>ArrayList</code>不是，理论上<code>ArrayList</code>操作的效率会比<code>Vector</code>好一些。</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>add(E e)</code>  将指定的元素到这个列表的末尾（可选操作）。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>add(int index, E element)</code>  在列表中指定的位置上插入指定的元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>addAll(Collection&lt;? extends E&gt; c)</code>  追加指定集合的所有元素到这个列表的末尾，按他们的指定集合的迭代器返回（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>addAll(int index,  Collection&lt;? extends E&gt; c)</code>  将指定的集合中的所有元素插入到指定位置的列表中（可选操作）。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code>  从这个列表中移除所有的元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>contains(Object o)</code>  返回 <code>true</code>如果这个列表包含指定元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsAll(Collection&lt;?&gt; c)</code>  返回 <code>true</code>如果这个列表包含指定集合的所有元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object o)</code>  将指定的对象与此列表进行比较，以进行相等性。</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>get(int index)</code>  返回此列表中指定位置的元素。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>hashCode()</code>  返回此列表的哈希代码值。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>indexOf(Object o)</code>  返回此列表中指定元素的第一个出现的索引，或-如果此列表不包含元素，或- 1。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code>  返回 <code>true</code>如果此列表不包含元素。</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt;</code></td>
<td><code>iterator()</code>  在这个列表中的元素上返回一个正确的顺序。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lastIndexOf(Object o)</code>  返回此列表中指定元素的最后一个发生的索引，或-如果此列表不包含元素，或- 1。</td>
</tr>
<tr>
<td><code>ListIterator&lt;E&gt;</code></td>
<td><code>listIterator()</code>  返回列表元素的列表迭代器（在适当的顺序）。</td>
</tr>
<tr>
<td><code>ListIterator&lt;E&gt;</code></td>
<td><code>listIterator(int index)</code>  在列表中的元素上返回列表迭代器（在适当的顺序），从列表中的指定位置开始。</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>remove(int index)</code>  移除此列表中指定位置的元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>remove(Object o)</code>  从该列表中移除指定元素的第一个发生，如果它是存在的（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>removeAll(Collection&lt;?&gt; c)</code>  从这个列表中移除包含在指定集合中的所有元素（可选操作）。</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>replaceAll(UnaryOperator&lt;E&gt; operator)</code>  用将运算符应用到该元素的结果替换此列表中的每个元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>retainAll(Collection&lt;?&gt; c)</code>  仅保留包含在指定集合中的列表中的元素（可选操作）。</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>set(int index, E element)</code>  用指定元素替换此列表中指定位置的元素（可选操作）。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code>  返回此列表中元素的数目。</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>sort(Comparator&lt;? super E&gt; c)</code>  分类列表使用提供的 <code>Comparator</code>比较元素。</td>
</tr>
<tr>
<td><code>default Spliterator&lt;E&gt;</code></td>
<td><code>spliterator()</code>  创建此列表中的元素的 <a href="../../java/util/Spliterator.html"><code>Spliterator</code></a>。</td>
</tr>
<tr>
<td><code>List&lt;E&gt;</code></td>
<td><code>subList(int fromIndex,  int toIndex)</code>  返回一个视图之间的指定 <code>fromIndex</code>，包容，和  <code>toIndex</code>这份名单的部分，独家。</td>
</tr>
<tr>
<td><code>Object[]</code></td>
<td><code>toArray()</code>  返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一个到最后一个元素）。</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[]</code></td>
<td><code>toArray(T[] a)</code>  返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一到最后一个元素）；返回数组的运行时类型是指定的数组的运行时类型。</td>
</tr>
</tbody></table>
<p>Collection接口：单列集合，用来存储一个一个的对象</p>
<p><strong>常用类</strong></p>
<ul>
<li>List接口：存储序的、可重复的数据。  –&gt;“动态”数组,替换原的数组<ul>
<li><strong>ArrayList</strong>：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</li>
<li><strong>LinkedList</strong>：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</li>
<li><strong>Vector</strong>：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</li>
</ul>
</li>
</ul>
<h3 id="Set-extends-Collection"><a href="#Set-extends-Collection" class="headerlink" title="Set extends Collection"></a>Set extends Collection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>add(E e)</code>  如果没有当前（可选操作），则将指定的元素添加到该集合中。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>addAll(Collection&lt;? extends E&gt; c)</code>  如果没有当前（可选操作），将指定集合中的所有元素添加到该集合中。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code>  从这个集合中移除所有的元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>contains(Object o)</code>  如果这套 <code>true</code>返回包含指定的元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsAll(Collection&lt;?&gt; c)</code>  如果这套 <code>true</code>返回包含指定集合的所有元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object o)</code>  将指定的对象与此设置的相等性进行比较。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>hashCode()</code>  返回此组的哈希代码值。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code>  返回 <code>true</code>如果这个集合不包含元素。</td>
</tr>
<tr>
<td><code>Iterator&lt;E&gt;</code></td>
<td><code>iterator()</code>  返回此集合中元素的迭代器。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>remove(Object o)</code>  如果当前（可选操作），则从该集合中移除指定的元素。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>removeAll(Collection&lt;?&gt; c)</code>  从这个集合中移除包含在指定集合中的所有元素（可选操作）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>retainAll(Collection&lt;?&gt; c)</code>  仅保留包含在指定集合中的此集合中的元素（可选操作）。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code>  返回该集合中元素个数（其基数）。</td>
</tr>
<tr>
<td><code>default Spliterator&lt;E&gt;</code></td>
<td><code>spliterator()</code>  在这个集合中的元素创建一个 <code>Spliterator</code>。</td>
</tr>
<tr>
<td><code>Object[]</code></td>
<td><code>toArray()</code>  返回一个包含此集合中所有元素的数组。</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[]</code></td>
<td><code>toArray(T[] a)</code>  返回包含此集合中的所有元素的数组；返回的数组的运行时类型是指定的数组的运行时类型。</td>
</tr>
</tbody></table>
<p><strong>Set</strong>存储的数据特点：无序的、不可重复的元素</p>
<p><strong>常用类</strong></p>
<p> 以HashSet为例说明：</p>
<ul>
<li><p>无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。</p>
</li>
<li><p>不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</p>
</li>
</ul>
<p>Set接口中没额外定义新的方法，使用的都是Collection中声明过的方法。</p>
<p>Collection接口：单列集合，用来存储一个一个的对象</p>
<ul>
<li><p>Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”</p>
<ul>
<li><p>HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</p>
<ul>
<li><p>LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历。</p>
<p>在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</p>
</li>
</ul>
</li>
<li><pre><code>         TreeSet：可以照添加对象的指定属性，进行排序。</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="Queue-extends-Collection"><a href="#Queue-extends-Collection" class="headerlink" title="Queue extends Collection"></a>Queue extends Collection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>add(E e)</code>  插入指定元素为该队列是否有可能立即这样做不违反容量限制，还  <code>true</code>成功后抛出 <code>IllegalStateException</code>如果没有空间是可用的。</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>element()</code>  检索，但不删除此队列的头。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offer(E e)</code>  如果可能立即在不违反容量限制的情况下这样做的话，将指定的元素插入到队列中。</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peek()</code>  检索，但不删除，这个队列头，或返回 <code>null</code>如果队列为空。</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>poll()</code>  检索并移除此队列的头，或返回 <code>null</code>如果队列为空。</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>remove()</code>  检索和删除此队列的头。</td>
</tr>
</tbody></table>
<p>队列接口，在Collection接口的接触上添加了增删改查接口定义，一般默认是先进先出，即FIFO，除了优先队列和栈，优先队列是自己定义了排序的优先顺序，队列中不允许放入null元素。</p>
<ul>
<li><p>Deque（接口）:Queue的子接口，双向队列，可以从两边存取</p>
<ul>
<li>ArrayDeque：Deque的实现类，底层用数组实现，数据存贮在数组中</li>
</ul>
</li>
<li><p>AbstractQueue：Queue的子接口，仅实现了add、remove和element三个方法</p>
<ul>
<li>PriorityQueue：按照默认或者自己定义的顺序来排序元素，底层使用堆（完全二叉树）实现，使用动态数组实现，</li>
</ul>
</li>
<li><p>BlockingQueue： 在java.util.concurrent包中，阻塞队列，满足当前无法处理的操作</p>
</li>
</ul>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Interface Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义双列集合的规范Map&lt;K，V&gt;，每次存储一对元素，即key和value。</li>
<li>key的类型可以和value的类型相同，也可以不同，任意的引用类型都可以。</li>
<li>key是不允许重复的，但是value是可以重复的，所谓重复是指计算的hash值系统。</li>
</ul>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>clear()</code>  从这个映射中移除所有的映射（可选操作）。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>  试图计算出指定键和当前的映射值的映射（或 <code>null</code>如果没有当前映射）。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>  如果指定的键是不是已经与价值相关的（或映射到  <code>null</code>），尝试使用给定的映射功能，进入到这个Map除非 <code>null</code>计算其价值。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>  如果指定键的值是存在和非空的，尝试计算一个新的映射，给出了键和它当前的映射值。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsKey(Object key)</code>  返回 <code>true</code>如果这Map包含一个指定的键映射。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsValue(Object value)</code>  返回 <code>true</code>如果映射到指定的值的一个或多个键。</td>
</tr>
<tr>
<td><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></td>
<td><code>entrySet()</code>  返回一个 <a href="../../java/util/Set.html"><code>Set</code></a>视图的映射包含在这个Map。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object o)</code>  将指定的对象与此映射的相等性进行比较。</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>  在该映射中的每个条目执行给定的操作，直到所有的条目被处理或操作抛出异常。</td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>get(Object key)</code>  返回指定的键映射的值，或 <code>null</code>如果这个Map不包含的键映射。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>getOrDefault(Object key, V defaultValue)</code>  返回指定的键映射的值，或  <code>defaultValue</code>如果这个Map不包含的键映射。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>hashCode()</code>  返回此映射的哈希代码值。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code>  返回 <code>true</code>如果这个Map不包含键值的映射。</td>
</tr>
<tr>
<td><code>Set&lt;K&gt;</code></td>
<td><code>keySet()</code>  返回一个 <a href="../../java/util/Set.html"><code>Set</code></a>的关键视图包含在这个Map。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code>  如果指定的键已与值相关联的值或与空值相关联的，则将其与给定的非空值关联。</td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>put(K key, V value)</code>  将指定的值与此映射中的指定键关联（可选操作）。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>putAll(Map&lt;?  extends K,?  extends V&gt; m)</code>  从指定的映射到这个Map（可选操作）复制所有的映射。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>putIfAbsent(K key, V value)</code>  如果指定的键是不是已经与价值相关的（或映射到  <code>null</code>）将其与给定的值并返回 <code>null</code>，否则返回当前值。</td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>remove(Object key)</code>  如果存在（可选操作），则从该Map中移除一个键的映射。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>remove(Object key, Object value)</code>  仅当它当前映射到指定的值时，为指定的键移除条目。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>replace(K key, V value)</code>  仅当它当前映射到某一值时，替换指定的键的条目。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>replace(K key, V oldValue, V newValue)</code>  仅当当前映射到指定的值时，替换指定的键的条目。</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>  将每个条目的值替换为在该项上调用给定函数的结果，直到所有的条目都被处理或函数抛出异常。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code>  返回这个映射中的键值映射的数目。</td>
</tr>
<tr>
<td><code>Collection&lt;V&gt;</code></td>
<td><code>values()</code>  返回一个 <a href="../../java/util/Collection.html"><code>Collection</code></a>视图的值包含在这个Map。</td>
</tr>
</tbody></table>
<p><strong>Map:双列数据，存储key-value对的数据   —类似于高中的函数：y = f(x)</strong></p>
<ul>
<li><p>HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</p>
<ul>
<li><pre><code>         LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</code></pre>
</li>
<li><pre><code>               原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</code></pre>
</li>
<li><pre><code>               对于频繁的遍历操作，此类执行效率高于HashMap。</code></pre>
</li>
</ul>
</li>
<li><p>TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</p>
<p>底层使用红黑树</p>
</li>
<li><p>Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</p>
<ul>
<li><pre><code>  Properties:常用来处理配置文件。key和value都是String类型</code></pre>
</li>
</ul>
</li>
<li><p>HashMap的底层：数组+链表  （jdk7及之前)</p>
</li>
</ul>
<p>  <strong>数组+链表+红黑树 （jdk 8)</strong></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>为什么有数组了，还要提供集合？</p>
<p><strong>数组的优点：</strong></p>
<ul>
<li>数组的效率高于集合类</li>
<li>数组能存放基本数据类型和对象；集合中只能放对象</li>
</ul>
<p><strong>数组的缺点：</strong></p>
<ul>
<li>不是面向对象的，存在明显的缺陷</li>
<li>数组长度固定且无法动态改变；集合类容量动态改变</li>
<li>数组无法判断其中实际存了多少元素，只能通过length属性获取数组的申明的长度</li>
<li>数组存储的特点是顺序的连续内存；集合的数据结构更丰富</li>
</ul>
<p><strong>JDK 提供集合的意义：</strong></p>
<ul>
<li>集合以类的形式存在，符合面向对象，通过简单的方法和属性调用可实现各种复杂操作</li>
<li>集合有多种数据结构，不同类型的集合可适用于不同场合</li>
<li>弥补了数组的一些缺点，比数组更灵活、实用，可开发效率</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Leslie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://leslieaibin.github.io/2021/03/26/Collection/1.Java%E9%9B%86%E5%90%88-%E6%A1%86%E6%9E%B6/">https://leslieaibin.github.io/2021/03/26/Collection/1.Java%E9%9B%86%E5%90%88-%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Collection/">Collection</a></div><div class="post_share"><div class="social-share" data-image="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/26.jpg?raw=true" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/24/Thread/2.java%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"><img class="prev-cover" src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/27.jpg?raw=true" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">2.java中多线程的实现</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/09/%E5%B7%A5%E5%85%B7/win10%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/"><img class="next-cover" src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/11.jpg?raw=true" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">win10连接linux服务器的工具</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/09/05/Collection/4.HashMap的扩容机制/" title="4.HashMap实现原理"><img class="cover" src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/39.jpg?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-05</div><div class="title">4.HashMap实现原理</div></div></a></div><div><a href="/2021/08/24/Collection/3.java集合[3]--HashMap、ConcurrentHashMap、HashTable的区别/" title="3.HashMap、ConcurrentHashMap、HashTable"><img class="cover" src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/26.jpg?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-24</div><div class="title">3.HashMap、ConcurrentHashMap、HashTable</div></div></a></div><div><a href="/2021/08/20/Collection/2.集合[2]/" title="2.Java集合"><img class="cover" src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/36.jpg?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-20</div><div class="title">2.Java集合</div></div></a></div><div><a href="/2021/09/24/Collection/5.ConcurrentHashMap详解/" title="5.ConcurrentHashMap详解"><img class="cover" src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/40.jpg?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-24</div><div class="title">5.ConcurrentHashMap详解</div></div></a></div><div><a href="/2021/09/25/Collection/6.循环队列/" title="6.循环队列"><img class="cover" src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/41.jpg?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-25</div><div class="title">6.循环队列</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/01.jpg?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Leslie</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">105</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div></div><a class="button--animated" id="card-info-btn"><i class="fas fa-heart"></i><span>瓶中的水 青天的云</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/leslieAIbin" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.instagram.com/leslieaibin/" target="_blank" title="Ins"><i class="fab fa-instagram"></i></a><a class="social-icon" href="mailto:1915612226@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122143121657.png" target="_blank" title="weixin"><i class="fab fa-weixin"></i></a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88-1-%E2%80%93java%E9%9B%86%E5%90%88%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">Java集合[1]–java集合分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">Iterable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator"><span class="toc-number">1.1.1.</span> <span class="toc-text">Iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">forEach方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spliterator%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">spliterator方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">Collection接口：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List-extends-Collection"><span class="toc-number">1.2.1.</span> <span class="toc-text">List extends Collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-extends-Collection"><span class="toc-number">1.2.2.</span> <span class="toc-text">Set extends Collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue-extends-Collection"><span class="toc-number">1.2.3.</span> <span class="toc-text">Queue extends Collection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.</span> <span class="toc-text">Map接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">1.4.</span> <span class="toc-text">思考</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.Ping%E7%9A%84%E5%8E%9F%E7%90%86/" title="Ping的原理"><img src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/45.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ping的原理"/></a><div class="content"><a class="title" href="/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.Ping%E7%9A%84%E5%8E%9F%E7%90%86/" title="Ping的原理">Ping的原理</a><time datetime="2022-03-08T01:15:42.000Z" title="Created 2022-03-08 09:15:42">2022-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/23/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" title="策略模式"><img src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/23.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="策略模式"/></a><div class="content"><a class="title" href="/2021/12/23/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" title="策略模式">策略模式</a><time datetime="2021-12-22T16:15:42.000Z" title="Created 2021-12-23 00:15:42">2021-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/19/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" title="海量数据处理"><img src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/22.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="海量数据处理"/></a><div class="content"><a class="title" href="/2021/12/19/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" title="海量数据处理">海量数据处理</a><time datetime="2021-12-18T16:15:42.000Z" title="Created 2021-12-19 00:15:42">2021-12-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/" title="定位问题"><img src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/21.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="定位问题"/></a><div class="content"><a class="title" href="/2021/12/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/" title="定位问题">定位问题</a><time datetime="2021-12-17T16:15:42.000Z" title="Created 2021-12-18 00:15:42">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/14/java%E5%9F%BA%E7%A1%80/bitMap%E8%AE%B2%E8%A7%A3/" title="bitMap讲解"><img src="https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/20.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="bitMap讲解"/></a><div class="content"><a class="title" href="/2021/12/14/java%E5%9F%BA%E7%A1%80/bitMap%E8%AE%B2%E8%A7%A3/" title="bitMap讲解">bitMap讲解</a><time datetime="2021-12-14T01:15:42.000Z" title="Created 2021-12-14 09:15:42">2021-12-14</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://github.com/leslieAIbin/leslieaibin.github.io/blob/main/imgs/26.jpg?raw=true)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Leslie</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>