<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Ai</title>
  
  <subtitle>春暖花开去见你</subtitle>
  <link href="https://leslieaibin.github.io/atom.xml" rel="self"/>
  
  <link href="https://leslieaibin.github.io/"/>
  <updated>2022-02-13T08:08:24.988Z</updated>
  <id>https://leslieaibin.github.io/</id>
  
  <author>
    <name>Leslie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>海量数据处理</title>
    <link href="https://leslieaibin.github.io/2021/12/19/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2021/12/19/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2021-12-18T16:15:42.000Z</published>
    <updated>2022-02-13T08:08:24.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="海量数据处理的问题总结"><a href="#海量数据处理的问题总结" class="headerlink" title="海量数据处理的问题总结"></a>海量数据处理的问题总结</h1><p>所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。</p><p>解决办法呢？针对时间，需要采用巧妙的算法配合合适的数据结构，如<code>Bloom filter</code>/<code>Hash</code>/<code>bit-map</code>/<code>堆</code>/<code>数据库</code>或<code>倒排索引</code>/<code>trie</code>树。针对空间，大而化小，分而治之（<code>hash</code>映射可以做到）。</p><p>至于所谓的单机及集群问题，单机就是处理装载数据的机器有限(只要考虑CPU、内存、硬盘间的数据交互)。而集群，机器有多台，适合分布式处理、并行计算(更多考虑节点和节点间的数据交互)。</p><h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p><h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。</p><pre><code>5,000,000,000 * 64B ≈ 5GB * 64 = 320GB</code></pre><p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用分治策略，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p>思路如下：</p><p>首先遍历文件 a，对遍历到的 URL 求<code>hash(URL) % 1000</code>，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p><p>接着遍历<code>ai (i∈[0,999])</code>，把 URL 存储到一个<code>HashSet</code>集合中。然后遍历 bi 中每个 URL，看在<code>HashSet</code>集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p><p>方法总结</p><ul><li>  分而治之，进行哈希取余；</li><li>  对每个子文件进行<code>HashSet</code>统计。</li></ul><h1 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p><h2 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h2><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用分治策略，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p><p>思路如下：</p><p>首先遍历大文件，对遍历到的每个词x，执行<code>hash(x) % 5000</code>，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p><p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用<code>HashMap</code>来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 map.put(x, 1)；若存在，则执行<code>map.put(x, map.get(x) + 1)</code>，将该词频数加 1。</p><p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个小顶堆来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个小顶堆，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为小顶堆，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p><h2 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h2><ul><li>  分而治之，进行哈希取余；</li><li>  使用<code>HashMap</code>统计频数；</li><li>  求解最大的<code>TopN</code>个，用小顶堆；求解最小的<code>TopN</code>个，用大顶堆。</li></ul><h1 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。</p><h2 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h2><p>这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用<code>HashMap</code>统计重复 IP 的次数，最后计算出重复次数最多的 IP。</p><p>注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。</p><h2 id="方法总结-1"><a href="#方法总结-1" class="headerlink" title="方法总结"></a>方法总结</h2><ul><li>  分而治之，进行哈希取余；</li><li>  使用<code>HashMap</code>统计频数；</li><li>  求解最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。</li></ul><h1 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p><h2 id="解答思路-3"><a href="#解答思路-3" class="headerlink" title="解答思路"></a>解答思路</h2><h3 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h3><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用<code>HashSet</code>/<code>HashMap</code>找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p><h3 id="方法二：位图法"><a href="#方法二：位图法" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h3><p>位图，就是用一个或多个<code>bit</code>来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p><p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p><p>假设我们要对 [0,7] 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p><pre><code>0 0 0 0 0 0 0 0</code></pre><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p><pre><code>0 0 0 0 1 0 1 0</code></pre><p>依次遍历，结束后，位数组是这样的：</p><pre><code>0 1 1 0 1 1 1 0</code></pre><p>每个为 1 的位，它的下标都表示了一个数：</p><pre><code>for i in range(8):    if bits[i] == 1:        print(i)</code></pre><p>这样我们其实就已经实现了排序。</p><p>对于整数相关的算法的求解，位图法是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 2^32。</p><p>那么对于这道题，我们用 2 个 bit 来表示各个数字的状态：</p><ul><li>  00 表示这个数字没出现过；</li><li>  01 表示这个数字出现过一次（即为题目所找的不重复整数）；</li><li>  10 表示这个数字出现了多次。</li></ul><p>那么这 2^32 个整数，总共所需内存为 2^32*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p><p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p><h2 id="方法总结-2"><a href="#方法总结-2" class="headerlink" title="方法总结"></a>方法总结</h2><p>判断数字是否重复的问题，位图法是一种非常高效的方法。</p><h1 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 40 亿个不重复的没排过序的<code>unsigned int</code>型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？</p><h2 id="解答思路-4"><a href="#解答思路-4" class="headerlink" title="解答思路"></a>解答思路</h2><h3 id="方法一：分治法-1"><a href="#方法一：分治法-1" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h3><p>依然可以用分治法解决，方法与前面类似，就不再次赘述了。</p><h3 id="方法二：位图法-1"><a href="#方法二：位图法-1" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h3><p>40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b ≈ 512M。</p><p>我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。</p><h2 id="方法总结-3"><a href="#方法总结-3" class="headerlink" title="方法总结"></a>方法总结</h2><p>判断数字是否存在、判断数字是否重复的问题，位图法是一种非常高效的方法。</p><h1 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询床的长度不超过 255 字节。</p><p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p><h2 id="解答思路-5"><a href="#解答思路-5" class="headerlink" title="解答思路"></a>解答思路</h2><p>每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。</p><h3 id="方法一：分治法-2"><a href="#方法一：分治法-2" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h3><p>分治法依然是一个非常实用的方法。</p><p>划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。</p><p>方法可行，但不是最好，下面介绍其他方法。</p><h3 id="方法二：HashMap-法"><a href="#方法二：HashMap-法" class="headerlink" title="方法二：HashMap 法"></a>方法二：HashMap 法</h3><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个<code>HashMap</code>中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。</p><p>思路如下：</p><p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 O(N)。</p><p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p><p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 O(Nlog10)。</p><h3 id="方法三：前缀树法"><a href="#方法三：前缀树法" class="headerlink" title="方法三：前缀树法"></a>方法三：前缀树法</h3><p>方法二使用了<code>HashMap</code>来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p><p>思路如下：</p><p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p><p>最后依然使用小顶堆来对字符串的出现次数进行排序。</p><h2 id="方法总结-4"><a href="#方法总结-4" class="headerlink" title="方法总结"></a>方法总结</h2><p>前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。</p><h1 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。</p><h2 id="解答思路-6"><a href="#解答思路-6" class="headerlink" title="解答思路"></a>解答思路</h2><p>这道题本质还是求解数据重复的问题，对于这类问题，一般首先考虑位图法。</p><p>对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。</p><p>思路如下：</p><p>申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。</p><h2 id="方法总结-5"><a href="#方法总结-5" class="headerlink" title="方法总结"></a>方法总结</h2><p>求解数据重复问题，记得考虑位图法。</p><h1 id="题目8"><a href="#题目8" class="headerlink" title="题目8"></a>题目8</h1><p>题目描述 从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 (N+1)/2 个数；当样本数为偶数时，中位数为 第 N/2 个数与第 1+N/2 个数的均值。</p><h2 id="解答思路-7"><a href="#解答思路-7" class="headerlink" title="解答思路"></a>解答思路</h2><p>如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 O(NlogN)。这里使用其他方法。</p><h3 id="方法一：双堆法"><a href="#方法一：双堆法" class="headerlink" title="方法一：双堆法"></a>方法一：双堆法</h3><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。</p><p>若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。</p><p>以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法适用于数据量较小的情况。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。</p><h3 id="方法二：分治法"><a href="#方法二：分治法" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h3><p>分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。</p><p>对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。</p><p>划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。</p><p>提示，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。 对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。</p><p>注意，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。</p><h2 id="方法总结-6"><a href="#方法总结-6" class="headerlink" title="方法总结"></a>方法总结</h2><p>分治法，真香！</p><h1 id="题目9"><a href="#题目9" class="headerlink" title="题目9"></a>题目9</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。</p><h2 id="解答思路-8"><a href="#解答思路-8" class="headerlink" title="解答思路"></a>解答思路</h2><p>如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。</p><h3 id="方法一：HashMap法"><a href="#方法一：HashMap法" class="headerlink" title="方法一：HashMap法"></a>方法一：<code>HashMap</code>法</h3><p>如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的<code>HashMap</code>中。接着就可以按照 query 出现的次数进行排序。</p><h3 id="方法二：分治法-1"><a href="#方法二：分治法-1" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h3><p>分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 hash(query) % 10 把这些 query 划分到 10 个小文件中。之后对每个小文件使用<code>HashMap</code>统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。</p><p>接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。</p><h2 id="方法总结-7"><a href="#方法总结-7" class="headerlink" title="方法总结"></a>方法总结</h2><ul><li>  内存若够，直接读入进行排序；</li><li>  内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。</li></ul><h1 id="题目10"><a href="#题目10" class="headerlink" title="题目10"></a>题目10</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？</p><h2 id="解答思路-9"><a href="#解答思路-9" class="headerlink" title="解答思路"></a>解答思路</h2><p>对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：</p><p>首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。</p><p>接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。</p><p>重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。</p><p>为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。</p><h2 id="方法总结-8"><a href="#方法总结-8" class="headerlink" title="方法总结"></a>方法总结</h2><p>求 TopK，不妨考虑一下堆排序？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;海量数据处理的问题总结&quot;&gt;&lt;a href=&quot;#海量数据处理的问题总结&quot; class=&quot;headerlink&quot; title=&quot;海量数据处理的问题总结&quot;&gt;&lt;/a&gt;海量数据处理的问题总结&lt;/h1&gt;&lt;p&gt;所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>定位问题</title>
    <link href="https://leslieaibin.github.io/2021/12/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://leslieaibin.github.io/2021/12/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-17T16:15:42.000Z</published>
    <updated>2022-02-13T08:24:07.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定位问题的先决条件"><a href="#定位问题的先决条件" class="headerlink" title="定位问题的先决条件"></a>定位问题的先决条件</h3><p>需要有详细的日志记录，提前告警的监控平台，事发现场保留</p><blockquote><p>日志 ：业务日志，中间件日志<br>监控 ：CPU、内存、磁盘、网络，类加载、GC、线程等<br>快照 ：-XX:+HeapDumpOnOutOfMemoryError 和 -XX:HeapDumpPath</p></blockquote><h3 id="分析问题，解决问题的思路"><a href="#分析问题，解决问题的思路" class="headerlink" title="分析问题，解决问题的思路"></a>分析问题，解决问题的思路</h3><blockquote><p>经验+直觉，快速定位 &gt; 逐一排查，传输链路 &gt; 寻找规律 不要轻易怀疑监控。考虑资源。优先保证系统能正常运行。保留现场，事后排查定位问题。</p></blockquote><blockquote><p>逐一排查，传输链路，通过日志或工具逐一排查</p><ol><li>内部原因，是否是客户端或者前端问题，程序发布后的Bug，回滚后可以立即解决</li><li>外部原因，比如服务，第三方服务，主机、组件的问题。<ol><li>服务：错误日志邮件提醒或elk快速定位问题，查看gc日志</li><li>第三方服务：单独调用测试，联系第三方加急解决</li><li>主机： CPU相关问题，可以使用 top、vmstat、pidstat、ps 等工具排查； 内存相关问题，可以使用 free、top、ps、vmstat、cachestat、sar 等工具排查；IO 相关问题，可以使用 lsof、iostat、pidstat、sar、iotop、df、du 等工具排查；网络相关问题，可以使用 ifconfig、ip、nslookup、dig、ping、tcpdump、iptables等工具排查。</li><li>组件：查看日志输出，使用命令查看运行情况</li></ol></li><li>因为系统资源不够造成系统假死的问题，通常需要先通过重启和扩容解决问题，之后再进行分析，系统资源不够，一般体现在 CPU 使用高、 内存泄漏或OOM 的问题、IO问题、网络相关问题这四个方面</li></ol></blockquote><h3 id="分析问题的方法"><a href="#分析问题的方法" class="headerlink" title="分析问题的方法"></a>分析问题的方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jps -v 查看java进程</span><br><span class="line">jinfo -flags pid 查看运行参数</span><br><span class="line">jstat -gc 8544 5000 100，将每隔5s采样一次pid为8544的gc，输出100次</span><br><span class="line"></span><br><span class="line">jmap -dump:live,format=b,file=dump.hprof 29170 </span><br><span class="line"><span class="meta">#</span><span class="bash">生成虚拟机的内存转储快照 注意线上可能会触发线上gc</span></span><br><span class="line">jmap -heap 29170</span><br><span class="line">jmap -histo:live 29170 | more</span><br><span class="line">jmap -permstat 29170</span><br><span class="line"></span><br><span class="line">jstack -l 29170 |more 显示虚拟机的线程快照</span><br><span class="line"></span><br><span class="line">df -h # 磁盘 </span><br><span class="line">free -m / -h # 内存</span><br><span class="line">top cpu  # cpu          </span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="线上cpu100-报警（找出最耗时CPU进程-线程-堆栈-代码）"><a href="#线上cpu100-报警（找出最耗时CPU进程-线程-堆栈-代码）" class="headerlink" title="线上cpu100%报警（找出最耗时CPU进程-线程-堆栈-代码）"></a>线上cpu100%报警（找出最耗时CPU进程-线程-堆栈-代码）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">方法1：原生工具，慢</span><br><span class="line">top -c #显示完整信息  P：cpu使用排序 M：内存使用排序</span><br><span class="line">top -Hp 10765 ，#显示一个进程的线程运行信息列表  -H 显示线程信息，-p指定pid &amp; P</span><br><span class="line">printf &quot;%x\n&quot; 10804    转16进制   2f71</span><br><span class="line">jstack 12084 | grep &#x27;0x2f71&#x27; -C5 --color 查看堆栈，找到线程在干嘛</span><br><span class="line"></span><br><span class="line">方法2：</span><br><span class="line">使用提前准备好的sh脚本，可以一条命名查看当前出事的线程代码，快，推荐</span><br><span class="line">sh show-busy-java-threads.sh &gt; a.txt #查询java耗时线程前5个</span><br><span class="line">sh show-busy-java-threads.sh -p &gt; a.txt #查询指定进程</span><br><span class="line"></span><br><span class="line">方法3：</span><br><span class="line">使用arthas，工具内置很多功能，比如可以查看源码，判断是否发布成功，可以用来排查疑难问题</span><br><span class="line">curl -O https://alibaba.github.io/arthas/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br><span class="line">dashboard</span><br><span class="line">thread -8</span><br><span class="line">jad com.xx.xx.xx.xxximp 查看线上类代码</span><br><span class="line">watch com.xx.xx.xx.xxximp doTask &#x27;&#123;params&#125;&#x27; &#x27;#cost&gt;100&#x27; -x 2 </span><br><span class="line"><span class="meta">#</span><span class="bash">观察会慢在什么入参上，监控耗时超过100毫秒的 doTask方法的入参，并且输出入参，展开2层入参参数</span></span><br><span class="line">ognl #查询某静态字段的值</span><br><span class="line"></span><br><span class="line">定位到堆栈就可以定位到出问题代码的行号，然后找对应的发布分支代码该行号即可</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="线上内存OOM"><a href="#线上内存OOM" class="headerlink" title="线上内存OOM"></a>线上内存OOM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">某Java服务（假设PID&#x3D;12084）出现了OOM，最常见的原因为：</span><br><span class="line">1. 有可能是内存分配确实过小，而正常业务使用了大量内存</span><br><span class="line">2. 某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽未调用close()，dispose()释放资源，例如：文件io，网络io</span><br><span class="line">3. 某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程（没有用线程池），不断发起网络连接等</span><br><span class="line">总结：本身资源不够，申请资源太多，资源耗尽</span><br><span class="line"></span><br><span class="line">分析工具：</span><br><span class="line">jvisualvm（直方图），MAT（优先，直方图，跟踪内存使用的引用关系），JProfiler</span><br><span class="line"></span><br><span class="line">线下分析：</span><br><span class="line">服务挂掉之后有保留文件：直接下载dump文件导入mat分析</span><br><span class="line">java -jar -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;</span><br><span class="line"></span><br><span class="line">线上分析：</span><br><span class="line">1. 确认是不是内存本身就分配过小</span><br><span class="line">jmap -heap 12084</span><br><span class="line"></span><br><span class="line">2. 找到最耗内存的对象</span><br><span class="line">jmap -histo:live 12084 | head -n 10  #该命令会强制执行一次fgc</span><br><span class="line"></span><br><span class="line">jmap -dump:format&#x3D;b,file&#x3D;&#x2F;opt&#x2F;dump.hprof &#123;pid&#125; #以二进制输出档当前内存的堆情况，</span><br><span class="line">然后可以导入MAT等工具进行</span><br><span class="line">tar –czf dump.tar.gz dump.hprof</span><br><span class="line"></span><br><span class="line">3. 确认进程创建的线程数，以及网络连接数，如果资源耗尽，也可能出现OOM</span><br><span class="line">ll &#x2F;proc&#x2F;17306&#x2F;fd | wc -l</span><br><span class="line">ll &#x2F;proc&#x2F;17306&#x2F;task | wc -l</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="如何防止线上问题发生"><a href="#如何防止线上问题发生" class="headerlink" title="如何防止线上问题发生"></a>如何防止线上问题发生</h3><blockquote><p>数据库：上线一个定时监控和杀掉慢SQL的脚本。这个脚本每分钟执行一次，检测上一分钟内，有没有执行时间超过一分钟（这个阈值可以根据实际情况调整）的慢SQL，如果有大事务自己觉得该阈值的合理性，如果发现，直接杀掉这个会话</p></blockquote><blockquote><p>cpu或者内存的使用率上做报警，大于90%的时候可以dump和jstack一次，甚至jstat也可以做，然后95%的时候也同样执行一次，甚至98或者99的时候也可以做一次，这样不仅可以保留现场，同时还可以对比</p></blockquote><blockquote><p>完善的服务报错日志监控，可选elfk+日志监控或sentry</p></blockquote><blockquote><p>完善的流程机制。完善的主机，中间件监控报警机制</p></blockquote><h3 id="遇到过的线上问题以及解决思路"><a href="#遇到过的线上问题以及解决思路" class="headerlink" title="遇到过的线上问题以及解决思路"></a>遇到过的线上问题以及解决思路</h3><blockquote><p><a href="https://link.juejin.cn/?target=https://chenyongjun.vip/articles/76">Zuul 网关不响应任何请求，zuul假死</a></p></blockquote><blockquote><p>App打不开，请求超时，访问数据库超时，数据库cpu飙升有规律，在某个时间点才飙升，去调度中心找该时间断的的定时任务，排查是异步转账开多了线程导致的</p></blockquote><h3 id="工具汇总"><a href="#工具汇总" class="headerlink" title="工具汇总"></a>工具汇总</h3><ul><li>去哪儿bistour</li><li>mat 分析堆快照</li><li>arthas <a href="https://link.juejin.cn/?target=https://arthas.aliyun.com/doc/quick-start.html">arthas.aliyun.com/doc/quick-s…</a></li><li><a href="https://link.juejin.cn/?target=https://gceasy.io">gceasy.io</a> #在线gc日志，dump文件分析</li><li><a href="https://link.juejin.cn/?target=https://fastthread.io">fastthread.io</a> #在线gc日志，dump文件分析</li><li><a href="https://link.juejin.cn/?target=https://console.perfma.com">console.perfma.com</a> #在线生成jvm参数</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://link.juejin.cn/?target=https://www.bbsmax.com/A/6pdD7b2X5w/">www.bbsmax.com/A/6pdD7b2X5…</a></li><li><a href="https://link.juejin.cn/?target=https://cloud.tencent.com/developer/article/1600345">cloud.tencent.com/developer/a…</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定位问题的先决条件&quot;&gt;&lt;a href=&quot;#定位问题的先决条件&quot; class=&quot;headerlink&quot; title=&quot;定位问题的先决条件&quot;&gt;&lt;/a&gt;定位问题的先决条件&lt;/h3&gt;&lt;p&gt;需要有详细的日志记录，提前告警的监控平台，事发现场保留&lt;/p&gt;
&lt;blockquot</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>bitMap讲解</title>
    <link href="https://leslieaibin.github.io/2021/12/14/java%E5%9F%BA%E7%A1%80/bitMap%E8%AE%B2%E8%A7%A3/"/>
    <id>https://leslieaibin.github.io/2021/12/14/java%E5%9F%BA%E7%A1%80/bitMap%E8%AE%B2%E8%A7%A3/</id>
    <published>2021-12-14T01:15:42.000Z</published>
    <updated>2021-12-14T14:59:51.979Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><ol><li>在实际项目中，我们经常需要聚合统计，比如统计一个年龄在20-30，喜欢看技术书籍，喜欢听音乐，喜欢宅在家的程序员等等一系列标签的用户。 如果使用mysql求并集，首先语句随着标签变长而变长，其次聚合，分组，去重严重影响语句性能。这种情况如何解决？</li><li>比如现在比较火的面试题，在10亿整数中找出100个重复的数，或者任意给定一个整数，判断是否在这个10亿数中。</li></ol><h3 id="bitMap原理"><a href="#bitMap原理" class="headerlink" title="bitMap原理"></a>bitMap原理</h3><p>bitMap就是使用bit位来标记元素，key为该元素，value一般为0或者1，大大节省存储空间.</p><p>现在有(2, 3, 4, 5，7)5个数，任意给定一个在0-7范围内的数字，判断是否在此集合中：</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20211214225035132.png" alt="image-20211214225035132"></p><ul><li><p>创建一个范围为(0-7)的Byte类型数组，将集合数字对应数组的bit位置置1；</p></li><li><p>然后遍历该Byte数组，如果Byte数组位置为1即代表该数存在。</p></li><li><p>同理对于10亿整数也可以这样处理，一个int型数字4个字节，32bit，如果使用bit标记正整数，就可以节省32倍的内存空间。</p></li><li><p>10亿数字，40亿字节，320亿bit，需要大约4g内存，使用bitMap标记，只需要125M内存空间即可存储，大大节省内存空间。</p></li></ul><p>以上和桶排序排序的思想非常相似。</p><h3 id="bitMap实际运用"><a href="#bitMap实际运用" class="headerlink" title="bitMap实际运用"></a>bitMap实际运用</h3><p>对于1千万数据，判断任意给定的数是否在其中？<br> 分治思想<br> 使用int数组作为bitMap。<br> 将数组分成32组，每组内有(0-31)个位置，如果给定数组在指定数组中的bit是0，则不存在。</p><ol><li>求十进制数在对应数组a中的下标<br> a[i] = a[N/32]</li><li>求int[]中bit位置<br> index = a[i] % 32</li></ol><p>上述两个运算可以改成位运算，因为位运算的效率非常高，占用cpu的时钟周期非常少。<br> 结论：对于2的倍数，%2^n = &amp;(2^n-1),模运算等于与预算，例：a % 16 = a &amp; 15,这里的15做与运算时需要化成16进制，即0x0F.</p><p>在10000000个范围为[1-100000]数中，给定指定一个数，判断是否在这个集合中</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMapActual</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1千万数据集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bitmap数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[N/<span class="number">32</span> + <span class="number">1</span>]; <span class="comment">//int 等于32个bit 所以数据长度为(N/32+1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为集合数据加标记</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addValue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定位数组编号 相当于n/32</span></span><br><span class="line">        <span class="keyword">int</span> row = n &gt;&gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定位数组内slot位置 相当于n%32</span></span><br><span class="line">        <span class="keyword">int</span> offset = n &amp; <span class="number">0x1F</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组slot置1</span></span><br><span class="line">        a[row] |= <span class="number">1</span> &lt;&lt; offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断给定数字是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定位数组编号</span></span><br><span class="line">        <span class="keyword">int</span> row = n &gt;&gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定位数组内slot位置</span></span><br><span class="line">        <span class="keyword">int</span> offset = n &amp; <span class="number">0x1F</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 &lt;&lt; position 将a[i]中左移position求与,slot位置有值返回true</span></span><br><span class="line">        <span class="keyword">return</span> (a[row] &amp; ( <span class="number">1</span> &lt;&lt; offset)) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一个长度为N的数组</span></span><br><span class="line">        <span class="keyword">int</span> num[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//随机数范围是(0-100000)</span></span><br><span class="line">            <span class="keyword">int</span> item = random.nextInt(<span class="number">100000</span>);</span><br><span class="line">            num[i] = item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BitMapActual map = <span class="keyword">new</span> BitMapActual();</span><br><span class="line">        <span class="comment">//置1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            map.addValue(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.exits(temp))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;temp:&quot;</span> + temp + <span class="string">&quot;has already exists&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;temp:&quot;</span> + temp + <span class="string">&quot;has no exists&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;小知识&quot;&gt;&lt;a href=&quot;#小知识&quot; class=&quot;headerlink&quot; title=&quot;小知识&quot;&gt;&lt;/a&gt;小知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在实际项目中，我们经常需要聚合统计，比如统计一个年龄在20-30，喜欢看技术书籍，喜欢听音乐，喜欢宅在家的程序员等等一系</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>反射机制</title>
    <link href="https://leslieaibin.github.io/2021/12/12/java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/"/>
    <id>https://leslieaibin.github.io/2021/12/12/java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/</id>
    <published>2021-12-12T01:15:42.000Z</published>
    <updated>2022-02-14T08:38:32.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC框架手撕之路—java反射以及动态代理机制"><a href="#RPC框架手撕之路—java反射以及动态代理机制" class="headerlink" title="RPC框架手撕之路—java反射以及动态代理机制"></a>RPC框架手撕之路—java反射以及动态代理机制</h1><p>在上一篇文章中，我们提到了，RPC框架所需要的java基础，第一点就是java的动态代理机制，动态代理机制的基础是反射，无论是在实际编程或者是面试时，都是java知识的重中之重。</p><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>在运行状态中，对于任意一个类，都能够知道这一个类的所有属性和方法，对于任意一个对象都能够通过反射机制调用一个类的任意方法，这种动态获取类信息以及动态调用类方法的功能称为java的反射机制。</p><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>1、动态的创建类的实例，将类绑定到现有对象中，或从现有对象中获取类型。 2、应用程序需要在运行时从某个特定的程序集中载入一个特定的类。</p><p>个人理解的反射机制就是，某些类在程序运行的一开始并没有加载，但是随着程序的运行，我们发现这些类也需要用到，此时就可以通过反射机制，来获取到类的属性和方法。</p><h2 id="代理模式："><a href="#代理模式：" class="headerlink" title="代理模式："></a>代理模式：</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>委托模式，是为某个对象提供一个代理对象，并且由代理对象控制对原对象的访问。代理模式通俗来讲就是我们生活中常见的中介。代理模式可以提供非常好的访问控制，应用比较广泛。</p><p>而其中的代理模式中的动态代理不仅在rpc远程访问中有重要的应用，同样在Spring AOP和其他应用中也起到了很重要的作用。</p><p>代理模式的通用类图：</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-hello-world.oss-cn-beijing.aliyuncs.com/imgs/173d2f9e1a2f5a8f6d0010cb64a7677c.png"></p><p><strong>Subject：</strong> 抽象主题角色：可以是抽象类，也可以是接口。抽象主题是一个普通的业务类型，无特殊要求。</p><p><strong>RealSubject：</strong> 具体主题角色：也叫做被委托角色或被代理角色，是业务逻辑的具体执行者。</p><p><strong>Proxy：</strong> 代理主题角色：也叫做委托类或代理类。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后处理工作。</p><p>按照代理创建的时期来进行分类，可以分为动态代理和静态代理。</p><h3 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h3><p>一个代理类只能实现一种抽象主题角色，在程序运行之前，代理类.class文件就已经被创建，代理类和委托类的关系在运行前就确定。</p><h3 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h3><p>一个代理类通过反射机制，可以实现多种不类型的抽象主题角色。动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。以下为动态代理概括图： <img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-hello-world.oss-cn-beijing.aliyuncs.com/imgs/cb919ba78df42f8a74cbc96a317ed2d1.png"></p><p>实现代码块如下：</p><p><strong>抽象角色类实现</strong>(动态代理的抽象决策类只能使用接口)：</p><pre><code>public interface Subject &#123;    /**     * 接口方法，抽象主题类     */    public void request();&#125;</code></pre><p><strong>具体决策类实现：</strong></p><pre><code>public class ConcreteSubject implements Subject&#123;    /**     * 具体业务实现逻辑     */    @Override    public void request() &#123;        //业务处理逻辑        System.out.println(&quot;逻辑执行&quot;);    &#125;&#125;</code></pre><p><strong>动态创建代理对象的类</strong>(代理类，使用反射机制):</p><pre><code>import lombok.extern.slf4j.Slf4j;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;</code></pre><p>​<br>    public class ProxyHandler implements InvocationHandler {<br>        /**<br>         *<br>         * @param proxy<br>         * @param method<br>         * @param args<br>         * @return<br>         * @throws Throwable<br>         */</p><pre><code>    /**     *目标对象     */    private Object target;    /**     */    public Object newProxyInstance(Object target)&#123;       this.target = target;       Object result = Proxy.newProxyInstance(target.getClass().getClassLoader(),               target.getClass().getInterfaces(),this);       return result;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        //TODO原对象方法调用添加的预处理逻辑        Object ret = null;        try&#123;            //调用目标方法            ret = method.invoke(target, args);        &#125;catch (Exception e)&#123;            //log(&quot;调用&#123;&#125;.&#123;&#125;发生异常&quot;, target.getClass().getName(), method.getName(), e);            throw e;        &#125;        return ret;    &#125;&#125;</code></pre><p><strong>客户端类</strong>：</p><pre><code>import lombok.extern.slf4j.Slf4j;import java.util.logging.Logger;</code></pre><p>​<br>    public class Client {<br>        public static void main(String[] args){<br>            System.out.println(“开始”);<br>            ProxyHandler handler = new ProxyHandler();<br>            Subject subject = (Subject) handler.newProxyInstance(new ConcreteSubject());<br>            subject.request();<br>            System.out.println(“结束”);<br>        }<br>    }</p><p>运行结果： <img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-hello-world.oss-cn-beijing.aliyuncs.com/imgs/943b059667471fd616a3c403f1f574b0.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RPC框架手撕之路—java反射以及动态代理机制&quot;&gt;&lt;a href=&quot;#RPC框架手撕之路—java反射以及动态代理机制&quot; class=&quot;headerlink&quot; title=&quot;RPC框架手撕之路—java反射以及动态代理机制&quot;&gt;&lt;/a&gt;RPC框架手撕之路—java</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis缓存与数据库一致性问题</title>
    <link href="https://leslieaibin.github.io/2021/11/30/Redis/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%20Redis%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/"/>
    <id>https://leslieaibin.github.io/2021/11/30/Redis/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%20Redis%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/</id>
    <published>2021-11-30T01:15:42.000Z</published>
    <updated>2021-12-08T15:17:18.413Z</updated>
    
    <content type="html"><![CDATA[<p>在做系统优化时，想到了将数据进行分级存储的思路。因为在系统中会存在一些数据，有些数据的实时性要求不高，比如一些配置信息。</p><p>基本上配置了很久才会变一次。而有一些数据实时性要求非常高，比如订单和流水的数据。所以这里根据数据要求实时性不同将数据分为三级。</p><ul><li>第1级：订单数据和支付流水数据；这两块数据对实时性和精确性要求很高，所以不添加任何缓存，读写操作将直接操作数据库。</li><li>第2级：用户相关数据；这些数据和用户相关，具有读多写少的特征，所以我们使用redis进行缓存。</li><li>第3级：支付配置信息；这些数据和用户无关，具有数据量小，频繁读，几乎不修改的特征，所以我们使用本地内存进行缓存。</li></ul><p>但是只要使用到缓存，无论是本地内存做缓存还是使用 redis 做缓存，那么就会存在数据同步的问题，因为配置信息缓存在内存中，而内存时无法感知到数据在数据库的修改。这样就会造成数据库中的数据与缓存中数据不一致的问题。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>那么我们这里列出来所有策略，并且讨论他们优劣性。</p><ul><li><p>先更新数据库，后更新缓存</p></li><li><p>先更新数据库，后删除缓存</p></li><li><p>先更新缓存，后更新数据库</p></li><li><p>先删除缓存，后更新数据库</p></li></ul><h4 id="先更新数据库，后更新缓存"><a href="#先更新数据库，后更新缓存" class="headerlink" title="先更新数据库，后更新缓存"></a>先更新数据库，后更新缓存</h4><p>这种场景一般是没有人使用的，主要原因是在更新缓存那一步，为什么呢？因为有的业务需求缓存中存在的值并不是直接从数据库中查出来的，有的是需要经过一系列计算来的缓存值，那么这时候后你要更新缓存的话其实代价是很高的。如果此时有大量的对数据库进行写数据的请求，但是读请求并不多，那么此时如果每次写请求都更新一下缓存，那么性能损耗是非常大的。</p><p>举个例子比如在数据库中有一个值为 1 的值，此时我们有 10 个请求对其每次加一的操作，但是这期间并没有读操作进来，如果用了先更新数据库的办法，那么此时就会有十个请求对缓存进行更新，会有大量的冷数据产生，如果我们不更新缓存而是删除缓存，那么在有读请求来的时候那么就会只更新缓存一次。</p><h4 id="先更新缓存，后更新数据库"><a href="#先更新缓存，后更新数据库" class="headerlink" title="先更新缓存，后更新数据库"></a>先更新缓存，后更新数据库</h4><p>这一种情况应该不需要我们考虑了吧，和第一种情况是一样的。</p><h4 id="先删除缓存，后更新数据库"><a href="#先删除缓存，后更新数据库" class="headerlink" title="先删除缓存，后更新数据库"></a>先删除缓存，后更新数据库</h4><p>该方案也会出问题，具体出现的原因如下。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078252.png" alt="先删除缓存，后更新数据库"></p><p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p><ol><li>请求 A 会先删除 Redis 中的数据，然后去数据库进行更新操作</li><li>此时请求 B 看到 Redis 中的数据时空的，会去数据库中查询该值，补录到 Redis 中</li><li>但是此时请求 A 并没有更新成功，或者事务还未提交</li></ol><p>那么这时候就会产生数据库和 Redis 数据不一致的问题。如何解决呢？其实最简单的解决办法就是延时双删的策略。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078256.png" alt="延时双删"></p><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。具体步骤是：</p><ul><li>先删除缓存</li><li>再写数据库</li><li>休眠500毫秒（根据具体的业务时间来定）</li><li>再次删除缓存。</li></ul><p>但是上述的保证事务提交完以后再进行删除缓存还有一个问题，就是如果你使用的是 Mysql 的读写分离的架构的话，那么其实主从同步之间也会有时间差。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078251.png" alt="主从同步时间差"></p><p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p><ol><li>请求 A 更新操作，删除了 Redis</li><li>请求主库进行更新操作，主库与从库进行同步数据的操作</li><li>请 B 查询操作，发现 Redis 中没有数据</li><li>去从库中拿去数据</li><li>此时同步数据还未完成，拿到的数据是旧数据</li></ol><p>此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078255.png" alt="从主库中拿数据"></p><h4 id="先更新数据库，后删除缓存"><a href="#先更新数据库，后删除缓存" class="headerlink" title="先更新数据库，后删除缓存"></a>先更新数据库，后删除缓存</h4><p>问题：这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078254.png" alt="先更新数据库，后删除缓存"></p><p>此时解决方案就是利用消息队列进行删除的补偿。具体的业务逻辑用语言描述如下：</p><ol><li>请求 A 先对数据库进行更新操作</li><li>在对 Redis 进行删除操作的时候发现报错，删除失败</li><li>此时将Redis 的 key 作为消息体发送到消息队列中</li><li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</li></ol><p>但是这个方案会有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000039078253.png" alt="利用订阅 binlog 删除缓存"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每种方案各有利弊，比如在第三种先删除缓存，后更新数据库这个方案我们最后讨论了要更新 Redis 的时候强制走主库查询就能解决问题，那么这样的操作会对业务代码进行大量的侵入，但是不需要增加的系统，不需要增加整体的服务的复杂度。</p><p>最后一种方案我们最后讨论了利用订阅 binlog 日志进行搭建独立系统操作 Redis，这样的缺点其实就是增加了系统复杂度。其实每一次的选择都需要我们对于我们的业务进行评估来选择，没有一种技术是对于所有业务都通用的。没有最好的，只有最适合我们的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在做系统优化时，想到了将数据进行分级存储的思路。因为在系统中会存在一些数据，有些数据的实时性要求不高，比如一些配置信息。&lt;/p&gt;
&lt;p&gt;基本上配置了很久才会变一次。而有一些数据实时性要求非常高，比如订单和流水的数据。所以这里根据数据要求实时性不同将数据分为三级。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>超卖问题</title>
    <link href="https://leslieaibin.github.io/2021/11/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E8%B6%85%E5%8D%96%E8%AE%A8%E8%AE%BA/"/>
    <id>https://leslieaibin.github.io/2021/11/18/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E8%B6%85%E5%8D%96%E8%AE%A8%E8%AE%BA/</id>
    <published>2021-11-17T16:15:42.000Z</published>
    <updated>2022-02-12T12:29:10.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见写法安全性及效率分析"><a href="#常见写法安全性及效率分析" class="headerlink" title="常见写法安全性及效率分析"></a>常见写法安全性及效率分析</h1><p>假设我们的商品表的schema是下面这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`goods`</span> (<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span><span class="string">``</span><span class="string">` `</span><span class="string">&#x27;自增id&#x27;</span><span class="string">``</span>,<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span><span class="string">``</span><span class="string">` `</span><span class="string">&#x27;&#x27;</span><span class="string">` `</span><span class="keyword">COMMENT</span><span class="string">` `</span><span class="string">&#x27;商品名称&#x27;</span><span class="string">``</span>,<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="string">`available`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span><span class="string">``</span><span class="string">` `</span><span class="string">&#x27;0&#x27;</span><span class="string">` `</span><span class="keyword">COMMENT</span><span class="string">` `</span><span class="string">&#x27;库存剩余量&#x27;</span><span class="string">``</span>,<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="string">`stock`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span><span class="string">``</span><span class="string">` `</span><span class="string">&#x27;0&#x27;</span><span class="string">` `</span><span class="keyword">COMMENT</span><span class="string">` `</span><span class="string">&#x27;总库存量&#x27;</span><span class="string">``</span>,<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">``</span><span class="string">&#x27;商品表&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="设置为字段无符号解决"><a href="#设置为字段无符号解决" class="headerlink" title="设置为字段无符号解决"></a>设置为字段无符号解决</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="keyword">select</span> available <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line">if(num &gt; 0)&#123;</span><br><span class="line">   affectRows = udpate goods <span class="keyword">set</span> available = available - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line">   if(affectRows == 1)&#123;</span><br><span class="line">       return ok ;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       return fatal ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这种做法大家的想法是我们将库存字段设置成无符号类型，这样当库存字段在sql执行时候被置为负数的时候mysql就会报错，那么affectRow就会是0或者可以捕获到这个异常，从而实现并发下的数据安全。</strong></p><h4 id="解法释义"><a href="#解法释义" class="headerlink" title="解法释义"></a>解法释义</h4><p>实际上这段代码是危险的，因为在不同版本的mysql和配置下，这段代码的表现完全不同。具体的情况会出现3种不同的结果：</p><ul><li>  代码正常运行，执行update的时候报错</li><li>  代码最终执行结果出现了 -1</li><li>  最终update操作之后，available变成了一个很大的数目</li></ul><p>为什么会出现这三种情况呢？</p><p>我想在学习开始学习计算机的时候都讲过计算机的加减法计算方法。</p><p><code>思考一下，无符号2 减去 无符号3 在计算机中的运算是什么样的？</code></p><p><code>2 - 3 = 2 + (-3)</code></p><p><code>假设我们的计算机是4位的,2的补码表示:0010,-3的补码表示为1011</code></p><p><code>那么加和的结果是</code></p><p><code>0010</code></p><p><code>1011 +</code></p><p><code>------</code></p><p><code>1111 =</code></p><p><code>1111解释为有符号数是多少呢？ -1</code></p><p><code>1111解释为无符号数是多少呢？ 15</code></p><p>所以呢？如果mysql不做任何处理的话，你的无符号数减法的结果不会报错，最终你算出来的库存还是一个非常大的值(可怕)。<br>但是幸运的是mysql 后来的版本帮你做了这件事情(具体哪个版本我也不清楚)，所以如果是mysql做了无符号检测的话，如果减出的结果是负值，会报错，这是大多数人期待的结果。-1这种情况是需要你设置一下sqlmode的，这也是会出现的情况。</p><h4 id="解法总结"><a href="#解法总结" class="headerlink" title="解法总结"></a>解法总结</h4><ul><li>  这个办法很多人用的时候没问题，那只能说明可能是机缘巧合，但是对于业务代码而言，不能靠碰运气，需要消除不确定性、缩小迁移成本。</li><li>  如果你想采用这种办法，辛苦你把你们msyql相应的版本及配置搞清楚，确定无符号在你所在的版本会出现什么结果。</li></ul><h2 id="select-for-update（感觉并不能保证原子性）"><a href="#select-for-update（感觉并不能保证原子性）" class="headerlink" title="select for update（感觉并不能保证原子性）"></a>select for update（感觉并不能保证原子性）</h2><h4 id="解法释义-1"><a href="#解法释义-1" class="headerlink" title="解法释义"></a>解法释义</h4><p>读取时候就开始加排他锁也是网上常见的办法之一，具体实现如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran ;</span><br><span class="line">num = <span class="keyword">select</span> avaliable <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xxx <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">if (num &gt;= 0)&#123;</span><br><span class="line">   affectNum = udpate goods <span class="keyword">set</span> available = available - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line">   <span class="keyword">commit</span> ;</span><br><span class="line"> return affectNum ;</span><br><span class="line">&#125;else&#123;</span><br><span class="line"> <span class="keyword">rollback</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该解法在用户读取的时候对相应的数据加排他锁，保证自己在更新的时候该行的数据不会被别的进程更改.所有写请求及排他锁加锁都会被阻塞。</p><p>想想这样的情况，A进程执行过程中，出现死机的情况导致commit/rollback请求没有被发送到mysqlserver，那么所有请求都会锁等待。</p><h4 id="解法总结-1"><a href="#解法总结-1" class="headerlink" title="解法总结"></a>解法总结</h4><ul><li><p>  低流量可以采用这种办法来保证数据的安全性</p></li><li><p>性能低下，平均需要发送4次mysql请求，同时会造成所有同类请求锁等待。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3></li><li><p>  select for udpate 需要在显式的指定在事务代码块执行，不然不会起作用。很多网友都理所当然的人为select for update直接就可以加排他锁</p></li><li><p>  排他锁的释放是在rollback/commit 动作完成才会释放，不是在update操作之后。mysql innodb执行两段锁协议，加锁阶段只加锁，解锁阶段只解锁。</p></li></ul><h2 id="采用事务，先查后写再查，确保没问题"><a href="#采用事务，先查后写再查，确保没问题" class="headerlink" title="采用事务，先查后写再查，确保没问题"></a>采用事务，先查后写再查，确保没问题</h2><h4 id="解法释义-2"><a href="#解法释义-2" class="headerlink" title="解法释义"></a>解法释义</h4><p>这时候的available设置为有符号类型，解决方案一的问题</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tran ;</span><br><span class="line"></span><br><span class="line">num = <span class="keyword">select</span> available <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line"></span><br><span class="line">if(num &gt; 0)&#123;</span><br><span class="line">   //实际需要关心这里的返回值，这里不考虑</span><br><span class="line"></span><br><span class="line">   udpate goods <span class="keyword">set</span> available = available - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line"></span><br><span class="line">   num_afterupdate = <span class="keyword">select</span> available <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xx ;</span><br><span class="line"></span><br><span class="line">   if(num_afterupdate &lt; 0 )&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">rollback</span> ;</span><br><span class="line"></span><br><span class="line">   &#125;else&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">commit</span> ;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解法区分于第一种的办法在于，加了事务、available类型更改、采用了更新后确认的形式，尝试解决问题。</p><p>我们都知道数据库的事务隔离级别有4种：<br><strong>RU，RC，RR，Serializable。</strong><br>我们常见的innodb中RR模式是可以保证可重复读，意思是在同一个事务内部，多次读取的结果是一致的。那么最后一次的读取对于RR隔离级别实际上是无效的。<br>RC模式下，这个代码是可用的，每次请求可以确保自己的进程不会超发。</p><h4 id="解法总结-2"><a href="#解法总结-2" class="headerlink" title="解法总结"></a>解法总结</h4><ul><li>  RR、RC模式下结果不一致.RR下不可保证安全、RC可以。</li><li>  性能不高，一次业务请求到mysql的转化为 1 : 5。</li><li>  这种解法就像老奶奶锁门，总是不放心自己到底锁了没有，走了几步再回来看看，实际上有些时候是徒劳。</li></ul><h2 id="update语句增加available查询条件"><a href="#update语句增加available查询条件" class="headerlink" title="update语句增加available查询条件"></a>update语句增加available查询条件</h2><h4 id="解法释义-3"><a href="#解法释义-3" class="headerlink" title="解法释义"></a>解法释义</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udpate goods <span class="keyword">set</span> available = available - <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = xx<span class="string">` `</span><span class="keyword">and</span><span class="string">` `</span>available - <span class="number">1</span> &gt;= <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p>大家有的另一个误区是单条语句不是事务，实际上单条sql也是一个事务。-<br>问题的关键就集中在怎么证明这句的安全性的。-<br>我们都知道update操作对于id为主键索引的情况下，是会对数据加行锁。-<br>其实update操作在mysql内部也是一个先查后改的过程，这个过程如果是原子的，那么可以保证update语句是串行的，那我们就来看一下update语句在mysql内部的执行过程。-</p><p>那么对于上面这个语句，一样遵循两段锁协议。-<br>update执行的过程，会去查询满足条件的行并加锁，这个加锁是innodb做的，那么就可以保证别的事务必须等到该事务执行完了之后才能获得锁，此时拿到最新数据。</p><h4 id="解法总结-3"><a href="#解法总结-3" class="headerlink" title="解法总结"></a>解法总结</h4><ul><li>  语句安全、效率最优（我的认知里）</li></ul><h2 id="采用设置库存而不是扣减库存"><a href="#采用设置库存而不是扣减库存" class="headerlink" title="采用设置库存而不是扣减库存"></a>采用设置库存而不是扣减库存</h2><p>这几天我把类似的文章几乎翻了一遍，唯一看到批评我的上一条做法的是我的那个做法是不具备幂等性的。</p><blockquote><ul><li>  所谓幂等性就是，同一个用户对同一连接的访问不会产生副作用。比如上一条的方案，如果记录用户的操作和扣减库存不是原子操作的话，就有可能出现的问题是，库存扣减成功了，但是用户记录失败了，那么用户重复请求，就会出现多次减库存的问题。</li></ul></blockquote><p>那么他们的解法是这样的，采用设置而不是扣减，代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num_old = <span class="keyword">select</span> available <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> = xx<span class="string">` `</span><span class="keyword">and</span><span class="string">` `</span>available &gt;= <span class="number">1</span> ;</span><br><span class="line">num_new = num_old - 1 ;</span><br><span class="line"><span class="keyword">update</span> goods <span class="keyword">set</span> <span class="keyword">num</span>=num_new <span class="keyword">where</span> <span class="keyword">id</span>=xx<span class="string">` `</span><span class="keyword">and</span><span class="string">` `</span><span class="keyword">num</span>=num_old ;</span><br></pre></td></tr></table></figure><p>这段代码也是安全的，采用的是乐观锁的理念来完成的操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>  上面的做法，最后两个是相对安全的，但是你的库存字段还是要设置为无符号，关于是否幂等，要看结合请求看，不是单个扣减块代码。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>  <a href="http://hedengcheng.com/?p=771">何登成的技术博客</a>mysql udpate流程学习</li><li>  <a href="http://www.10tiao.com/html/249/201706/2651960197/1.html">幂等性做法来源</a>使用设置库存代替库存扣减</li><li>  <a href="http://www.cnblogs.com/blankqdb/archive/2012/11/03/blank_qdb.html">mysql 无符号问题</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见写法安全性及效率分析&quot;&gt;&lt;a href=&quot;#常见写法安全性及效率分析&quot; class=&quot;headerlink&quot; title=&quot;常见写法安全性及效率分析&quot;&gt;&lt;/a&gt;常见写法安全性及效率分析&lt;/h1&gt;&lt;p&gt;假设我们的商品表的schema是下面这样的：&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>消息队列幂等性</title>
    <link href="https://leslieaibin.github.io/2021/11/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%8E%E6%A0%B7%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>https://leslieaibin.github.io/2021/11/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%8E%E6%A0%B7%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7/</id>
    <published>2021-11-12T01:15:42.000Z</published>
    <updated>2022-02-13T10:53:38.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ消费幂等性"><a href="#RabbitMQ消费幂等性" class="headerlink" title="RabbitMQ消费幂等性"></a>RabbitMQ消费幂等性</h2><h3 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h3><blockquote><p>幂等性，简单来说就是<strong>对于同一个系统，在同样条件下，一次请求和重复多次请求对资源的影响是一致的，就称该操作为幂等的</strong>。比如说如果有一个接口是幂等的，当传入相同条件时，其效果必须是相同的。在RabbitMQ中消费幂等就是指给消费者发送多条同样的消息，消费者只会消费其中的一条。例如，在一次购物中提交订单进行支付时，当网络延迟等其他问题造成消费者重新支付，如果没有幂等性的支持，那么会对同一订单进行两次扣款，这是非常严重的，因此有了幂等性，当对同一个订单进行多次支付时，可以确保只对同一个订单扣款一次。</p></blockquote><h3 id="RabbitMQ消费幂等性-1"><a href="#RabbitMQ消费幂等性-1" class="headerlink" title="RabbitMQ消费幂等性"></a>RabbitMQ消费幂等性</h3><p>在正常情况下，消费者在消费消息的时候，当消费完毕后，会发送一个确认ack给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。而在前面保证生产端消息可靠性投递方案1中，当生产者发送消息给RabbitMQ后，在Broker返回确认ack之前，RabbitMQ出现了宕机（数据库保存的消息状态仍然为<code>“投递中”</code>），则该消息会被定时任务抓取并重新发送；或者当在网络延迟传输中，消费者出现异常或者消费者延迟消费，会造成进行RabbitMQ重试补偿，那么此时RabbitMQ中就可能会有两条消息，会造成消费者重复消费，此时消费端就需要做幂等性校验，让消费者只消费其中一条消息。实现消费端幂等性、保证同一消息不被重复消费下面介绍一种简单的方案。</p><ul><li><p>为了保证消息不被重复消费，首先要保证每个消息是唯一的，所以可以给每一个消息携带一个唯一的id，流程如下：</p><p>  1、消费者监听到消息后获取消息的MsgId（这个MsgId是我们自定义消息的字段，是主键），先去Redis中查询这个MsgId是否存在。也可以生产者发送消息时指给消息对象设置唯一的 MessageID，只有该 MessageID 没有被消费者存入到Redis中即该消息未被消费，这样重发的消息才能在重试机制中再次被消费。</p><p>  2、如果不存在，则正常消费消息，并把消息的id存入Redis中。</p><p>  3、如果存在则丢弃或者拒绝此消息并不返回队列。</p></li><li><p>代码：</p><p>  1.消费者</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessageFromQueue1</span><span class="params">(Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SetOperations&lt;String, Object&gt; ops = redisTemplate.opsForSet();</span><br><span class="line">    <span class="comment">//获取唯一Id</span></span><br><span class="line">    String msgID = message.getMessageProperties().getHeader(</span><br><span class="line">            <span class="string">&quot;spring_returned_message_correlation&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ops.pop(msgID)!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//该订单已经完成扣款，无需再进行扣款</span></span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行扣款操作</span></span><br><span class="line">        ..</span><br><span class="line">        ..</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将对应的订单id保存到redis中         </span></span><br><span class="line">        ops.add(msgID,<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回确认ack</span></span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      </span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="消息队列如何限流？"><a href="#消息队列如何限流？" class="headerlink" title="消息队列如何限流？"></a>消息队列如何限流？</h2><p>消息队列限流是指在服务器面临巨额流量时，为了进行自保，进行的一种救急措施。</p><p>因为巨大的流量代表着非常多的消息，这些消息如果多到服务器处理不过来就会造成服务器瘫痪，影响用户体验，造成不良影响。</p><p>所以要进行一次降级操作，把处理不了的流量隔绝在系统之外，避免它们打垮系统。</p><p>基本上任何一个消息队列都有限流的功能，今天我们就来看看在<code>RabbitMQ</code>之中进行限流具体应该怎么做？</p><p>RabbitMQ提供了一种<code>QOS</code>(服务质量保证)功能，即在非自动确认消息的前提下，如果一定数目的消息还未被消费确认，则不进行新消息的消费。</p><h2 id="TTL消息-队列"><a href="#TTL消息-队列" class="headerlink" title="TTL消息/队列"></a>TTL消息/队列</h2><p><code>TTL</code>是Time To Live的缩写，也就是生存时间的意思，<code>RabbitMQ</code>支持消息的过期时间，在消息发送时可以进行指定，也支持队列的过期时间，从消息入队列开始计算，只要超过了队列的超时时间配置，那么消息会自动的清除。</p><p>设置队列的话就是整个队列的消息到时都会过期，设置消息的话就是单条消息到时自动过期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TTL队列示例</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">ttlQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置3s过期</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topicQueue1&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码就是演示如何创建一个TTL队列，需要放入参数才行，队列构造中的其他参数我为了方便直接填了false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTtl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String message = <span class="string">&quot;Hello 我是作者和耳朵，欢迎关注我。&quot;</span> + LocalDateTime.now().toString();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Message content : &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置过期3s</span></span><br><span class="line">    MessageProperties props = MessagePropertiesBuilder.newInstance()</span><br><span class="line">            .setExpiration(<span class="string">&quot;3000&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.send(Producer.QUEUE_NAME,<span class="keyword">new</span> Message(message.getBytes(StandardCharsets.UTF_8),props));</span><br><span class="line">    System.out.println(<span class="string">&quot;消息发送完毕。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="DLX死信队列"><a href="#DLX死信队列" class="headerlink" title="DLX死信队列"></a>DLX死信队列</h2><p><code>DLX死信队列</code>虽然叫队列，但其实指的是<code>Exchange</code>，或者说指的<code>Exchange</code>和它所属的<code>Queue</code>，他俩一块构成了死信队列。</p><p>当一条消息：</p><ul><li>消费被拒绝（basic.reject/basic.nack）并且requeue=false</li><li>TTL过期</li><li>要进入的队列达到最大长度</li></ul><p>这三种情况，就可以判定一条消息死了，这种消息如果我们没有做处理，它就会被自动删除。</p><p>但其实我们可以在队列上加上一个参数，使当队列中发现了<code>死亡的消息</code>之后会将它自动转发到某个<code>Exchange</code>，由指定的<code>Exchange</code>来处理这些死亡的消息。</p><p>这个处理死亡消息的<code>Exchange</code>和之前我们讲述的<code>Exchange</code>没什么区别，依然可以绑定队列然后进行消息消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DLX队列示例</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">dlxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 指定消息死亡后发送到ExchangeName=&quot;dlx.exchange&quot;的交换机去</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,<span class="string">&quot;dlx.exchange&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;topicQueue1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上代码，就是设置了一个队列中的消息死亡后的去处，就等于消息死亡后给它不把它删掉而是做一次转发，发到其他<code>Exchange</code>去。</p><p>那这样搞有什么用呢？这就取决于业务需求了，不过下一节会用到它，接着往下看~</p><h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2><p><code>RabbitMQ</code>的基因中没有延时队列这回事，它不能直接指定一个队列类型为延时队列，然后去延时处理，但是经过上面两节的铺垫，我们可以将TTL+DLX相结合，这就能组成一个延时队列。</p><p>设想一个场景，下完订单之后15分钟未付款我们就要将订单关闭，这就是一个很经典的演示消费的场景，如果拿<code>RabbitMQ</code>来做，我们就需要结合TTL+DLX了。</p><p>先把订单消息设置好15分钟过期时间，然后过期后队列将消息转发给我们设置好的<code>DLX-Exchange</code>，<code>DLX-Exchange</code>再将分发给它绑定的队列，我们的消费者再消费这个队列中的消息，就做到了延时十五分钟消费。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RabbitMQ消费幂等性&quot;&gt;&lt;a href=&quot;#RabbitMQ消费幂等性&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ消费幂等性&quot;&gt;&lt;/a&gt;RabbitMQ消费幂等性&lt;/h2&gt;&lt;h3 id=&quot;什么是幂等性&quot;&gt;&lt;a href=&quot;#什么是</summary>
      
    
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>消息队列问题</title>
    <link href="https://leslieaibin.github.io/2021/11/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%A4%AA%E5%A4%9A%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>https://leslieaibin.github.io/2021/11/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%A4%AA%E5%A4%9A%E6%80%8E%E4%B9%88%E5%8A%9E/</id>
    <published>2021-11-11T01:15:42.000Z</published>
    <updated>2022-02-13T02:03:43.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MQ-的问题"><a href="#MQ-的问题" class="headerlink" title="MQ 的问题"></a>MQ 的问题</h2><p>任何技术都会有利有弊，MQ 给整体系统架构带来很多好处，但也会付出一定的代价。</p><p>MQ 主要引入了以下问题：</p><ul><li><p><strong>系统可用性降低</strong>：引入了 MQ 后，通信需要基于 MQ 完成，如果 MQ 宕机，则服务不可用。</p></li><li><p>系统复杂度提高</p><p>使用 MQ，需要关注一些新的问题：</p><ul><li>如何保证消息没有 <strong>重复消费</strong>？</li><li>如何处理 <strong>消息丢失</strong> 的问题？</li><li>如何保证传递 <strong>消息的顺序性</strong>？</li><li>如何处理大量 <strong>消息积压</strong> 的问题？</li></ul></li><li><p><strong>一致性问题</strong>：假设系统 A 处理完直接返回成功的结果给用户，用户认为请求成功。但如果此时，系统 BCD 中只要有任意一个写库失败，那么数据就不一致了。这种情况如何处理？</p></li></ul><p>下面，我们针对以上问题来一一分析。</p><h3 id="1-重复消费"><a href="#1-重复消费" class="headerlink" title="1. 重复消费"></a>1. 重复消费</h3><p><strong>如何保证消息不被重复消费</strong> 和 <strong>如何保证消息消费的幂等性</strong> 是同一个问题。</p><p>必须先明确产生重复消费的原因，才能对症下药。</p><h4 id="重复消费问题原因"><a href="#重复消费问题原因" class="headerlink" title="重复消费问题原因"></a>重复消费问题原因</h4><p>重复消费问题通常不是 MQ 来处理，而是由开发来处理的。</p><p>以 Kafka 举例，Kafka 每个 Partition 都是一个有序的、不可变的记录序列，不断追加到结构化的提交日志中。Partition 中为每条记录分配一个连续的 id 号，称为偏移量（Offset），用于唯一标识 Partition 内的记录。</p><p>Kafka 的客户端和 Broker 都会保存 Offset。客户端消费消息后，每隔一段时间，就把已消费的 Offset 提交给 Kafka Broker，表示已消费。</p><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210427194009.png" alt="img"></p><p>在这个过程中，如果客户端应用消费消息后，因为宕机、重启等情况而没有提交已消费的 Offset 。当系统恢复后，会继续消费消息，由于 Offset 未提交，就会出现重复消费的问题。</p><h4 id="重复消费解决方案"><a href="#重复消费解决方案" class="headerlink" title="重复消费解决方案"></a>重复消费解决方案</h4><p>应对重复消费问题，需要在业务层面，通过 <strong>幂等性设计</strong> 来解决。</p><p>MQ 重复消费不可怕，可怕的是没有应对机制，可以借鉴的思路有：</p><ul><li>如果是写关系型数据库，可以先根据主键查询，判断数据是否已存在，存在则更新，不存在则插入；</li><li>如果是写 Redis，由于 set 操作天然具有幂等性，所以什么都不用做；</li><li>如果是根据消息做较复杂的逻辑处理，可以在消息中加入全局唯一 ID，例如：订单 ID 等。在客户端存储中（Mysql、Redis 等）保存已消费消息的 ID。一旦接受到新消息，先判断消息中的 ID 是否在已消费消息 ID 表中存在，存在则不再处理，不存在则处理。</li></ul><p>在实际开发中，可以参考上面的例子，结合现实场景，设计合理的幂等性方案。</p><h3 id="2-消息丢失"><a href="#2-消息丢失" class="headerlink" title="2. 消息丢失"></a>2. 消息丢失</h3><p><strong>如何处理消息丢失的问题</strong> 和 <strong>如何保证消息不被重复消费</strong> 是同一个问题。关注点有：</p><ul><li>MQ Server 丢失数据</li><li>消费方丢失数据</li><li>生产方丢失数据</li></ul><h4 id="消费方丢失数据"><a href="#消费方丢失数据" class="headerlink" title="消费方丢失数据"></a>消费方丢失数据</h4><p>唯一可能导致消费方丢失数据的情况是：消费方设置了<strong>自动提交 Offset</strong>。一旦设置了自动提交 Offset，接受到消息后就会自动提交 Offset 给 Kafka ，Kafka 就认为消息已被消费。如果此时，消费方尚未来得及处理消息就挂了，那么消息就丢了。</p><p>解决方法就是：消费方关闭自动提交 Offset，处理完消息后<strong>手动提交 Offset</strong>。但这种情况下可能会出现重复消费的情形，需要自行保证幂等性。</p><h4 id="RabbitMq弄丢了数据"><a href="#RabbitMq弄丢了数据" class="headerlink" title="RabbitMq弄丢了数据"></a><strong>RabbitMq弄丢了数据</strong></h4><p>就是 RabbitMQ 自己弄丢了数据，这个你必须<strong>开启 RabbitMQ 的持久化</strong>，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，<strong>恢复之后会自动读取之前存储的数据</strong>，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，<strong>可能导致少量数据丢失</strong>，但是这个概率较小。</p><p>设置持久化有<strong>两个步骤</strong>：</p><ul><li>创建 queue 的时候将其设置为持久化<br>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li><li>第二个是发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2<br>就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li></ul><p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p><p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p><p>所以，持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code>，你也是可以自己重发的。</p><h4 id="生产方丢失数据"><a href="#生产方丢失数据" class="headerlink" title="生产方丢失数据"></a>生产方丢失数据</h4><p>如果按照上述的思路设置了 <code>acks=all</code>，生产方一定不会丢数据。</p><p>要求是，你的 Leader 接收到消息，所有的 Follower 都同步到了消息之后，才认为本生产消息成功了。如果未满足这个条件，生产者会自动不断的重试，重试无限次。</p><h3 id="3-消息的顺序性"><a href="#3-消息的顺序性" class="headerlink" title="3. 消息的顺序性"></a>3. 消息的顺序性</h3><p>要保证 MQ 的顺序性，势必要付出一定的代价，所以实施方案前，要先明确业务场景是不是有必要保证消息的顺序性。只有那些明确对消息处理顺序有要求的业务场景才值得去保证消息顺序性。</p><p>方案一</p><p>一个 Topic，一个 Partition，一个 Consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</p><p>方案二</p><ul><li>写入数据到 Partition 时指定一个全局唯一的 ID，例如订单 ID。发送方保证相同 ID 的消息有序的发送到同一个 Partition。</li><li>基于上一点，消费方从 Kafka Partition 中消费消息时，此刻一定是顺序的。但如果消费方式以并发方式消费消息，顺序就可能会被打乱。为此，还有做到以下几点：<ul><li>消费方维护 N 个缓存队列，具有相同 ID 的数据都写入同一个队列中；</li><li>创建 N 个线程，每个线程只负责从指定的一个队列中取数据。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210427194215.png" alt="img"></p><h3 id="4-消息积压"><a href="#4-消息积压" class="headerlink" title="4. 消息积压"></a>4. 消息积压</h3><p>假设一个 MQ 消费者可以一秒处理 1000 条消息，三个 MQ 消费者可以一秒处理 3000 条消息，那么一分钟的处理量是 18 万条。如果 MQ 中积压了几百万到上千万的数据，即使消费者恢复了，也需要大概很长的时间才能恢复过来。</p><p>对于产线环境来说，漫长的等待是不可接受的，所以面临这种窘境时，只能临时紧急扩容以应对了，具体操作步骤和思路如下：</p><ul><li>先修复 Consumer 的问题，确保其恢复消费速度，然后将现有 Consumer 都停掉。</li><li>新建一个 Topic，Partition 是原来的 10 倍，临时建立好原先 10 倍的 Queue 数量。</li><li>然后写一个临时的分发数据的 Consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 Queue。</li><li>接着临时征用 10 倍的机器来部署 Consumer ，每一批 Consumer 消费一个临时 Queue 的数据。这种做法相当于是临时将 Queue 资源和 Consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li><li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MQ-的问题&quot;&gt;&lt;a href=&quot;#MQ-的问题&quot; class=&quot;headerlink&quot; title=&quot;MQ 的问题&quot;&gt;&lt;/a&gt;MQ 的问题&lt;/h2&gt;&lt;p&gt;任何技术都会有利有弊，MQ 给整体系统架构带来很多好处，但也会付出一定的代价。&lt;/p&gt;
&lt;p&gt;MQ 主要引入</summary>
      
    
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="https://leslieaibin.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Skip List--跳表</title>
    <link href="https://leslieaibin.github.io/2021/10/30/Redis/%E8%B7%B3%E8%A1%A8/"/>
    <id>https://leslieaibin.github.io/2021/10/30/Redis/%E8%B7%B3%E8%A1%A8/</id>
    <published>2021-10-30T01:15:42.000Z</published>
    <updated>2022-02-14T02:13:37.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Skip-List–跳表"><a href="#Skip-List–跳表" class="headerlink" title="Skip List–跳表"></a>Skip List–跳表</h1><p>跳表是一种神奇的数据结构，因为几乎所有版本的大学本科教材上都没有跳表这种数据结构，而且神书《算法导论》、《算法第四版》这两本书中也没有介绍跳表。但是跳表插入、删除、查找元素的时间复杂度跟红黑树都是一样量级的，时间复杂度都是O(logn)，而且跳表有一个特性是红黑树无法匹敌的（具体什么特性后面会提到）。所以在工业中，跳表也会经常被用到。废话不多说了，开始今天的跳表学习。</p><p>通过本文，你能 get 到以下知识：</p><ul><li>  什么是跳表？</li><li>  跳表的查找、插入、删除元素的流程</li><li>  跳表查找、插入、删除元素的时间复杂度</li><li>  跳表插入元素时，如何动态维护索引？</li><li>  为什么Redis选择使用跳表而不是红黑树来实现有序集合？</li><li>  工业上其他使用跳表的场景</li></ul><blockquote><p>友情提示：下文在跳表插入数据时，会讲述如何动态维护索引，实现比较简单，逻辑比较绕，不要放弃，加油！！！如果一遍看不懂没关系，可以选择暂时性的跳过，毕竟这块偏向于源码。但是读者必须知道跳表的查找、插入、删除的时间复杂度都是 O(logn)，而且可以按照范围区间查找元素，当工作中遇到某些场景时，需要想到可以使用跳表解决问题即可。毕竟平时的工作都是直接使用封装好的跳表，例如：java.util.concurrent 下的 ConcurrentSkipListMap()。</p></blockquote><h3 id="理解跳表，从单链表开始说起"><a href="#理解跳表，从单链表开始说起" class="headerlink" title="理解跳表，从单链表开始说起"></a>理解跳表，从单链表开始说起</h3><p>下图是一个简单的<strong>有序单链表</strong>，单链表的特性就是每个元素存放下一个元素的引用。即：通过第一个元素可以找到第二个元素，通过第二个元素可以找到第三个元素，依次类推，直到找到最后一个元素。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/37027.jpg"></p><p>跳表-原始链表.jpeg</p><p>现在我们有个场景，想快速找到上图链表中的 10 这个元素，只能从头开始遍历链表，直到找到我们需要找的元素。查找路径：1、3、4、5、7、8、9、10。这样的查找效率很低，平均时间复杂度很高O(n)。那有没有办法提高链表的查找速度呢？如下图所示，我们从链表中每两个元素抽出来，加一级索引，一级索引指向了原始链表，即：通过一级索引 7 的down指针可以找到原始链表的 7 。那现在怎么查找 10 这个元素呢？</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/60225.jpg"></p><p>跳表-一级索引.jpeg</p><p>先在索引找 1、4、7、9，遍历到一级索引的 9 时，发现 9 的后继节点是 13，比 10 大，于是不往后找了，而是通过 9 找到原始链表的 9，然后再往后遍历找到了我们要找的 10，遍历结束。有没有发现，加了一级索引后，查找路径：1、4、7、9、10，查找节点需要遍历的元素相对少了，我们不需要对 10 之前的所有数据都遍历，查找的效率提升了。</p><p>那如果加二级索引呢？如下图所示，查找路径：1、7、9、10。是不是找 10 的效率更高了？这就是跳表的思想，用“空间换时间”，通过给链表建立索引，提高了查找的效率。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/23212.jpg"></p><p>跳表-二级索引.jpeg</p><p>可能同学们会想，从上面案例来看，提升的效率并不明显，本来需要遍历8个元素，优化了半天，还需要遍历 4 个元素，其实是因为我们的数据量太少了，当数据量足够大时，效率提升会很大。如下图所示，假如有序单链表现在有1万个元素，分别是 0~9999。现在我们建了很多级索引，最高级的索引，就两个元素 0、5000，次高级索引四个元素 0、2500、5000、7500，依次类推，当我们查找 7890 这个元素时，查找路径为 0、5000、7500 … 7890，通过最高级索引直接跳过了5000个元素，次高层索引直接跳过了2500个元素，<strong>从而使得链表能够实现二分查找</strong>。由此可以看出，当元素数量较多时，索引提高的效率比较大，近似于二分查找。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/65247.jpg"></p><p>数据量增多后，索引效果图.png</p><p>到这里大家应该已经明白了什么是跳表。跳表是<strong>可以实现二分查找的有序链表</strong>。</p><h3 id="查找的时间复杂度"><a href="#查找的时间复杂度" class="headerlink" title="查找的时间复杂度"></a>查找的时间复杂度</h3><p>既然跳表可以提升链表查找元素的效率，那查找一个元素的时间复杂度到底是多少呢？查找元素的过程是从最高级索引开始，一层一层遍历最后下沉到原始链表。所以，时间复杂度 = 索引的高度 * 每层索引遍历元素的个数。</p><p>先来求跳表的索引高度。如下图所示，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/2k个元素。最高级索引一般有2个元素，即：最高级索引 h 满足 2 = n/2h，即 h = log2n - 1，最高级索引 h 为索引层的高度加上原始数据一层，跳表的总高度 h = log2n。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214100936207.png" alt="image-20220214100936207"></p><p>查找的时间复杂度证明.jpeg</p><p>我们看上图中加粗的箭头，表示查找元素 x 的路径，那查找过程中每一层索引最多遍历几个元素呢？</p><p>图中所示，现在到达第 k 级索引，我们发现要查找的元素 x 比 y 大比 z 小，所以，我们需要从 y 处下降到 k-1 级索引继续查找，k-1级索引中比 y 大比 z 小的只有一个 w，所以在 k-1 级索引中，我们遍历的元素最多就是 y、w、z，发现 x 比 w大比 z 小之后，再下降到 k-2 级索引。所以，k-2 级索引最多遍历的元素为 w、u、z。其实每级索引都是类似的道理，每级索引中都是两个结点抽出一个结点作为上一级索引的结点。 现在我们得出结论：当每级索引都是两个结点抽出一个结点作为上一级索引的结点时，每一层最多遍历3个结点。</p><p>跳表的索引高度 h = log2n，且每层索引最多遍历 3 个元素。所以跳表中查找一个元素的时间复杂度为 O(3*logn)，省略常数即：O(logn)。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>跳表通过建立索引，来提高查找元素的效率，就是典型的“空间换时间”的思想，所以在空间上做了一些牺牲，那空间复杂度到底是多少呢？</p><p>假如原始链表包含 n 个元素，则一级索引元素个数为 n/2、二级索引元素个数为 n/4、三级索引元素个数为 n/8 以此类推。所以，索引节点的总和是：n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2，**空间复杂度是 O(n)**。</p><p>如下图所示：如果每三个结点抽一个结点做为索引，索引总和数就是 n/3 + n/9 + n/27 + … + 9 + 3 + 1= n/2，减少了一半。所以我们可以通过较少索引数来减少空间复杂度，但是相应的肯定会造成查找效率有一定下降，我们可以根据我们的应用场景来控制这个阈值，看我们更注重时间还是空间。</p><p>![image-20220214100955292](/Users/leslie/Library/Application Support/typora-user-images/image-20220214100955292.png)</p><p>三个节点提取一个做索引.jpeg</p><p>But，索引结点往往只需要存储 key 和几个指针，并不需要存储完整的对象，所以当对象比索引结点大很多时，索引占用的额外空间就可以忽略了。举个例子：我们现在需要用跳表来给所有学生建索引，学生有很多属性：学号、姓名、性别、身份证号、年龄、家庭住址、身高、体重等。学生的各种属性只需要在原始链表中存储一份即可，我们只需要用学生的学号（int 类型的数据）建立索引，所以索引相对原始数据而言，占用的空间可以忽略。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入数据看起来也很简单，跳表的原始链表需要保持有序，所以我们会向查找元素一样，找到元素应该插入的位置。如下图所示，要插入数据6，整个过程类似于查找6，整个的查找路径为 1、1、1、4、4、5。查找到第底层原始链表的元素 5 时，发现 5 小于 6 但是后继节点 7 大于 6，所以应该把 6 插入到 5 之后 7 之前。整个时间复杂度为查找元素的时间复杂度 O(logn)。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101012915.png" alt="image-20220214101012915"></p><p>插入数据图示.jpeg</p><p>如下图所示，假如一直往原始列表中添加数据，但是不更新索引，就可能出现两个索引节点之间数据非常多的情况，极端情况，跳表退化为单链表，从而使得查找效率从 O(logn) 退化为 O(n)。那这种问题该怎么解决呢？我们需要在插入数据的时候，索引节点也需要相应的增加、或者重建索引，来避免查找效率的退化。那我们该如何去维护这个索引呢？</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101025149.png" alt="image-20220214101025149"></p><p>插入数据，不更新索引图示.jpeg</p><p>比较容易理解的做法就是完全重建索引，我们每次插入数据后，都把这个跳表的索引删掉全部重建，重建索引的时间复杂度是多少呢？因为索引的空间复杂度是 O(n)，即：索引节点的个数是 O(n) 级别，每次完全重新建一个 O(n) 级别的索引，时间复杂度也是 O(n) 。造成的后果是：为了维护索引，导致每次插入数据的时间复杂度变成了 O(n)。</p><p>那有没有其他效率比较高的方式来维护索引呢？假如跳表每一层的晋升概率是 1/2，最理想的索引就是在原始链表中每隔一个元素抽取一个元素做为一级索引。换种说法，<strong>我们在原始链表中随机的选 n/2 个元素做为一级索引是不是也能通过索引提高查找的效率呢？</strong> 当然可以了，因为一般随机选的元素相对来说都是比较均匀的。如下图所示，随机选择了n/2 个元素做为一级索引，虽然不是每隔一个元素抽取一个，但是对于查找效率来讲，影响不大，比如我们想找元素 16，仍然可以通过一级索引，使得遍历路径较少了将近一半。如果抽取的一级索引的元素恰好是前一半的元素 1、3、4、5、7、8，那么查找效率确实没有提升，但是这样的概率太小了。我们可以认为：当原始链表中<strong>元素数量足够大</strong>，且<strong>抽取足够随机</strong>的话，我们得到的索引是均匀的。我们要清楚设计良好的数据结构都是为了应对大数据量的场景，如果原始链表只有 5 个元素，那么依次遍历 5 个元素也没有关系，因为数据量太少了。所以，我们可以维护一个这样的索引：<strong>随机选 n/2 个元素做为一级索引、随机选 n/4 个元素做为二级索引、随机选 n/8 个元素做为三级索引，依次类推，一直到最顶层索引</strong>。这里每层索引的元素个数已经确定，且每层索引元素选取的足够随机，所以可以通过索引来提升跳表的查找效率。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101046805.png" alt="image-20220214101046805"></p><p>跳表-一级索引随机分布.jpg</p><p>那代码该如何实现，才能使跳表满足上述这个样子呢？可以在每次新插入元素的时候，尽量让该元素有 1/2 的几率建立一级索引、1/4 的几率建立二级索引、1/8 的几率建立三级索引，以此类推，就能满足我们上面的条件。现在我们就需要一个概率算法帮我们把控这个 1/2、1/4、1/8 … ，<strong>当每次有数据要插入时，先通过概率算法告诉我们这个元素需要插入到几级索引中</strong>，然后开始维护索引并把数据插入到原始链表中。下面开始讲解这个概率算法代码如何实现。</p><p>我们可以实现一个 randomLevel() 方法，该方法会随机生成 1~MAX_LEVEL 之间的数（MAX_LEVEL表示索引的最高层数），且该方法<strong>有 1/2 的概率返回 1、1/4 的概率返回 2、1/8的概率返回 3，以此类推</strong>。</p><ul><li>  randomLevel() 方法返回 1 表示当前插入的该元素不需要建索引，只需要存储数据到原始链表即可（概率 1/2）</li><li>  randomLevel() 方法返回 2 表示当前插入的该元素需要建一级索引（概率 1/4）</li><li>  randomLevel() 方法返回 3 表示当前插入的该元素需要建二级索引（概率 1/8）</li><li>  randomLevel() 方法返回 4 表示当前插入的该元素需要建三级索引（概率 1/16）</li><li>  。。。以此类推</li></ul><p>所以，通过 randomLevel() 方法，我们可以控制整个跳表各级索引中元素的个数。<strong>重点来了</strong>：randomLevel() 方法返回 2 的时候会建立一级索引，我们想要一级索引中元素个数占原始数据的 1/2，但是 randomLevel() 方法返回 2 的概率为 1/4，那是不是有矛盾呢？明明说好的 1/2，结果一级索引元素个数怎么变成了原始链表的 1/4？我们先看下图，应该就明白了。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101108858.png" alt="image-20220214101108858"></p><p>插入数据图示.jpeg</p><p>假设我们在插入元素 6 的时候，randomLevel() 方法返回 1，则我们不会为 6 建立索引。插入 7 的时候，randomLevel() 方法返回3 ，所以我们需要为元素 7 建立二级索引。这里我们发现了一个特点：当建立二级索引的时候，同时也会建立一级索引；当建立三级索引时，同时也会建立一级、二级索引。所以，一级索引中元素的个数等于 <em>[ 原始链表元素个数 ]</em> * _[ randomLevel() 方法返回值 &gt; 1 的概率 ]_。因为 randomLevel() 方法返回值 &gt; 1就会建索引，凡是建索引，无论几级索引必然有一级索引，<strong>所以一级索引中元素个数占原始数据个数的比率为 randomLevel() 方法返回值 &gt; 1 的概率</strong>。那 randomLevel() 方法返回值 &gt; 1 的概率是多少呢？因为 randomLevel() 方法随机生成 1~MAX_LEVEL 的数字，且 randomLevel() 方法返回值 1 的概率为 1/2，则 randomLevel() 方法返回值 &gt; 1 的概率为 1 - 1/2 = 1/2。即<strong>通过上述流程实现了一级索引中元素个数占原始数据个数的 1/2</strong>。</p><p>同理，当 randomLevel() 方法返回值 &gt; 2 时，会建立二级或二级以上索引，都会在二级索引中增加元素，因此<strong>二级索引中元素个数占原始数据的比率为 randomLevel() 方法返回值 &gt; 2 的概率</strong>。 randomLevel() 方法返回值 &gt; 2 的概率为 1 减去 randomLevel() = 1 或 =2 的概率，即 1 - 1/2 - 1/4 = 1/4。OK，达到了我们设计的目标：<strong>二级索引中元素个数占原始数据的 1/4</strong>。</p><p>以此类推，可以得出，遵守以下两个条件：</p><ul><li>  randomLevel() 方法，随机生成 1~MAX_LEVEL 之间的数（MAX_LEVEL表示索引的最高层数），且<strong>有 1/2的概率返回 1、1/4的概率返回 2、1/8的概率返回 3 …</strong></li><li>  randomLevel() 方法返回 1 不建索引、返回2建一级索引、返回 3 建二级索引、返回 4 建三级索引 …</li></ul><p>就可以满足我们想要的结果，即：一级索引中元素个数应该占原始数据的 1/2，二级索引中元素个数占原始数据的 1/4，三级索引中元素个数占原始数据的 1/8 ，依次类推，一直到最顶层索引。</p><p>但是问题又来了，怎么设计这么一个 randomLevel() 方法呢？直接撸代码：</p><pre><code>// 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：//        1/2 的概率返回 1//        1/4 的概率返回 2//        1/8 的概率返回 3 以此类推private int randomLevel() &#123;  int level = 1;  // 当 level &lt; MAX_LEVEL，且随机数小于设定的晋升概率时，level + 1  while (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL)    level += 1;  return level;&#125;</code></pre><p>上述代码可以实现我们的功能，而且，我们的案例中晋升概率 SKIPLIST_P 设置的 1/2，即：每两个结点抽出一个结点作为上一级索引的结点。如果我们想节省空间利用率，可以适当的降低代码中的 SKIPLIST_P，从而减少索引元素个数，Redis 的 zset 中 SKIPLIST_P 设定的 0.25。下图所示，是Redis <a href="https://links.jianshu.com/go?to=https://github.com/antirez/redis/blob/unstable/src/t_zset.c">t_zset.c</a> 中 zslRandomLevel 函数的实现：</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101129643.png" alt="image-20220214101129643"></p><p>Redis 源码中 <code>(random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF)</code> 在功能上等价于我代码中的 <code>Math.random() &lt; SKIPLIST_P</code> ，只不过 Redis 作者 <a href="https://links.jianshu.com/go?to=https://github.com/antirez">antirez</a> 使用位运算来提高浮点数比较的效率。</p><p>整体思路大家应该明白了，那插入数据时维护索引的时间复杂度是多少呢？**元素插入到单链表的时间复杂度为 O(1)**，我们索引的高度最多为 logn，当插入一个元素 x 时，最坏的情况就是元素 x 需要插入到每层索引中，所以插入数据到各层索引中，最坏时间复杂度是 O(logn)。</p><p>过程大概理解了，再通过一个例子描述一下跳表插入数据的全流程。现在我们要插入数据 6 到跳表中，首先 randomLevel() 返回 3，表示<strong>需要建二级索引</strong>，即：一级索引和二级索引需要增加元素 6。该跳表目前最高三级索引，首先找到三级索引的 1，发现 6 比 1大比 13小，所以，从 1 下沉到二级索引。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101146750.png" alt="image-20220214101146750"></p><p>下沉到二级索引后，发现 6 比 1 大比 7 小，此时需要在二级索引中 1 和 7 之间加一个元素6 ，并从元素 1 继续下沉到一级索引。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101201432.png" alt="image-20220214101201432">插入数据且维护跳表图示2.jpeg</p><p>下沉到一级索引后，发现 6 比 1 大比 4 大，所以往后查找，发现 6 比 4 大比 7 小，此时需要在一级索引中 4 和 7 之间加一个元素 6 ，并把二级索引的 6 指向 一级索引的 6，最后，从元素 4 继续下沉到原始链表。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101216693.png" alt="image-20220214101216693"></p><p>下沉到原始链表后，就比较简单了，发现 4、5 比 6小，7比6大，所以将6插入到 5 和 7 之间即可，整个插入过程结束。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101229592.png" alt="image-20220214101229592">整个插入过程的路径与查找元素路径类似， 每层索引中插入元素的时间复杂度 O(1)，所以整个插入的时间复杂度是 O(logn)。</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>跳表删除数据时，要把索引中对应节点也要删掉。如下图所示，如果要删除元素 9，需要把原始链表中的 9 和第一级索引的 9 都删除掉。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20220214101245553.png" alt="image-20220214101245553">跳表中，删除元素的时间复杂度是多少呢？</p><p>删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素 x，则执行删除操作。跳表中，每一层索引其实都是一个有序的单链表，单链表删除元素的时间复杂度为 O(1)，索引层数为 logn 表示最多需要删除 logn 个元素，所以删除元素的总时间包含 <em>查找元素的时间</em> 加 <em>删除 logn个元素的时间</em> 为 O(logn) + O(logn) = 2 O(logn)，忽略常数部分，删除元素的时间复杂度为 O(logn)。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p> 跳表是可以实现二分查找的有序链表；</p></li><li><p> 每个元素插入时随机生成它的level；</p></li><li><p> 最底层包含所有的元素；</p></li><li><p> 如果一个元素出现在level(x)，那么它肯定出现在x以下的level中；</p></li><li><p> 每个索引节点包含两个指针，一个向下，一个向右；（笔记目前看过的各种跳表源码实现包括Redis 的zset 都没有向下的指针，那怎么从二级索引跳到一级索引呢？留个悬念，看源码吧，文末有跳表实现源码）</p></li><li><p> 跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近；</p></li></ol><h3 id="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"><a href="#为什么Redis选择使用跳表而不是红黑树来实现有序集合？" class="headerlink" title="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"></a>为什么Redis选择使用跳表而不是红黑树来实现有序集合？</h3><p>Redis 中的有序集合(zset) 支持的操作：</p><ol><li><p> 插入一个元素</p></li><li><p> 删除一个元素</p></li><li><p> 查找一个元素</p></li><li><p> 有序输出所有元素</p></li><li><p> 按照范围区间查找元素（比如查找值在 [100, 356] 之间的数据）</p></li></ol><p>其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。</p><h3 id="工业上其他使用跳表的场景"><a href="#工业上其他使用跳表的场景" class="headerlink" title="工业上其他使用跳表的场景"></a>工业上其他使用跳表的场景</h3><p>在博客上从来没有见过有同学讲述 HBase MemStore 的数据结构，其实 HBase MemStore 内部存储数据就使用的跳表。为什么呢？HBase 属于 LSM Tree 结构的数据库，LSM Tree 结构的数据库有个特点，实时写入的数据先写入到内存，内存达到阈值往磁盘 flush 的时候，会生成类似于 StoreFile 的<strong>有序文件</strong>，而跳表恰好就是天然有序的，所以在 flush 的时候效率很高，而且跳表查找、插入、删除性能都很高，这应该是 HBase MemStore 内部存储数据使用跳表的原因之一。HBase 使用的是 java.util.concurrent 下的 ConcurrentSkipListMap()。</p><p>Google 开源的 key/value 存储引擎 LevelDB 以及 Facebook 基于 LevelDB 优化的 RocksDB 都是 LSM Tree 结构的数据库，他们内部的 MemTable 都是使用了跳表这种数据结构。</p><p>后期笔者还会输出一篇深入剖析 LSM Tree 的博客，到时候再结合场景分析为什么使用跳表。</p><p>参考：</p><p><a href="https://links.jianshu.com/go?to=https://github.com/antirez/redis/blob/unstable/src/t_zset.c">Redis zset源码</a></p><p><a href="https://links.jianshu.com/go?to=https://time.geekbang.org/column/article/42896">极客时间-数据结构与算法之美课程</a></p><ul><li>  王争老师的整套课程都很棒，对数据结构与算法想整体提高的同学可以订阅</li></ul><p><a href="https://links.jianshu.com/go?to=https://github.com/wangzheng0822/algo/blob/master/java/17_skiplist/SkipList.java">王争老师SkipList 实现</a></p><ul><li>  这个跳表实现相对简单，建议初学者参考，整个项目是王争老师极客时间课程配套的代码，其他数据结构实现也可以参考</li><li>  笔记在写本博客期间，向该项目提交了 pr，已被merge，模仿 redis 源码重新实现了 randomLevel() 方法，不过为了容易理解没有使用redis的位运算，之前的 randomLevel() 方法会导致索引冗余特别严重，5 级以下的索引中元素个数接近于所有元素的个数，有兴趣的同学可以继续深入研究</li></ul><p><a href="https://links.jianshu.com/go?to=https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5ac63d5188256255299d9c">源码 5：凌波微步 —— 探索「跳跃列表」内部结构</a></p><ul><li>  老钱的《Redis 深度历险》系列非常推荐</li></ul><p><a href="https://www.jianshu.com/p/dd01e8dc4d1f">拜托，面试别再问我跳表了！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Skip-List–跳表&quot;&gt;&lt;a href=&quot;#Skip-List–跳表&quot; class=&quot;headerlink&quot; title=&quot;Skip List–跳表&quot;&gt;&lt;/a&gt;Skip List–跳表&lt;/h1&gt;&lt;p&gt;跳表是一种神奇的数据结构，因为几乎所有版本的大学本科教材上都</summary>
      
    
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>10.分库分表</title>
    <link href="https://leslieaibin.github.io/2021/10/25/MySQL/10.%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>https://leslieaibin.github.io/2021/10/25/MySQL/10.%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2021-10-25T12:17:42.000Z</published>
    <updated>2022-02-13T01:59:37.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要拆分数据库？"><a href="#1-为什么要拆分数据库？" class="headerlink" title="1. 为什么要拆分数据库？"></a><strong>1. 为什么要拆分数据库？</strong></h2><p>单体项目在构建之初，<a href="https://link.zhihu.com/?target=https://coding.imooc.com/class/274.html?mc_marking=b9478d5f12bd4de1a83dc61bc224d99f&mc_channel=shouji">数据库</a>的负载和数据量都不大，所以不需要对数据库做拆分，小型财务系统、文书系统、ERP系统、OA系统，用一个MySQL数据库实例基本就够用了。</p><p>就像《淘宝技术这十年》里面说到的，电商业务的数据量增长飞快，所以最开始的PHP+MySQL的架构已经不能满足实际要求了，于是淘宝想到的第一个办法就是把MySQL替换成Oracle。但是没过了多久，在08年前后，单节点的Oracle数据库也不好用了，于是淘宝终于告别了单节点数据库，开始拆分数据库。从一个节点，变成多个节点。</p><p>拆分数据库是有讲究的，比如说拆分方法有两种：垂直切分和水平切分。那你是先水平切分还是垂直切分呢？顺序无所谓？不，顺序有所为，次序绝对不能错：先水平切分，然后垂直切分。</p><h2 id="2-什么是垂直切分？"><a href="#2-什么是垂直切分？" class="headerlink" title="2. 什么是垂直切分？"></a><strong>2. 什么是垂直切分？</strong></h2><p>垂直切分是根据业务来拆分数据库，同一类业务的数据表拆分到一个独立的数据库，另一类的数据表拆分到其他数据库。</p><p>比如说一个新零售的电商数据库，我们可以把跟商品相关的数据表拆分成一个数据库，然后在这些数据表的基础之上，构建出商品系统。比如用JAVA或者PHP语言，创建出一个商城系统。然后把跟进销存相关的数据表拆分到另外一个数据库上，再用程序构建出仓库系统。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-cb822f0a43ecbeeeef8ed3845a3fa278_1440w.jpg" alt="img"></p><p><strong>垂直切分解决了什么问题</strong></p><p>垂直切分可以降低单节点数据库的负载。原来所有数据表都放在一个数据库节点上，无疑所有的读写请求也都发到这个MySQL上面，所以数据库的负载太高。如果把一个节点的数据库拆分成多个MySQL数据库，这样就可以有效的降低每个MySQL数据库的负载。</p><p><strong>垂直切分不能解决什么问题</strong></p><p>垂直切分不能解决的是缩表，比如说商品表无论划分给哪个数据库节点，商品表的记录还是那么多，不管你把数据库垂直拆分的有多细致，每个数据表里面的数据量是没有变化的。</p><p>MySQL单表记录超过2000万，读写性能会下降的很快，因此说垂直切分并不能起到缩表的效果。</p><h2 id="3-什么是水平切分？"><a href="#3-什么是水平切分？" class="headerlink" title="3. 什么是水平切分？"></a><strong>3. 什么是水平切分？</strong></h2><p>水平切分是按照某个字段的某种规则，把数据切分到多张数据表。一张数据表化整为零，拆分成多张数据表，这样就可以起到缩表的效果了。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-e8376833abf17549ed97853ab7f71b90_1440w.jpg" alt="img"></p><p>很多人，都会水平切分存在误解，以为水平切分出来的数据表必须保存在不同的MySQL节点上。其实水平切分出来的数据表也可以保存在一个MySQL节点上面。不是水平切分一定需要多个MySQL节点。为什么这么说呢？</p><p>许多人不知道MySQL自带一种数据分区的技术，可以把一张表的数据，按照特殊规则，切分存储在不同的目录下。如果我们给Linux主机挂载了多块硬盘，我们完全可以利用MySQL分区技术，把一张表的数据切分存储在多个硬盘上。这样就由原来一块硬盘有限的IO能力，升级成了多个磁盘增强型的IO。如果你感兴趣数据分区的具体效果，可以看<a href="https://link.zhihu.com/?target=https://coding.imooc.com/class/274.html?mc_marking=b9478d5f12bd4de1a83dc61bc224d99f&mc_channel=shouji">《MySQL数据库集群》</a>这门实战课。</p><p><strong>水平切分的用途</strong></p><p>水平切分可以把数据切分到多张数据表，可以起到缩表的作用。</p><p>但是也不是所有的数据表都要做水平切分。数据量较大的数据表才需要做数据切分，比如说电商系统中的，用户表、商品表、产品表、地址表、订单表等等。有些数据表就不需要切分，因为数据量不多，比如说品牌表、供货商表、仓库表，这些都是不需要切分的。</p><p><strong>水平切分的缺点</strong></p><p>不同数据表的切分规则并不一致，要根据实际业务来确定。所以我们在选择数据库中间件产品的时候，就要选择切分规则丰富的产品。常见的数据库中间件有：MyCat、Atlas、ProxySQL等等。有些人觉得MyCat是Java语言开发的，就怀疑MyCat运行效率。其实数据库中间件的作用相当于SQL语句的路由器。你家路由器硬件配置不怎么高，但是不影响你享用百兆宽带。MyCat也是一个道理，它仅仅是起到SQL语句转发的作用，并不会实际执行SQL语句。我推荐使用MyCat最主要的原因是它自带了非常多的数据切分规则，我们可以按照主键求模切分数据，可以按照主键范围切分数据，还可以按照日期切分数据等等。因此说，为了满足业务的需要，MyCat目前来说算是非常不错的中间件产品。</p><p>水平切分的另一个缺点就是扩容比较麻烦，日积月累，分片迟早有不够用的时候。这时候不是首先选择增加新的集群分片。因为一个MySQL分片，需要4~8个MySQL节点（最小规模），增加一个分片的投入成本是很高的。所以正确的做法是做冷热数据分离，定期对分片中的数据归档。把过期的业务数据，从分片中转移到归档库。目前来说数据压缩比最高的MySQL引擎是TokuDB，而且带着事物的写入速度是InnoDB引擎的6-14倍。用TokuDB作为归档数据库最适合不过。</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-90c4e1014db42321db91c4cf330f1168_1440w.jpg" alt="img"></p><h2 id="4-到底是应该先水平还是先垂直"><a href="#4-到底是应该先水平还是先垂直" class="headerlink" title="4. 到底是应该先水平还是先垂直"></a>4. 到底是应该先水平还是先垂直</h2><p><strong>感觉各有道理</strong>。但我支持先垂直，然后水平</p><p><img src="https://test-1874253.oss-cn-beijing.aliyuncs.com/img/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAT2NlYW4mJlN0YXI=,size_10,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><p>数据库拆分原则：</p><ul><li>优先考虑缓存降低对数据库的读操作</li><li>再考虑读写分离，降低数据库写操作</li><li>最后开始数据拆分：<ul><li>先按照业务垂直拆分</li><li>在考虑水平拆分：先分库（设置数据路由规则，把数据分配到不同的库中）</li><li>最后在考虑分表，单表拆分到数据1000万以内。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-为什么要拆分数据库？&quot;&gt;&lt;a href=&quot;#1-为什么要拆分数据库？&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要拆分数据库？&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 为什么要拆分数据库？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;单体项目在构建之初，&lt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>11.数据库优化</title>
    <link href="https://leslieaibin.github.io/2021/10/25/MySQL/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <id>https://leslieaibin.github.io/2021/10/25/MySQL/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</id>
    <published>2021-10-25T12:17:42.000Z</published>
    <updated>2022-02-13T03:56:56.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库优化和查询优化方案"><a href="#数据库优化和查询优化方案" class="headerlink" title="数据库优化和查询优化方案"></a>数据库优化和查询优化方案</h1><h3 id="数据库优化方案"><a href="#数据库优化方案" class="headerlink" title="数据库优化方案"></a>数据库优化方案</h3><ol><li> 优化索引，sql语句，分析慢查询</li><li> 设计表的时候严格按照数据库设计规范来设计数据库</li><li> 使用缓存，把经常访问并且不需要经常变化的数据放在缓存中，能够节约磁盘IO</li><li> 优化硬件，采用ssd，使用磁盘队列技术（RAID0， RAID1，RAID5）</li><li> 采用mysql自带的表分区技术，把数据分析分成不同文件，能够磁盘的读写效率</li><li> 垂直分表，把一些不经常读的数据放在一张表当中，节约磁盘IO</li><li> 主从分离读写，采用主从复制把数据库的读操作和写操作分离开来</li><li> 分库分表分机器，数据量特别大的时候，主要的原理是数据路由</li><li> 选择合适的表引擎，参数上的优化</li><li> 进行架构级别的缓存，静态化和分布式</li><li> 不采用全文检索</li><li> 采用更快的存储方恨少，例如nosql存储经常访问的数据</li></ol><h3 id="优化数据库的查询效率"><a href="#优化数据库的查询效率" class="headerlink" title="优化数据库的查询效率"></a>优化数据库的查询效率</h3><ol><li> 存储引擎的选择，如果数据表需要事务处理，应该考虑Innodb，因为它完全符合ACID的特性，如果不需要食物处理，使用默认存储引擎MyISAM是比较明智的</li><li> 分表分库主从</li><li> 对查询进行优化，要尽量避免全表扫描，首先应考虑在shere以及orderby涉及的列上建立索引</li><li> 应尽量避免在where子句当中使用，不等于或者大于小于操作符，否则将导致引擎放弃使用索引而进行全表扫描</li><li> 应尽量避免在where子句当中使用null值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li> 应尽量避免在where子句当中使用or的判断，如果一个字段有索引，一个字段没有索引，将会导致引擎放弃使用索引而进行全表扫描</li><li> update语句如果只改一两个字段，不要update全部字段，否则频繁调用，会引起明显的性能消耗，同时带来的大量的日志</li><li> 对于多张数据量的表进行join，要先分页在做join，否则逻辑读写高，性能差</li></ol><hr><p>详细的优化方案</p><ul><li><p>1）数据库设计方面：</p><ul><li><p>  a. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p></li><li><p>  b. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0</p></li><li><p>  c. 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p></li><li><p>  d. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p></li><li><p>  e. 应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引。</p></li><li><p>  f. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p></li><li><p>  g. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p></li><li><p>  h. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p></li><li><p>  i. 避免频繁创建和删除临时表，以减少系统表资源的消耗。</p></li><li><p>  j. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p></li><li><p>  k. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p></li><li><p>  l. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p></li></ul></li></ul><ul><li><p>2)SQL语句方面：</p><ul><li><p>  a. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p></li><li><p>  b. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p></li></ul></li></ul><p><code>select id from t where num=10 or num=20</code></p><p>可以这样查询：</p><p><code>select id from t where num=10 union all select id from t where num=20</code></p><pre><code>- c. in 和 not in 也要慎用，否则会导致全表扫描，如： </code></pre><p><code>select id from t where num in(1,2,3)</code></p><p>对于连续的数值，能用 between 就不要用 in 了：</p><p><code>select id from t where num between 1 and 3</code></p><pre><code>- d. 下面的查询也将导致全表扫描： </code></pre><p><code>select id from t where name like ‘%abc%’</code></p><pre><code>- e. 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。</code></pre><p>然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><p><code>select id from t where num=@num</code></p><p>可以改为强制查询使用索引：</p><p><code>select id from t with(index(索引名)) where num=@num</code></p><pre><code>- f. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： </code></pre><p><code>select id from t where num/2=100</code></p><p>应改为:</p><p><code>select id from t where num=100*2</code></p><pre><code>- g. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： </code></pre><p><code>select id from t where substring(name,1,3)=’abc’</code></p><p>–name以abc开头的id</p><p><code>select id from t where datediff(day,createdate,’2005-11-30′)=0</code></p><p>–‘2005-11-30’生成的id</p><p>应改为:</p><p><code>select id from t where name like ‘abc%’ select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′</code></p><pre><code>- h. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。- i. 不要写一些没有意义的查询，如需要生成一个空表结构： </code></pre><p><code>select col1,col2 into #t from t where 1=0</code></p><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p><p>create table #t(…)</p><pre><code>- j. 很多时候用 exists 代替 in 是一个好的选择： </code></pre><p><code>select num from a where num in(select num from b)</code></p><p>用下面的语句替换：</p><p><code>select num from a where exists(select 1 from b where num=a.num)</code></p><pre><code>- k. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。- l. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。- m. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。- n. 尽量避免大事务操作，提高系统并发能力。</code></pre><ul><li><p>3)java方面：重点内容</p><ul><li><p>  a.尽可能的少造对象。</p></li><li><p>  b.合理摆正系统设计的位置。大量数据操作，和少量数据操作一定是分开的。大量的数据操作，肯定不是ORM框架搞定的。，</p></li><li><p>  c.使用jDBC链接数据库操作数据</p></li><li><p>  d.控制好内存，让数据流起来，而不是全部读到内存再处理，而是边读取边处理；</p></li><li><p>  e.合理利用内存，有的数据要缓存</p></li></ul></li></ul><p>如何优化数据库，如何提高数据库的性能?</p><p>1） 硬件调整性能 </p><p>最有可能影响性能的是磁盘和网络吞吐量,解决办法扩大虚拟内存，并保证有足够可以扩充的空间；把数据库服务器上的不必要服务关闭掉；把数据库服务器和主域服务器分开；把SQL数据库服务器的吞吐量调为最大；在具有一个以上处理器的机器上运行SQL。</p><p>2）调整数据库</p><p>若对该表的查询频率比较高，则建立索引；建立索引时，想尽对该表的所有查询搜索操作， 按照where选择条件建立索引，尽量为整型键建立为有且只有一个簇集索引，数据在物理上按顺序在数据页上，缩短查找范围，为在查询经常使用的全部列建立非簇集索引，能最大地覆盖查询；但是索引不可太多，执行UPDATE DELETE INSERT语句需要用于维护这些索引的开销量急剧增加；避免在索引中有太多的索引键；避免使用大型数据类型的列为索引；保证每个索引键值有少数行。</p><p>3）使用存储过程</p><p>应用程序的实现过程中，能够采用存储过程实现的对数据库的操作尽量通过存储过程来实现，因为存储过程是存放在数据库服务器上的一次性被设计、编码、测试，并被再次使用，需要执行该任务的应用可以简单地执行存储过程，并且只返回结果集或者数值，这样不仅可以使程序模块化，同时提高响应速度，减少网络流量，并且通过输入参数接受输入，使得在应用中完成逻辑的一致性实现。</p><p>4）应用程序结构和算法</p><p>建立查询条件索引仅仅是提高速度的前提条件，响应速度的提高还依赖于对索引的使用。因为人们在使用SQL时往往会陷入一个误区，即太关注于所得的结果是否正确，特别是对数据量不是特别大的数据库操作时，是否建立索引和使用索引的好坏对程序的响应速度并不大，因此程序员在书写程序时就忽略了不同的实现方法之间可能存在的性能差异，这种性能差异在数据量特别大时或者大型的或是复杂的数据库环境中（如联机事务处理OLTP或决策支持系统DSS）中表现得尤为明显。在工作实践中发现，不良的SQL往往来自于不恰当的索引设计、不充份的连接条件和不可优化的where子句。在对它们进行适当的优化后，其运行速度有了明显地提高！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库优化和查询优化方案&quot;&gt;&lt;a href=&quot;#数据库优化和查询优化方案&quot; class=&quot;headerlink&quot; title=&quot;数据库优化和查询优化方案&quot;&gt;&lt;/a&gt;数据库优化和查询优化方案&lt;/h1&gt;&lt;h3 id=&quot;数据库优化方案&quot;&gt;&lt;a href=&quot;#数据库优化方</summary>
      
    
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://leslieaibin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>13.线程安全</title>
    <link href="https://leslieaibin.github.io/2021/10/24/Thread/13.%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://leslieaibin.github.io/2021/10/24/Thread/13.%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-24T02:15:42.000Z</published>
    <updated>2022-02-12T13:50:02.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4种解决线程安全问题的方式"><a href="#4种解决线程安全问题的方式" class="headerlink" title="4种解决线程安全问题的方式"></a>4种解决线程安全问题的方式</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>线程安全问题，在做高并发的系统的时候，是程序员经常需要考虑的地方。怎么有效的防止线程安全问题，保证数据的准确性？怎么合理的最大化的利用系统资源等，这些问题都需要充分的理解并运行线程。当然关于多线程的问题在面试的时候也是出现频率比较高的。下面就来学习一下吧！</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>先来看看什么是进程和线程？</p><p>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。就比如说，我们开发的一个单体项目，运行它，就会产生一个进程。</p><p>线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。在这里强调一点就是：计算机中的线程和应用程序中的线程不是同一个概念。</p><p>总之一句话描述就是：进程是资源分配的最小单位，线程是程序执行的最小单位。</p><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>什么是线程安全呢？什么样的情况会造成线程安全问题呢？怎么解决线程安全呢？这些问题都是在下文中所要讲述的。</p><p><strong>线程安全：</strong>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p><p>那什么时候会造成线程安全问题呢？当多个线程同时去访问一个对象时，就可能会出现线程安全问题。那么怎么解决呢？请往下看！</p><h3 id="解决线程安全"><a href="#解决线程安全" class="headerlink" title="解决线程安全"></a>解决线程安全</h3><p>在这里提供4种方法来解决线程安全问题，也是最常用的4种方法。前提是项目在一个服务器中，如果是分布式项目可能就会用到分布锁了，这个就放到后面文章来详谈了。</p><p>讲4种方法前，还是先来了解一下悲观锁和乐观锁吧！</p><p>悲观锁，顾名思义它是悲观的。讲得通俗点就是，认为自己在使用数据的时候，一定有别的线程来修改数据，因此在获取数据的时候先加锁，确保数据不会被线程修改。形象理解就是总觉得有刁民想害朕。</p><p>而乐观锁就比较乐观了，认为在使用数据时，不会有别的线程来修改数据，就不会加锁，只是在更新数据的时候去判断之前有没有别的线程来更新了数据。具体用法在下面讲解。</p><p>现在来看有那4种方法吧！</p><h3 id="1-使用synchronized关键字"><a href="#1-使用synchronized关键字" class="headerlink" title="1. 使用synchronized关键字"></a>1. 使用synchronized关键字</h3><p>一个表现为原生语法层面的互斥锁，它是一种悲观锁，使用它的时候我们一般需要一个监听对象 并且监听对象必须是唯一的，通常就是当前类的字节码对象。它是JVM级别的，不会造成死锁的情况。使用synchronized可以拿来修饰类，静态方法，普通方法和代码块。比如：Hashtable类就是使用synchronized来修饰方法的。put方法部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure the value is not null</span></span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure><p>而ConcurrentHashMap类中就是使用synchronized来锁代码块的。putVal方法部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">              V oldVal = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                          binCount = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>synchronized关键字底层实现主要是通过monitorenter 与monitorexit计数 ，如果计数器不为0，说明资源被占用，其他线程就不能访问了，但是可重入的除外。说到这，就来讲讲什么是可重入的。这里其实就是指的可重入锁：指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响，执行对象中所有同步方法不用再次获得锁。避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁。</p><p>其实在使用synchronized时，存在一个锁升级原理。它是指在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。锁升级的目的是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。可能你又会问什么是偏向锁？什么是轻量级锁？什么是重量级锁？这里就简单描述一下吧，能够帮你更好的理解synchronized。</p><p>偏向锁（无锁）：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后（线程的id会记录在对象的Mark Word中），消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。</p><p>轻量级锁（CAS）：就是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；轻量级锁的意图是在没有多线程竞争的情况下，通过CAS操作尝试将MarkWord更新为指向LockRecord的指针，减少了使用重量级锁的系统互斥量产生的性能消耗。</p><p>重量级锁：虚拟机使用CAS操作尝试将MarkWord更新为指向LockRecord的指针，如果更新成功表示线程就拥有该对象的锁；如果失败，会检查MarkWord是否指向当前线程的栈帧，如果是，表示当前线程已经拥有这个锁；如果不是，说明这个锁被其他线程抢占，此时膨胀为重量级锁。</p><h3 id="2-使用Lock接口下的实现类"><a href="#2-使用Lock接口下的实现类" class="headerlink" title="2. 使用Lock接口下的实现类"></a>2. 使用Lock接口下的实现类</h3><p>Lock是juc（java.util.concurrent）包下面的一个接口。常用的实现类就是ReentrantLock 类，它其实也是一种悲观锁。一种表现为 API 层面的互斥锁。通过lock() 和 unlock() 方法配合使用。因此也可以说是一种手动锁，使用比较灵活。但是使用这个锁时一定要注意要释放锁，不然就会造成死锁。一般配合try/finally 语句块来完成。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">5000</span>;</span><br><span class="line">      ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">               lock.lock();</span><br><span class="line">               <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName()+<span class="string">&quot;你的票号是&quot;</span>+num--);</span><br><span class="line">               &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">              &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                 lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比 synchronized，ReentrantLock 增加了一些高级功能，主要有以下 3 项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。</p><p>等待可中断是指：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</p><p>公平锁是指：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>锁绑定多个条件是指：一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition() 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="comment">//ConditionObject是Condition的实现类</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><h3 id="3-使用线程本地存储ThreadLocal"><a href="#3-使用线程本地存储ThreadLocal" class="headerlink" title="3. 使用线程本地存储ThreadLocal"></a>3. 使用线程本地存储ThreadLocal</h3><p>当多个线程操作同一个变量且互不干扰的场景下，可以使用ThreadLocal来解决。它会在每个线程中对该变量创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。通过set(T value)方法给线程的局部变量设置值；get()获取线程局部变量中的值。当给线程绑定一个 Object 内容后，只要线程不变,就可以随时取出；改变线程,就无法取出内容.。这里提供一个用法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">500</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                  ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line">                  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                        local.set(++a);   <span class="comment">//子线程对a的操作不会影响主线程中的a</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                              Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">&quot;子线程：&quot;</span>+local.get());</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            a = <span class="number">22</span>;</span><br><span class="line">            ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line">            local.set(a);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                  System.out.println(<span class="string">&quot;主线程：&quot;</span>+local.get());</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>ThreadLocal线程容器保存变量时，底层其实是通过ThreadLocalMap来实现的。它是以当前ThreadLocal变量为key ，要存的变量为value。获取的时候就是以当前ThreadLocal变量去找到对应的key，然后获取到对应的值。源码参考如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals; <span class="comment">//ThreadLocal.ThreadLocalMap threadLocals = null;Thread类中声明的</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">       t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>观察源码就会发现，其实每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。</p><p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p><p>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找即可。</p><h3 id="4-使用乐观锁机制"><a href="#4-使用乐观锁机制" class="headerlink" title="4. 使用乐观锁机制"></a>4. 使用乐观锁机制</h3><p>前面已经讲述了什么是乐观锁。这里就来描述哈在java开发中怎么使用的。</p><p>其实在表设计的时候，我们通常就需要往表里加一个version字段。每次查询时，查出带有version的数据记录，更新数据时，判断数据库里对应id的记录的version是否和查出的version相同。若相同，则更新数据并把版本号+1；若不同，则说明，该数据发生了并发，被别的线程使用了，进行递归操作，再次执行递归方法，直到成功更新数据为止。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4种解决线程安全问题的方式&quot;&gt;&lt;a href=&quot;#4种解决线程安全问题的方式&quot; class=&quot;headerlink&quot; title=&quot;4种解决线程安全问题的方式&quot;&gt;&lt;/a&gt;4种解决线程安全问题的方式&lt;/h1&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>代理</title>
    <link href="https://leslieaibin.github.io/2021/10/12/java%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2021/10/12/java%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2021-10-12T01:15:42.000Z</published>
    <updated>2022-02-14T08:38:21.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-反射和动态代理"><a href="#Java-反射和动态代理" class="headerlink" title="Java 反射和动态代理"></a>Java 反射和动态代理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p><p><strong>通过反射机制，可以在运行时访问 Java 对象的属性，方法，构造方法等。</strong></p><h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>反射的主要应用场景有：</p><ul><li>  开发通用框架 - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li><li>  动态代理 - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</li><li>  注解 - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</li><li>  可扩展性功能 - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。</li></ul><h3 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h3><ul><li>  <strong>性能开销</strong> - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。</li><li>  <strong>破坏封装性</strong> - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li><li>  <strong>内部曝光</strong> - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。</li></ul><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic1.zhimg.com/v2-41136c8c767fb7469ddb9c446f662de8_b.jpg"></p><p>类加载的完整过程如下：</p><ol><li> 在编译时，Java 编译器编译好 .java 文件之后，在磁盘中产生 .class 文件。.class 文件是二进制文件，内容是只有 JVM 能够识别的机器码。</li><li> JVM 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 java.lang.Class 对象。</li><li> 加载结束后，JVM 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。</li></ol><h3 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h3><p>要想使用反射，首先需要获得待操作的类所对应的 Class 对象。<strong>Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构。</strong>所以，java.lang.Class 可以视为所有反射 API 的入口点。</p><p><strong>反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。</strong></p><p>举例来说，假如定义了以下代码：</p><pre><code>User user = new User(); </code></pre><p>步骤说明：</p><ol><li> JVM 加载方法的时候，遇到 new User()，JVM 会根据 User 的全限定名去加载 User.class 。</li><li> JVM 会去本地磁盘查找 User.class 文件并加载 JVM 内存中。</li><li> JVM 通过调用类加载器自动创建这个类对应的 Class 对象，并且存储在 JVM 的方法区。注意：一个类有且只有一个 Class 对象。</li></ol><h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><p><strong>java.lang.reflect 包</strong></p><p>Java 中的 java.lang.reflect 包提供了反射功能。java.lang.reflect 包中的类都没有 public 构造方法。</p><p>java.lang.reflect 包的核心接口和类如下：</p><ul><li>  Member 接口 - 反映关于单个成员(字段或方法)或构造函数的标识信息。</li><li>  Field 类 - 提供一个类的域的信息以及访问类的域的接口。</li><li>  Method 类 - 提供一个类的方法的信息以及访问类的方法的接口。</li><li>  Constructor 类 - 提供一个类的构造函数的信息以及访问类的构造函数的接口。</li><li>  Array 类 - 该类提供动态地生成和访问 JAVA 数组的方法。</li><li>  Modifier 类 - 提供了 static 方法和常量，对类和成员访问修饰符进行解码。</li><li>  Proxy 类 - 提供动态地生成代理类和类实例的静态方法。</li></ul><p><strong>获得 Class 对象</strong></p><p>获得 Class 的三种方法：</p><p>（1）<strong>使用 Class 类的 forName 静态方法</strong></p><p>示例：</p><pre><code>package io.github.dunwu.javacore.reflect;public class ReflectClassDemo01 &#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        Class c1 = Class.forName(&quot;io.github.dunwu.javacore.reflect.ReflectClassDemo01&quot;);        System.out.println(c1.getCanonicalName());        Class c2 = Class.forName(&quot;[D&quot;);        System.out.println(c2.getCanonicalName());        Class c3 = Class.forName(&quot;[[Ljava.lang.String;&quot;);        System.out.println(c3.getCanonicalName());    &#125;&#125;//Output://io.github.dunwu.javacore.reflect.ReflectClassDemo01//double[]//java.lang.String[][]</code></pre><p>使用类的完全限定名来反射对象的类。常见的应用场景为：在 JDBC 开发中常用此方法加载数据库驱动。</p><p>（2）<strong>直接获取某一个对象的 class</strong></p><p>示例：</p><pre><code>public class ReflectClassDemo02 &#123;    public static void main(String[] args) &#123;        Boolean b;        // Class c = b.getClass(); // 编译错误        Class c1 = Boolean.class;        System.out.println(c1.getCanonicalName());        Class c2 = java.io.PrintStream.class;        System.out.println(c2.getCanonicalName());        Class c3 = int[][][].class;        System.out.println(c3.getCanonicalName());    &#125;&#125;//Output://boolean//java.io.PrintStream//int[][][]</code></pre><p>（3）<strong>调用 Object 的 getClass 方法，</strong>示例：</p><p>Object 类中有 getClass 方法，因为所有类都继承 Object 类。从而调用 Object 类来获取</p><p>示例：</p><pre><code>package io.github.dunwu.javacore.reflect;import java.util.HashSet;import java.util.Set;public class ReflectClassDemo03 &#123;    enum E &#123;        A, B    &#125;    public static void main(String[] args) &#123;        Class c = &quot;foo&quot;.getClass();        System.out.println(c.getCanonicalName());        Class c2 = ReflectClassDemo03.E.A.getClass();        System.out.println(c2.getCanonicalName());        byte[] bytes = new byte[1024];        Class c3 = bytes.getClass();        System.out.println(c3.getCanonicalName());        Set&lt;String&gt; set = new HashSet&lt;&gt;();        Class c4 = set.getClass();        System.out.println(c4.getCanonicalName());    &#125;&#125;//Output://java.lang.String//io.github.dunwu.javacore.reflect.ReflectClassDemo.E//byte[]//java.util.HashSet</code></pre><p><strong>判断是否为某个类的实例</strong></p><p>判断是否为某个类的实例有两种方式：</p><ol><li> 用 instanceof 关键字</li><li> 用 Class 对象的 isInstance 方法（它是一个 Native 方法）</li></ol><p>示例：</p><pre><code>public class InstanceofDemo &#123;    public static void main(String[] args) &#123;        ArrayList arrayList = new ArrayList();        if (arrayList instanceof List) &#123;            System.out.println(&quot;ArrayList is List&quot;);        &#125;        if (List.class.isInstance(arrayList)) &#123;            System.out.println(&quot;ArrayList is List&quot;);        &#125;    &#125;&#125;//Output://ArrayList is List//ArrayList is List</code></pre><p><strong>创建实例</strong></p><p>通过反射来创建实例对象主要有两种方式：</p><ol><li> 用 Class 对象的 newInstance 方法。</li><li> 用 Constructor 对象的 newInstance 方法。</li></ol><p>示例：</p><pre><code>public class NewInstanceDemo &#123;    public static void main(String[] args)            throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;        Class&lt;?&gt; c1 = StringBuilder.class;        StringBuilder sb = (StringBuilder) c1.newInstance();        sb.append(&quot;aaa&quot;);        System.out.println(sb.toString());        //获取String所对应的Class对象        Class&lt;?&gt; c2 = String.class;        //获取String类带一个String参数的构造器        Constructor constructor = c2.getConstructor(String.class);        //根据构造器创建实例        String str2 = (String) constructor.newInstance(&quot;bbb&quot;);        System.out.println(str2);    &#125;&#125;//Output://aaa//bbb</code></pre><p><strong>Field</strong></p><p>Class 对象提供以下方法获取对象的成员（Field）：</p><ol><li> getFiled - 根据名称获取公有的（public）类成员。</li><li> getDeclaredField - 根据名称获取已声明的类成员。但不能得到其父类的类成员。</li><li> getFields - 获取所有公有的（public）类成员。</li><li> getDeclaredFields - 获取所有已声明的类成员。</li></ol><p>示例如下：</p><pre><code>public class ReflectFieldDemo &#123;    class FieldSpy&lt;T&gt; &#123;        public Boolean[][] b = &#123;&#123;false, false&#125;, &#123;true, true&#125;&#125;;        public String name = &quot;Alice&quot;;        public List&lt;Integer&gt; list;        public T val;    &#125;    public static void main(String[] args) throws NoSuchFieldException &#123;        Field f1 = FieldSpy.class.getField(&quot;b&quot;);        System.out.format(&quot;Type: %s%n&quot;, f1.getType());        Field f2 = FieldSpy.class.getField(&quot;name&quot;);        System.out.format(&quot;Type: %s%n&quot;, f2.getType());        Field f3 = FieldSpy.class.getField(&quot;list&quot;);        System.out.format(&quot;Type: %s%n&quot;, f3.getType());        Field f4 = FieldSpy.class.getField(&quot;val&quot;);        System.out.format(&quot;Type: %s%n&quot;, f4.getType());    &#125;&#125;//Output://Type: class [[Z//Type: class java.lang.String//Type: interface java.util.List//Type: class java.lang.Object</code></pre><p><strong>Method</strong></p><p>Class 对象提供以下方法获取对象的方法（Method）：</p><ul><li>  getMethod - 返回类或接口的特定方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li><li>  getDeclaredMethod - 返回类或接口的特定声明方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li><li>  getMethods - 返回类或接口的所有 public 方法，包括其父类的 public 方法。</li><li>  getDeclaredMethods - 返回类或接口声明的所有方法，包括 public、protected、默认（包）访问和 private 方法，但不包括继承的方法。</li></ul><p>获取一个 Method 对象后，可以用 invoke 方法来调用这个方法。</p><p>invoke 方法的原型为:</p><pre><code>public Object invoke(Object obj, Object... args)        throws IllegalAccessException, IllegalArgumentException,           InvocationTargetException</code></pre><p>示例：</p><pre><code>public class ReflectMethodDemo &#123;    public static void main(String[] args)            throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;        // 返回所有方法        Method[] methods1 = System.class.getDeclaredMethods();        System.out.println(&quot;System getDeclaredMethods 清单（数量 = &quot; + methods1.length + &quot;）：&quot;);        for (Method m : methods1) &#123;            System.out.println(m);        &#125;        // 返回所有 public 方法        Method[] methods2 = System.class.getMethods();        System.out.println(&quot;System getMethods 清单（数量 = &quot; + methods2.length + &quot;）：&quot;);        for (Method m : methods2) &#123;            System.out.println(m);        &#125;        // 利用 Method 的 invoke 方法调用 System.currentTimeMillis()        Method method = System.class.getMethod(&quot;currentTimeMillis&quot;);        System.out.println(method);        System.out.println(method.invoke(null));    &#125;&#125;</code></pre><p><strong>Constructor</strong></p><p>Class 对象提供以下方法获取对象的构造方法（Constructor）：</p><ul><li>  getConstructor - 返回类的特定 public 构造方法。参数为方法参数对应 Class 的对象。</li><li>  getDeclaredConstructor - 返回类的特定构造方法。参数为方法参数对应 Class 的对象。</li><li>  getConstructors - 返回类的所有 public 构造方法。</li><li>  getDeclaredConstructors - 返回类的所有构造方法。</li></ul><p>获取一个 Constructor 对象后，可以用 newInstance 方法来创建类实例。</p><p>示例：</p><pre><code>public class ReflectMethodConstructorDemo &#123;    public static void main(String[] args)            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;        Constructor&lt;?&gt;[] constructors1 = String.class.getDeclaredConstructors();        System.out.println(&quot;String getDeclaredConstructors 清单（数量 = &quot; + constructors1.length + &quot;）：&quot;);        for (Constructor c : constructors1) &#123;            System.out.println(c);        &#125;        Constructor&lt;?&gt;[] constructors2 = String.class.getConstructors();        System.out.println(&quot;String getConstructors 清单（数量 = &quot; + constructors2.length + &quot;）：&quot;);        for (Constructor c : constructors2) &#123;            System.out.println(c);        &#125;        System.out.println(&quot;====================&quot;);        Constructor constructor = String.class.getConstructor(String.class);        System.out.println(constructor);        String str = (String) constructor.newInstance(&quot;bbb&quot;);        System.out.println(str);    &#125;&#125;</code></pre><p><strong>Array</strong></p><p>数组在 Java 里是比较特殊的一种类型，它可以赋值给一个对象引用。下面我们看一看利用反射创建数组的例子：</p><pre><code>public class ReflectArrayDemo &#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.String&quot;);        Object array = Array.newInstance(cls, 25);        //往数组里添加内容        Array.set(array, 0, &quot;Scala&quot;);        Array.set(array, 1, &quot;Java&quot;);        Array.set(array, 2, &quot;Groovy&quot;);        Array.set(array, 3, &quot;Scala&quot;);        Array.set(array, 4, &quot;Clojure&quot;);        //获取某一项的内容        System.out.println(Array.get(array, 3));    &#125;&#125;//Output://Scala</code></pre><p>其中的 Array 类为 java.lang.reflect.Array 类。我们通过 Array.newInstance 创建数组对象，它的原型是：</p><pre><code>public static Object newInstance(Class&lt;?&gt; componentType, int length)    throws NegativeArraySizeException &#123;    return newArray(componentType, length);&#125;</code></pre><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是反射的一个非常重要的应用场景。动态代理常被用于一些 Java 框架中。例如 Spring 的 AOP ，Dubbo 的 SPI 接口，就是基于 Java 动态代理实现的。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>静态代理其实就是指设计模式中的代理模式。-<br>代理模式为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic4.zhimg.com/v2-e8162f682944cfd99112e7dea37f0387_b.jpg"></p><p><strong>Subject</strong> 定义了 RealSubject 和 Proxy 的公共接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy 。</p><pre><code>abstract class Subject &#123;    public abstract void Request();&#125;</code></pre><p><strong>RealSubject</strong> 定义 Proxy 所代表的真实实体。</p><pre><code>class RealSubject extends Subject &#123;    @Override        public void Request() &#123;        System.out.println(&quot;真实的请求&quot;);    &#125;&#125;</code></pre><p><strong>Proxy</strong> 保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。</p><pre><code>class Proxy extends Subject &#123;    private RealSubject real;    @Override        public void Request() &#123;        if (null == real) &#123;            real = new RealSubject();        &#125;        real.Request();    &#125;&#125;</code></pre><blockquote><p>说明：-<br>静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和 RealSubject 的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。</p></blockquote><h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><p>为了解决静态代理的问题，就有了创建动态代理的想法：</p><p>在运行状态中，需要代理的地方，根据 Subject 和 RealSubject，动态地创建一个 Proxy，用完之后，就会销毁，这样就可以避免了 Proxy 角色的 class 在系统中冗杂的问题了。</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic4.zhimg.com/v2-126d7905882d5a27b0ff6efcaa0ff07b_b.jpg"></p><p>Java 动态代理基于经典代理模式，引入了一个 InvocationHandler，InvocationHandler 负责统一管理所有的方法调用。</p><p>动态代理步骤：</p><ol><li> 获取 RealSubject 上的所有接口列表；</li><li> 确定要生成的代理类的类名，默认为：com.sun.proxy.$ProxyXXXX；</li><li> 根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；</li><li> 将对应的字节码转换为对应的 class 对象；</li><li> 创建 InvocationHandler 实例 handler，用来处理 Proxy 所有方法调用；</li><li> Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。</li></ol><p>从上面可以看出，JDK 动态代理的实现是基于实现接口的方式，使得 Proxy 和 RealSubject 具有相同的功能。</p><p>但其实还有一种思路：通过继承。即：让 Proxy 继承 RealSubject，这样二者同样具有相同的功能，Proxy 还可以通过重写 RealSubject 中的方法，来实现多态。CGLIB 就是基于这种思路设计的。</p><p>在 Java 的动态代理机制中，有两个重要的类（接口），一个是 InvocationHandler 接口、另一个则是 Proxy 类，这一个类和一个接口是实现我们动态代理所必须用到的。</p><h3 id="InvocationHandler-接口"><a href="#InvocationHandler-接口" class="headerlink" title="InvocationHandler 接口"></a>InvocationHandler 接口</h3><p>InvocationHandler 接口定义：</p><pre><code>public interface InvocationHandler &#123;    public Object invoke(Object proxy, Method method, Object[] args)            throws Throwable;&#125;</code></pre><p>每一个动态代理类都必须要实现 InvocationHandler 这个接口，并且每个代理类的实例都关联到了一个 Handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 InvocationHandler 这个接口的 invoke 方法来进行调用。</p><p>我们来看看 InvocationHandler 这个接口的唯一一个方法 invoke 方法：</p><pre><code>Object invoke(Object proxy, Method method, Object[] args)throws Throwable </code></pre><p>参数说明：</p><ul><li>  proxy - 代理的真实对象。</li><li>  method - 所要调用真实对象的某个方法的 Method 对象</li><li>  args - 所要调用真实对象某个方法时接受的参数</li></ul><p>如果不是很明白，等下通过一个实例会对这几个参数进行更深的讲解。</p><h3 id="Proxy-类"><a href="#Proxy-类" class="headerlink" title="Proxy 类"></a>Proxy 类</h3><p>Proxy 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法：</p><pre><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)  throws IllegalArgumentException</code></pre><p>这个方法的作用就是得到一个动态的代理对象。</p><p>参数说明：</p><ul><li>  <strong>loader</strong> - 一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载。</li><li>  <strong>interfaces</strong> - 一个 Interface 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</li><li>  <strong>h</strong> - 一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上</li></ul><h3 id="动态代理实例"><a href="#动态代理实例" class="headerlink" title="动态代理实例"></a>动态代理实例</h3><p>上面的内容介绍完这两个接口(类)以后，我们来通过一个实例来看看我们的动态代理模式是什么样的：</p><p>首先我们定义了一个 Subject 类型的接口，为其声明了两个方法：</p><pre><code>public interface Subject &#123;    void hello(String str);    String bye();&#125;</code></pre><p>接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject 类：</p><pre><code>public class RealSubject implements Subject &#123;    @Override        public void hello(String str) &#123;        System.out.println(&quot;Hello  &quot; + str);    &#125;    @Override        public String bye() &#123;        System.out.println(&quot;Goodbye&quot;);        return &quot;Over&quot;;    &#125;&#125;</code></pre><p>下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外：</p><pre><code>public class InvocationHandlerDemo implements InvocationHandler &#123;    // 这个就是我们要代理的真实对象    private Object subject;    // 构造方法，给我们要代理的真实对象赋初值    public InvocationHandlerDemo(Object subject) &#123;        this.subject = subject;    &#125;    @Override        public Object invoke(Object object, Method method, Object[] args)            throws Throwable &#123;        // 在代理真实对象前我们可以添加一些自己的操作        System.out.println(&quot;Before method&quot;);        System.out.println(&quot;Call Method: &quot; + method);        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用        Object obj = method.invoke(subject, args);        // 在代理真实对象后我们也可以添加一些自己的操作        System.out.println(&quot;After method&quot;);        System.out.println();        return obj;    &#125;&#125;</code></pre><p>最后，来看看我们的 Client 类：</p><pre><code>public class Client &#123;    public static void main(String[] args) &#123;        // 我们要代理的真实对象        Subject realSubject = new RealSubject();        // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的        InvocationHandler handler = new InvocationHandlerDemo(realSubject);        /*         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上         */        Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject                        .getClass().getInterfaces(), handler);        System.out.println(subject.getClass().getName());        subject.hello(&quot;World&quot;);        String result = subject.bye();        System.out.println(&quot;Result is: &quot; + result);    &#125;&#125;</code></pre><p>我们先来看看控制台的输出：</p><pre><code>com.sun.proxy.$Proxy0Before methodCall Method: public abstract void io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)Hello  WorldAfter methodBefore methodCall Method: public abstract java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()GoodbyeAfter methodResult is: Over</code></pre><p>我们首先来看看 com.sun.proxy.$Proxy0 这东西，我们看到，这个东西是由 System.out.println(subject.getClass().getName()); 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？</p><pre><code>Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject                .getClass().getInterfaces(), handler);</code></pre><p>可能我以为返回的这个代理对象会是 Subject 类型的对象，或者是 InvocationHandler 的对象，结果却不是，首先我们解释一下<strong>为什么我们这里可以将其转化为 Subject 类型的对象</strong>？</p><p>原因就是：在 newProxyInstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是 Subject 类型，所以就可以将其转化为 Subject 类型了。</p><p><strong>同时我们一定要记住，通过 Proxy.newProxyInstance 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy 为中，最后一个数字表示对象的标号。</strong></p><p>接着我们来看看这两句</p><pre><code>subject.hello(&quot;World&quot;); String result = subject.bye();</code></pre><p>这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的 invoke 方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject 类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的 invoke 方法去执行。</p><p>我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：</p><pre><code>public abstract void io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)public abstract java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()</code></pre><p>正好就是我们的 Subject 接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的 invoke 方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>反射应用</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic2.zhimg.com/v2-2ce2db221bf3a57b6b45a11e2967b14d_b.jpg"></p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://pic3.zhimg.com/v2-9bd2394aa44f773e90a161e23f0797c2_b.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-反射和动态代理&quot;&gt;&lt;a href=&quot;#Java-反射和动态代理&quot; class=&quot;headerlink&quot; title=&quot;Java 反射和动态代理&quot;&gt;&lt;/a&gt;Java 反射和动态代理&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>19.oom排查</title>
    <link href="https://leslieaibin.github.io/2021/10/11/JVM/20.%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/"/>
    <id>https://leslieaibin.github.io/2021/10/11/JVM/20.%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</id>
    <published>2021-10-11T01:15:42.000Z</published>
    <updated>2022-02-14T08:51:36.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java双亲委派模型"><a href="#Java双亲委派模型" class="headerlink" title="Java双亲委派模型"></a>Java双亲委派模型</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>平时做业务开发比较少接触类加载器，但是如果想深入学习Tomcat、Spring等开源项目，或者从事底层架构的开发，了解甚至熟悉类加载的原理是必不可少的。</p><p>java的类加载器有哪些？什么是双亲委派？为什么要双亲委派？如何打破它？多多少少对这些概念了解一些，甚至因为应付面试背过这些知识点，但是再深入一些细节，却知之甚少。</p><h2 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h2><p>类加载器，顾名思义就是一个可以将Java字节码加载为<code>java.lang.Class</code>实例的工具。这个过程包括，读取字节数组、验证、解析、初始化等。另外，它也可以加载资源，包括图像文件和配置文件。</p><p>类加载器的特点：</p><ul><li>  动态加载，无需在程序一开始运行的时候加载，而是在程序运行的过程中，动态按需加载，字节码的来源也很多，压缩包jar、war中，网络中，本地文件等。类加载器动态加载的特点为热部署，热加载做了有力支持。</li><li>  全盘负责，当一个类加载器加载一个类时，这个类所依赖的、引用的其他所有类都由这个类加载器加载，除非在程序中显式地指定另外一个类加载器加载。所以破坏双亲委派不能破坏扩展类加载器以上的顺序。</li></ul><p>一个类的唯一性由加载它的类加载器和这个类的本身决定（类的全限定名+类加载器的实例ID作为唯一标识）。比较两个类是否相等（包括Class对象的<code>equals()</code>、<code>isAssignableFrom()</code>、<code>isInstance()</code>以及<code>instanceof</code>关键字等），只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类就必定不相等。</p><p>从实现方式上，类加载器可以分为两种：一种是<strong>启动类加载器</strong>，由C++语言实现，是虚拟机自身的一部分；另一种是继承于<code>java.lang.ClassLoader</code>的类加载器，包括<strong>扩展类加载器</strong>、<strong>应用程序类加载器</strong>以及自定义类加载器。</p><p><strong>启动类加载器</strong>（<code>Bootstrap ClassLoader</code>）：负责加载<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。<strong>启动类加载器无法被Java程序直接引用</strong>，用户在编写自定义类加载器时，如果想设置<code>Bootstrap ClassLoader</code>为其<code>parent</code>，<strong>可直接设置null</strong>。</p><p><strong>扩展类加载器</strong>（<code>Extension ClassLoader</code>）：负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定路径中的所有类库。该类加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现。扩展类加载器由启动类加载器加载，其父类加载器为启动类加载器，即<code>parent=null</code>。</p><p><strong>应用程序类加载器</strong>（<code>Application ClassLoader</code>）：负责加载用户类路径（<code>ClassPath</code>）上所指定的类库，由<code>sun.misc.Launcher$App-ClassLoader</code>实现。开发者可直接通过<code>java.lang.ClassLoader</code>中的<code>getSystemClassLoader()</code>方法获取应用程序类加载器，所以也可称它为系统类加载器。应用程序类加载器也是启动类加载器加载的，但是它的父类加载器是扩展类加载器。在一个应用程序中，系统类加载器一般是默认类加载器。</p><h2 id="三、双亲委派机制"><a href="#三、双亲委派机制" class="headerlink" title="三、双亲委派机制"></a>三、双亲委派机制</h2><h3 id="1、什么是双亲委派"><a href="#1、什么是双亲委派" class="headerlink" title="1、什么是双亲委派"></a>1、什么是双亲委派</h3><p>JVM 并不是在启动时就把所有的<code>.class</code>文件都加载一遍，而是程序在运行过程中用到了这个类才去加载。除了启动类加载器外，其他所有类加载器都需要继承抽象类<code>ClassLoader</code>，这个抽象类中定义了三个关键方法，理解清楚它们的作用和关系非常重要。</p><pre><code>public abstract class ClassLoader &#123;    //每个类加载器都有个父加载器    private final ClassLoader parent;    public Class&lt;?&gt; loadClass(String name) &#123;        //查找一下这个类是不是已经加载过了        Class&lt;?&gt; c = findLoadedClass(name);        //如果没有加载过        if( c == null )&#123;          //先委派给父加载器去加载，注意这是个递归调用          if (parent != null) &#123;              c = parent.loadClass(name);          &#125;else &#123;              // 如果父加载器为空，查找Bootstrap加载器是不是加载过了              c = findBootstrapClassOrNull(name);          &#125;        &#125;        // 如果父加载器没加载成功，调用自己的findClass去加载        if (c == null) &#123;            c = findClass(name);        &#125;        return c；    &#125;    protected Class&lt;?&gt; findClass(String name)&#123;       //1. 根据传入的类名name，到在特定目录下去寻找类文件，把.class文件读入内存          ...       //2. 调用defineClass将字节数组转成Class对象       return defineClass(buf, off, len)；    &#125;    // 将字节码数组解析成一个Class对象，用native方法实现    protected final Class&lt;?&gt; defineClass(byte[] b, int off, int len)&#123;       ...    &#125;&#125;</code></pre><p>​<br>​        </p><p>从上面的代码可以得到几个关键信息：</p><ul><li>  JVM 的类加载器是分层次的，它们有父子关系，而这个关系不是继承维护，而是组合，每个类加载器都持有一个 <code>parent</code>字段，指向父加载器。（<code>AppClassLoader</code>的<code>parent</code>是<code>ExtClassLoader</code>，<code>ExtClassLoader</code>的<code>parent</code>是<code>BootstrapClassLoader</code>，但是<code>ExtClassLoader</code>的<code>parent=null</code>。）</li><li>  <code>defineClass</code>方法的职责是调用 native 方法把 Java 类的字节码解析成一个 Class 对象。</li><li>  <code>findClass</code>方法的主要职责就是找到<code>.class</code>文件并把<code>.class</code>文件读到内存得到字节码数组，然后调用 <code>defineClass</code>方法得到 Class 对象。子类必须实现<code>findClass</code>。</li><li>  <code>loadClass</code>方法的主要职责就是实现双亲委派机制：首先检查这个类是不是已经被加载过了，如果加载过了直接返回，否则委派给父加载器加载，这是一个递归调用，<strong>一层一层向上委派，最顶层的类加载器（启动类加载器）无法加载该类时，再一层一层向下委派给子类加载器加载</strong>。</li></ul><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20210601230727770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjU4NjEyMA==,size_1,color_FFFFFF,t_70%23pic_center"></p><h3 id="2、为什么要双亲委派？"><a href="#2、为什么要双亲委派？" class="headerlink" title="2、为什么要双亲委派？"></a>2、为什么要双亲委派？</h3><p>双亲委派保证类加载器，自下而上的委派，又自上而下的加载，保证每一个类在各个类加载器中都是同一个类。</p><p>一个非常明显的目的就是保证<code>java</code>官方的类库<code>&lt;JAVA_HOME&gt;\lib</code>和扩展类库<code>&lt;JAVA_HOME&gt;\lib\ext</code>的加载安全性，不会被开发者覆盖。</p><p>例如类<code>java.lang.Object</code>，它存放在<code>rt.jar</code>之中，无论哪个类加载器要加载这个类，最终都是委派给启动类加载器加载，因此Object类在程序的各种类加载器环境中都是同一个类。</p><p>如果开发者自己开发开源框架，也可以自定义类加载器，利用双亲委派模型，保护自己框架需要加载的类不被应用程序覆盖。</p><h2 id="四、破坏双亲委派"><a href="#四、破坏双亲委派" class="headerlink" title="四、破坏双亲委派"></a>四、破坏双亲委派</h2><p>如果想自定义类加载器，就需要继承<code>ClassLoader</code>，并重写<code>findClass</code>，如果想不遵循双亲委派的类加载顺序，还需要重写<code>loadClass</code>。如下是一个自定义的类加载器，并重写了<code>loadClass</code>破坏双亲委派：</p><pre><code>package com.stefan.DailyTest.classLoader;import java.io.*;public class TestClassLoader extends ClassLoader &#123;    public TestClassLoader(ClassLoader parent) &#123;        super(parent);    &#125;    @Override    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;        // 1、获取class文件二进制字节数组        byte[] data = null;        try &#123;            ByteArrayOutputStream baos = new ByteArrayOutputStream();            FileInputStream fis = new FileInputStream(new File(&quot;C:\\study\\myStudy\\JavaLearning\\target\\classes\\com\\stefan\\DailyTest\\classLoader\\Demo.class&quot;));            byte[] bytes = new byte[1024];            int len = 0;            while ((len = fis.read(bytes)) != -1) &#123;                baos.write(bytes, 0, len);            &#125;            data = baos.toByteArray();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        // 2、字节码数组加载到 JVM 的方法区，        // 并在 JVM 的堆区建立一个java.lang.Class对象的实例        // 用来封装 Java 类相关的数据和方法        return this.defineClass(name, data, 0, data.length);    &#125;    @Override    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException&#123;        // 1、找到ext classLoader，并首先委派给它加载，为什么？        ClassLoader classLoader = getSystemClassLoader();        while (classLoader.getParent() != null) &#123;            classLoader = classLoader.getParent();        &#125;        Class&lt;?&gt; clazz = null;        try &#123;            clazz = classLoader.loadClass(name);        &#125; catch (ClassNotFoundException e) &#123;            // Ignore        &#125;        if (clazz != null) &#123;            return clazz;        &#125;        // 2、自己加载        clazz = this.findClass(name);        if (clazz != null) &#123;            return clazz;        &#125;        // 3、自己加载不了，再调用父类loadClass，保持双亲委派模式        return super.loadClass(name);    &#125;&#125;</code></pre><p>​<br>​        </p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20210601230816298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjU4NjEyMA==,size_1,color_FFFFFF,t_70%23pic_center"></p><p>测试加载Demo类：</p><pre><code>package com.stefan.DailyTest.classLoader;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        // 初始化TestClassLoader，并将加载TestClassLoader类的类加载器        // 设置为TestClassLoader的parent        TestClassLoader testClassLoader = new TestClassLoader(TestClassLoader.class.getClassLoader());        System.out.println(&quot;TestClassLoader的父类加载器：&quot; + testClassLoader.getParent());        // 加载 Demo        Class clazz = testClassLoader.loadClass(&quot;com.stefan.DailyTest.classLoader.Demo&quot;);        System.out.println(&quot;Demo的类加载器：&quot; + clazz.getClassLoader());    &#125;&#125;//控制台打印TestClassLoader的父类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2Demo的类加载器：com.stefan.DailyTest.classLoader.TestClassLoader@78308db1</code></pre><p>​<br>​        </p><p><strong>注意破坏双亲委派的位置</strong>，自定义类加载机制先委派给<code>ExtClassLoader</code>加载，<code>ExtClassLoader</code>再委派给<code>BootstrapClassLoader</code>，如果都加载不了，然后自定义类加载器加载，自定义类加载器加载不了才交给<code>AppClassLoader</code>。为什么不能直接让自定义类加载器加载呢？</p><p>不能！双亲委派的破坏只能发生在<code>AppClassLoader</code>及其以下的加载委派顺序，<code>ExtClassLoader</code>上面的双亲委派是不能破坏的！</p><p>因为任何类都是继承自超类<code>java.lang.Object</code>，而加载一个类时，也会加载继承的类，如果该类中还引用了其他类，则按需加载，且类加载器都是加载当前类的类加载器。</p><p>如<code>Demo</code>类只隐式继承了<code>Object</code>，自定义类加载器<code>TestClassLoader</code>加载了<code>Demo</code>，也会加载<code>Object</code>。如果<code>loadClass</code>直接调用<code>TestClassLoader</code>的<code>findClass</code>会报错<code>java.lang.SecurityException: Prohibited package name: java.lang</code>。</p><p>为了安全，<code>java</code>是不允许除<code>BootStrapClassLOader</code>以外的类加载器加载官方<code>java.</code>目录下的类库的。在<code>defineClass</code>源码中，最终会调用<code>native</code>方法<code>defineClass1</code>获取Class对象，在这之前会检查类的全限定名<code>name</code>是否是<code>java.</code>开头。（如果想完全绕开java的类加载，需要自己实现<code>defineClass</code>，但是因为个人能力有限，没有深入研究<code>defineClass</code>的重写，并且一般情况也不会破坏<code>ExtClassLoader</code>以上的双亲委派，除非不用java了。）</p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20210601230854149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjU4NjEyMA==,size_1,color_FFFFFF,t_70%23pic_center"></p><p><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdnimg.cn/20210601230918349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjU4NjEyMA==,size_1,color_FFFFFF,t_70%23pic_center">-<br>通过自定义类加载器破坏双亲委派的案例在日常开发中非常常见，比如Tomcat为了实现web应用间加载隔离，自定义了类加载器，每个<code>Context</code>代表一个web应用，都有一个<code>webappClassLoader</code>。再如热部署、热加载的实现都是需要自定义类加载器的。破坏的位置都是跳过<code>AppClassLoader</code>。</p><h2 id="五、Class-forName默认使用的类加载器"><a href="#五、Class-forName默认使用的类加载器" class="headerlink" title="五、Class.forName默认使用的类加载器"></a>五、Class.forName默认使用的类加载器</h2><ol><li><p> <code>forName(String name, boolean initialize,ClassLoader loader)</code>可以指定<code>classLoader</code>。</p></li><li><p>不显式传<code>classLoader</code>就是默认当前类的类加载器：</p><p> public static Class&lt;?&gt; forName(String className)</p><pre><code>             throws ClassNotFoundException &#123;   Class&lt;?&gt; caller = Reflection.getCallerClass();   return forName0(className, true, ClassLoader.getClassLoader(caller), caller);</code></pre><p> }</p></li></ol><pre><code>​    </code></pre><h2 id="六、线程上下文类加载器"><a href="#六、线程上下文类加载器" class="headerlink" title="六、线程上下文类加载器"></a>六、线程上下文类加载器</h2><p>线程上下文类加载器其实是一种类加载器传递机制。可以通过<code>java.lang.Thread#setContextClassLoader</code>方法给一个线程设置上下文类加载器，在该线程后续执行过程中就能把这个类加载器取（<code>java.lang.Thread#getContextClassLoader</code>）出来使用。</p><p>如果创建线程时未设置上下文类加载器，将会从父线程（<code>parent = currentThread()</code>）中获取，如果在应用程序的全局范围内都没有设置过，就默认是应用程序类加载器。</p><p>线程上下文类加载器的出现就是为了方便破坏双亲委派：</p><blockquote><p>一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK 1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI，Service Provider Interface）的代码，但启动类加载器不可能去加载ClassPath下的类。</p><p>但是有了线程上下文类加载器就好办了，JNDI服务使用线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。</p><p>Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p><p>摘自《深入理解java虚拟机》周志明</p></blockquote><h2 id="七、要点回顾"><a href="#七、要点回顾" class="headerlink" title="七、要点回顾"></a>七、要点回顾</h2><ol><li> java 的类加载，就是获取<code>.class</code>文件的二进制字节码数组并加载到 JVM 的方法区，并在 JVM 的堆区建立一个用来封装 java 类相关的数据和方法的<code>java.lang.Class</code>对象实例。</li><li> java默认有的类加载器有三个，启动类加载器（BootstrapClassLoader），扩展类加载器（ExtClassLoader），应用程序类加载器（也叫系统类加载器）（AppClassLoader）。类加载器之间存在父子关系，这种关系不是继承关系，是组合关系。如果<code>parent=null</code>，则它的父级就是启动类加载器。启动类加载器无法被java程序直接引用。</li><li> 双亲委派就是类加载器之间的层级关系，加载类的过程是一个递归调用的过程，首先一层一层向上委托父类加载器加载，直到到达最顶层启动类加载器，启动类加载器无法加载时，再一层一层向下委托给子类加载器加载。</li><li> 双亲委派的目的主要是为了保证<code>java</code>官方的类库<code>&lt;JAVA_HOME&gt;\lib</code>和扩展类库<code>&lt;JAVA_HOME&gt;\lib\ext</code>的加载安全性，不会被开发者覆盖。</li><li> 破坏双亲委派有两种方式：第一种，自定义类加载器，必须重写<code>findClass</code>和<code>loadClass</code>；第二种是通过线程上下文类加载器的传递性，让父类加载器中调用子类加载器的加载动作。</li></ol><p>参考：</p><ul><li>  《深入理解java虚拟机》周志明（书中对类加载的介绍非常详尽，部分精简整理后引用。）</li><li>  《深入拆解Tomcat &amp; Jetty》Tomcat如何打破双亲委托机制？李号双</li><li>  《Tomcat内核设计剖析》汪建，第十三章 公共与隔离的类加载器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java双亲委派模型&quot;&gt;&lt;a href=&quot;#Java双亲委派模型&quot; class=&quot;headerlink&quot; title=&quot;Java双亲委派模型&quot;&gt;&lt;/a&gt;Java双亲委派模型&lt;/h1&gt;&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;head</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>5.操作系统-进程调度算法</title>
    <link href="https://leslieaibin.github.io/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>https://leslieaibin.github.io/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-03T16:15:42.000Z</published>
    <updated>2021-10-11T05:38:43.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><h2 id="先来先服务调度算法"><a href="#先来先服务调度算法" class="headerlink" title="先来先服务调度算法"></a>先来先服务调度算法</h2><p>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p><h2 id="短作业-进程-优先调度算法"><a href="#短作业-进程-优先调度算法" class="headerlink" title="短作业(进程)优先调度算法"></a>短作业(进程)优先调度算法</h2><p>短作业(进程)优先调度算法，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p><h2 id="时间片轮转法"><a href="#时间片轮转法" class="headerlink" title="时间片轮转法"></a>时间片轮转法</h2><p>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。</p><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><p>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述：</p><p>1）应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，第i+1个队列的时间片要比第i个队列的时间片长一倍。</p><p>2）当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n队列便采取按时间片轮转的方式运行。</p><p>3）仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即第i队列中某个正在运行的进程的时间片用完后，由调度程序选择优先权较高的队列中的那一个进程，把处理机分配给它。</p><h2 id="优先权调度算法"><a href="#优先权调度算法" class="headerlink" title="优先权调度算法"></a>优先权调度算法</h2><p>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。</p><ol><li>非抢占式优先权算法</li></ol><p>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p><ol start="2"><li>抢占式优先权调度算法</li></ol><p>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i时，就将其优先权Pi与正在执行的进程j的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程调度算法&quot;&gt;&lt;a href=&quot;#进程调度算法&quot; class=&quot;headerlink&quot; title=&quot;进程调度算法&quot;&gt;&lt;/a&gt;进程调度算法&lt;/h1&gt;&lt;h2 id=&quot;先来先服务调度算法&quot;&gt;&lt;a href=&quot;#先来先服务调度算法&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>6.死锁的概念</title>
    <link href="https://leslieaibin.github.io/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E6%AD%BB%E9%94%81/"/>
    <id>https://leslieaibin.github.io/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E6%AD%BB%E9%94%81/</id>
    <published>2021-10-03T16:15:42.000Z</published>
    <updated>2022-02-14T00:11:48.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁概念，死锁产生的四个必要条件，如何避免和预防死锁"><a href="#死锁概念，死锁产生的四个必要条件，如何避免和预防死锁" class="headerlink" title="死锁概念，死锁产生的四个必要条件，如何避免和预防死锁"></a>死锁概念，死锁产生的四个必要条件，如何避免和预防死锁</h1><h2 id="一、死锁概念"><a href="#一、死锁概念" class="headerlink" title="一、死锁概念"></a>一、死锁概念</h2><p>死锁是指两个或多个进程在执行的过程中，因为竞争资源而造成互相等待的现象，若无外力作用，它们都无法推进下去。-<br>1.在等待对方时占有不可抢占的资源-<br>举个例子，假设有P1，P2两个进程，都需要A和B两个资源，两个都等待另一个资源而不肯释放资源，就这样无限等待中，这就形成死锁。这只是死锁的一种情况，就是在等待对方时占有不可抢占的资源。-<br>2.竞争可消耗资源引起死锁-<br>有P1，P2，P3三个进程，P1向P2发送消息并接受P3消息，P2向P3发送消息并接受P2消息，P3向P1发送消息并接受P2消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，也造成了死锁。-<br>3.进程推进顺序不当引起死锁-<br>有进程P1，P2，都需要资源A,B，本来可以P1运行A，P1运行B，P2运行B，P2运行A，P2运行B，但顺序换了，P1运行A时P2运行B，容易引发死锁，属于第一种的资源抢占问题。</p><h2 id="二、产生死锁的四个必要条件"><a href="#二、产生死锁的四个必要条件" class="headerlink" title="二、产生死锁的四个必要条件"></a>二、产生死锁的四个必要条件</h2><p>1.互斥条件-<br>一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所使用。此时如果有其他进程请求该资源，则请求进程只能等待。-<br>2.请求与保持条件-<br>进程中已经保持了至少一个资源，但又提出了新的资源请求，而该资源已经被其他进程占有，此时请求进程被阻塞，但对自己已经获得资源保持不放。-<br>3.不可剥夺条件-<br>进程未使用完的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。-<br>4.循环等待条件-<br>若干进程间形成首尾相接循环等待资源的关系。在发生死锁时必然存在一个进程等待队列{P1，P2，…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请。</p><p>注意：这四个条件是死锁的必然条件，只要系统发生死锁，这些条件必然成立。只要有上述条件有一条不满足，就不会发生死锁。</p><h2 id="三、死锁的预防"><a href="#三、死锁的预防" class="headerlink" title="三、死锁的预防"></a>三、死锁的预防</h2><p>我们可以通过破坏产生死锁的四个必要条件来预防死锁，由于资源互斥是固有特性无法改变的。-<br>1.破坏“请求与保持”条件-<br>方法一：静态分配，每个进程在开始执行时就申请他所需要的全部资源。-<br>方法二：动态分配，每个进程在申请所需要的资源时他本身不占用系统资源。-<br>2.破坏“不可剥夺”条件-<br>一个进程不可获得其所需要的全部资源便处于等待状态，等待期间他占用的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。-<br>3.破坏“循环等待”条件-<br>采用资源有序分配的基本思想。将系统中的资源顺序进行编号，将紧缺的、稀少的资源采用较大的编号，申请资源时必须按照编号的顺序执行，一个进程只有较小编号的进程才能申请较大编号的进程。</p><h2 id="四、死锁的避免"><a href="#四、死锁的避免" class="headerlink" title="四、死锁的避免"></a>四、死锁的避免</h2><p>基本思想：系统对进程发出每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则分配。这是一种动态策略。典型的避免死锁的算法试银行家算法。</p><h2 id="五、死锁的检测及解除"><a href="#五、死锁的检测及解除" class="headerlink" title="五、死锁的检测及解除"></a>五、死锁的检测及解除</h2><p>无需采取任何措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时的检测出死锁的发生，然后采取某种措施解除死锁。<br><img src="https://cubox.pro/c/filters:no_upscale()?imageUrl=https://img-blog.csdn.net/20180410144930427?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pXRTc2MTYxNzU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br>死锁的预防和避免都属于事先预防策略，但预防死锁的限制条件较为严格，实现起来较为简单，但往往导致资源利用率低。避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;死锁概念，死锁产生的四个必要条件，如何避免和预防死锁&quot;&gt;&lt;a href=&quot;#死锁概念，死锁产生的四个必要条件，如何避免和预防死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁概念，死锁产生的四个必要条件，如何避免和预防死锁&quot;&gt;&lt;/a&gt;死锁概念，死锁产</summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>4.操作系统-页面置换算法</title>
    <link href="https://leslieaibin.github.io/2021/10/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
    <id>https://leslieaibin.github.io/2021/10/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-02T16:15:42.000Z</published>
    <updated>2021-10-11T05:38:14.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时操作系统必须在内存选择一个页面将其移除内存，以便为即将调入的页面让出空间。而用来选择淘汰那一页的规则叫做页面置换算法。</p><h2 id="最佳置换算法（OPT）（理想置换算法）"><a href="#最佳置换算法（OPT）（理想置换算法）" class="headerlink" title="最佳置换算法（OPT）（理想置换算法）"></a>最佳置换算法（OPT）（理想置换算法）</h2><p>这是一种理想情况下的页面置换算法，但实际上是不可能实现的。该算法的基本思想是：发生缺页时，有些页面在内存中，其中有一页将很快被访问（也包含紧接着的下一条指令的那页），而其他页面则可能要到10、100或者1000条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数进行标记。最佳页面置换算法只是简单地规定：标记最大的页应该被置换。这个算法唯一的一个问题就是它无法实现。当缺页发生时，操作系统无法知道各个页面下一次是在什么时候被访问。虽然这个算法不可能实现，但是最佳页面置换算法可以用于对可实现算法的性能进行衡量比较。</p><h2 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h2><p>最简单的页面置换算法是先入先出（FIFO）法。这种算法的实质是，总是选择在主存中停留时间最长（即最老）的一页置换，即<strong>先进入内存的页，先退出内存</strong>。理由是：最早调入内存的页，其不再被使用的可能性比刚调入内存的可能性大。建立一个FIFO队列，收容所有在内存中的页。被置换页面总是在队列头上进行。当一个页面被放入内存时，就把它插在队尾上。</p><p>这种算法只是在按线性顺序访问地址空间时才是理想的，否则效率不高。因为那些常被访问的页，往往在主存中也停留得最久，结果它们因变“老”而不得不被置换出去。</p><p>FIFO的另一个缺点是，它有一种异常现象，即在增加存储块的情况下，反而使缺页中断率增加了。当然，导致这种异常现象的页面走向实际上是很少见的。</p><h2 id="最近最久未使用（LRU）算法"><a href="#最近最久未使用（LRU）算法" class="headerlink" title="最近最久未使用（LRU）算法"></a>最近最久未使用（LRU）算法</h2><p>FIFO算法和OPT算法之间的主要差别是，FIFO算法利用页面进入内存后的时间长短作为置换依据，而OPT算法的依据是将来使用页面的时间。如果以最近的过去作为不久将来的近似，那么就可以把过去最长一段时间里不曾被使用的页面置换掉。它的实质是，当需要置换一页时，*<strong>*选择在最近一段时间里最久没有使用过的页面予以置换**</strong>。这种算法就称为<strong>最久未使用算法</strong>（Least Recently Used，LRU）。</p><p>LRU算法是与每个页面最后使用的时间有关的。当必须置换一个页面时，LRU算法选择过去一段时间里最久未被使用的页面。</p><p>LRU算法是经常采用的页面置换算法，并被认为是相当好的，但是存在如何实现它的问题。LRU算法需要实际硬件的支持。其问题是怎么确定最后使用时间的顺序，对此有两种可行的办法：</p><ul><li><p>计数器。最简单的情况是使每个页表项对应一个使用时间字段，并给CPU增加一个逻辑时钟或计数器。每次存储访问，该时钟都加1。每当访问一个页面时，时钟寄存器的内容就被复制到相应页表项的使用时间字段中。这样我们就可以始终保留着每个页面最后访问的“时间”。在置换页面时，选择该时间值最小的页面。这样做，不仅要查页表，而且当页表改变时（因CPU调度）要维护这个页表中的时间，还要考虑到时钟值溢出的问题。</p></li><li><p>栈。用一个栈保留页号。每当访问一个页面时，就把它从栈中取出放在栈顶上。这样一来，栈顶总是放有目前使用最多的页，而栈底放着目前最少使用的页。由于要从栈的中间移走一项，所以要用具有头尾指针的双向链连起来。在最坏的情况下，移走一页并把它放在栈顶上需要改动6个指针。每次修改都要有开销，但需要置换哪个页面却可直接得到，用不着查找，因为尾指针指向栈底，其中有被置换页。</p></li></ul><p>因实现LRU算法必须有大量硬件支持，还需要一定的软件开销。所以实际实现的都是一种简单有效的LRU近似算法。</p><p>一种LRU近似算法是<strong>最近未使用算法</strong>（Not Recently Used，NUR）。它在存储分块表的每一表项中增加一个引用位，操作系统定期地将它们置为0。当某一页被访问时，由硬件将该位置1。过一段时间后，通过检查这些位可以确定哪些页使用过，哪些页自上次置0后还未使用过。就可把该位是0的页淘汰出去，因为在最近一段时间里它未被访问过。</p><h2 id="Clock置换算法（LRU算法的近似实现）"><a href="#Clock置换算法（LRU算法的近似实现）" class="headerlink" title="Clock置换算法（LRU算法的近似实现）"></a>Clock置换算法（LRU算法的近似实现）</h2><h2 id="最少使用（LFU）置换算法"><a href="#最少使用（LFU）置换算法" class="headerlink" title="最少使用（LFU）置换算法"></a>最少使用（LFU）置换算法</h2><p>在采用最少使用置换算法时，应为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。由于存储器具有较高的访问速度，例如100 ns，在1 ms时间内可能对某页面连续访问成千上万次，因此，通常不能直接利用计数器来记录某页被访问的次数，而是采用移位寄存器方式。每次访问某页时，便将该移位寄存器的最高位置1，再每隔一定时间(例如100 ns)右移一次。这样，在最近一段时间使用最少的页面将是∑Ri最小的页。</p><p>LFU置换算法的页面访问图与LRU置换算法的访问图完全相同；或者说，利用这样一套硬件既可实现LRU算法，又可实现LFU算法。应该指出，LFU算法并不能真正反映出页面的使用情况，因为在每一时间间隔内，只是用寄存器的一位来记录页的使用情况，因此，访问一次和访问10 000次是等效的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;页面置换算法&quot;&gt;&lt;a href=&quot;#页面置换算法&quot; class=&quot;headerlink&quot; title=&quot;页面置换算法&quot;&gt;&lt;/a&gt;页面置换算法&lt;/h1&gt;&lt;p&gt;地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时操作系统必须在内存选</summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群</title>
    <link href="https://leslieaibin.github.io/2021/10/01/Redis/Redis%E9%9B%86%E7%BE%A4/"/>
    <id>https://leslieaibin.github.io/2021/10/01/Redis/Redis%E9%9B%86%E7%BE%A4/</id>
    <published>2021-10-01T01:15:42.000Z</published>
    <updated>2021-10-11T05:42:10.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis支持三种集群方案"><a href="#Redis支持三种集群方案" class="headerlink" title="Redis支持三种集群方案"></a>Redis支持三种集群方案</h1><ul><li>主从复制模式</li><li>Sentiel(哨兵)模式</li><li>Cluster模式</li></ul><h2 id="Redis集群的三种模式"><a href="#Redis集群的三种模式" class="headerlink" title="Redis集群的三种模式"></a>Redis集群的三种模式</h2><h3 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000022808581" alt="img"></p><p><strong>主从复制作用</strong></p><p>通过持久化功能，Redis保证了即使服务器重启的情况下也不会丢失（或少量丢失）数据，因为持久化会把内存中数据保存到硬盘上，重启会从硬盘上加载数据。但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。</p><p>为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使一台服务器出现故障，其他服务器依然可以继续提供服务。</p><p>为此，<strong>Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上</strong>。</p><p>在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库(slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。</p><p><strong>总结：引入主从复制机制的目的有两个</strong></p><ul><li>一个是读写分离，分担 “master” 的读写压力</li><li>一个是方便做容灾恢复</li></ul><h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a><strong>主从复制原理</strong></h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1460000022808583" alt="img"></p><ul><li>从数据库启动成功后，连接主数据库，发送 SYNC 命令；</li><li>主数据库接收到 SYNC 命令后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；</li><li>主数据库 BGSAVE 执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令；</li><li>从数据库收到快照文件后丢弃所有旧数据，载入收到的快照；</li><li>主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令；</li><li>从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令；（<strong>从数据库初始化完成</strong>）</li><li>主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（<strong>从数据库初始化完成后的操作</strong>）</li><li>出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库，增量复制。</li><li>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li></ul><h4 id="主从复制优缺点"><a href="#主从复制优缺点" class="headerlink" title="主从复制优缺点"></a>主从复制优缺点</h4><p><strong>主从复制优点</strong></p><ul><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离；</li><li>为了分载 Master 的读操作压力，Slave 服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成；</li><li>Slave 同样可以接受其它 Slaves 的连接和同步请求，这样可以有效的分载 Master 的同步压力；</li><li>Master Server 是以非阻塞的方式为 Slaves 提供服务。所以在 Master-Slave 同步期间，客户端仍然可以提交查询或修改请求；</li><li>Slave Server 同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据；</li></ul><p><strong>主从复制缺点</strong></p><ul><li>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复（<strong>也就是要人工介入</strong>）；</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性；</li><li>如果多个 Slave 断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要 Slave 启动，就会发送sync 请求和主机全量同步，当多个 Slave 重启的时候，可能会导致 Master IO 剧增从而宕机。</li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂；</li></ul><h3 id="Sentinel（哨兵）模式"><a href="#Sentinel（哨兵）模式" class="headerlink" title="Sentinel（哨兵）模式"></a>Sentinel（哨兵）模式</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis支持三种集群方案&quot;&gt;&lt;a href=&quot;#Redis支持三种集群方案&quot; class=&quot;headerlink&quot; title=&quot;Redis支持三种集群方案&quot;&gt;&lt;/a&gt;Redis支持三种集群方案&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;主从复制模式&lt;/li&gt;
&lt;li&gt;Sent</summary>
      
    
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式限流</title>
    <link href="https://leslieaibin.github.io/2021/09/30/Redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81/"/>
    <id>https://leslieaibin.github.io/2021/09/30/Redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81/</id>
    <published>2021-09-30T01:15:42.000Z</published>
    <updated>2021-09-30T08:44:26.803Z</updated>
    
    <content type="html"><![CDATA[<p>由于互联网公司的流量巨大，系统上线会做一个流量峰值的评估，尤其是像各种秒杀促销活动，为了保证系统不被巨大的流量压垮，会在系统流量到达一定阈值时，拒绝掉一部分流量。</p><p>限流会导致用户在短时间内（这个时间段是毫秒级的）系统不可用，一般我们衡量系统处理能力的指标是每秒的<code>QPS</code>或者<code>TPS</code>，假设系统每秒的流量阈值是1000，理论上一秒内有第1001个请求进来时，那么这个请求就会被限流。</p><h1 id="限流方案"><a href="#限流方案" class="headerlink" title="限流方案"></a>限流方案</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>Java内部可以通过原子类计数器<code>AtomicInteger</code>、<code>Semaphore</code>信号量来做简单的限流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限流的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxCount = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 指定时间内</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> interval = <span class="number">60</span>;</span><br><span class="line"><span class="comment">// 原子类计数器</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 起始时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> startTime = System.currentTimeMills();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">limit</span><span class="params">(<span class="keyword">int</span> maxCount, <span class="keyword">int</span> interval)</span> </span>&#123;</span><br><span class="line">    atomicInteger.addAndGet(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (atomicInteger.get() == <span class="number">1</span>) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        atomicInteger.addAndGet(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过了间隔时间，直接重新开始计数</span></span><br><span class="line">    <span class="keyword">if</span> (System.currentTimeMillis() - startTime &gt; interval * <span class="number">1000</span>) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        atomicInteger.set(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还在间隔时间内,check有没有超过限流的个数</span></span><br><span class="line">    <span class="keyword">if</span> (atomicInteger.get() &gt; maxCount) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法思路很简单，我们把水比做请求，漏桶比做是系统处理能力极限，水先进入到漏桶里，漏桶里的水按一定速率流出，当流出速率小于流入的速率时，由于漏桶容量有限，后续进入的水直接溢出（拒绝请求），以此实现限流。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210930162736284.png" alt="image-20210930162736284"></p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法的原理也比较简单，可以理解成医院的挂号看病，只要拿到号以后才可以进行诊病。</p><p>系统会维护 一个令牌（token）桶，以一个恒定的速度往桶里放入令牌（token），这时如果有请求进来想要被处理，则需要先从桶里获取一个令牌（token）, 当桶里没有令牌（token）可取时，则该请求将被拒绝服务。令牌桶算法通过控制桶的容量，发放令牌的速率，来达到对请求的限制。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210930163437254.png" alt="image-20210930163437254"></p><h2 id="Redis-Lua"><a href="#Redis-Lua" class="headerlink" title="Redis + Lua"></a>Redis + Lua</h2><p>个人理解，<code>Lua</code>脚本和 <code>MySQL</code>数据库的存储过程比较相似，他们执行一组命令，所有命令的执行要么全部成功或者失败，以此达到原子性。也可以把<code>Lua</code>脚本理解为，一段具有业务逻辑的代码块。</p><p>而<code>Lua</code>本身就是一种编程语言，虽然<code>redis</code> 官方没有直接提供限流相应的<code>API</code>，但却支持了 <code>Lua</code> 脚本的功能，可以使用它实现复杂的令牌桶或漏桶算法，也是分布式系统中实现限流的主要方式之一。</p><p>相比<code>Redis</code>事务，<code>Lua脚本</code>的优点：</p><ul><li>减少网络开销：使用<code>Lua</code>脚本，无需向<code>Redis</code> 发送多次请求，执行一次即可，减少网络传输</li><li>原子操作：<code>Redis</code> 将整个<code>Lua</code>脚本作为一个命令执行，原子，无需担心并发</li><li>复用：<code>Lua</code>脚本一旦执行，会永久保存 <code>Redis</code> 中,，其他客户端可复用</li></ul><p><code>Lua</code>脚本大致逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 获取调用脚本时传入的第一个key值（用作限流的 key）</span><br><span class="line">local key = KEYS[<span class="number">1</span>]</span><br><span class="line">-- 获取调用脚本时传入的第一个参数值（限流大小）</span><br><span class="line">local limit = tonumber(ARGV[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">-- 获取当前流量大小</span><br><span class="line">local curentLimit = tonumber(redis.call(<span class="string">&#x27;get&#x27;</span>, key) or <span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">-- 是否超出限流</span><br><span class="line"><span class="keyword">if</span> curentLimit + <span class="number">1</span> &gt; limit then</span><br><span class="line">    -- 返回(拒绝)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    -- 没有超出 value + <span class="number">1</span></span><br><span class="line">    redis.call(<span class="string">&quot;INCRBY&quot;</span>, key, <span class="number">1</span>)</span><br><span class="line">    -- 设置过期时间</span><br><span class="line">    redis.call(<span class="string">&quot;EXPIRE&quot;</span>, key, <span class="number">2</span>)</span><br><span class="line">    -- 返回(放行)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>通过<code>KEYS[1]</code> 获取传入的key参数</li><li>通过<code>ARGV[1]</code>获取传入的<code>limit</code>参数</li><li><code>redis.call</code>方法，从缓存中<code>get</code>和<code>key</code>相关的值，如果为<code>null</code>那么就返回0</li><li>接着判断缓存中记录的数值是否会大于限制大小，如果超出表示该被限流，返回0</li><li>如果未超过，那么该key的缓存值+1，并设置过期时间为1秒钟以后，并返回缓存值+1</li></ul><p>这种方式是本文推荐的方案，具体实现会在后边做细说。</p><h2 id="网关层限流"><a href="#网关层限流" class="headerlink" title="网关层限流"></a>网关层限流</h2><p>限流常在网关这一层做，比如<code>Nginx</code>、<code>Openresty</code>、<code>kong</code>、<code>zuul</code>、<code>Spring Cloud Gateway</code>等，而像<code>spring cloud - gateway</code>网关限流底层实现原理，就是基于<code>Redis + Lua</code>，通过内置<code>Lua</code>限流脚本的方式。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/640" alt="图片"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于互联网公司的流量巨大，系统上线会做一个流量峰值的评估，尤其是像各种秒杀促销活动，为了保证系统不被巨大的流量压垮，会在系统流量到达一定阈值时，拒绝掉一部分流量。&lt;/p&gt;
&lt;p&gt;限流会导致用户在短时间内（这个时间段是毫秒级的）系统不可用，一般我们衡量系统处理能力的指标是每秒</summary>
      
    
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://leslieaibin.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>3.操作系统-IO模型</title>
    <link href="https://leslieaibin.github.io/2021/09/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.IO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://leslieaibin.github.io/2021/09/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.IO%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-09-29T16:15:42.000Z</published>
    <updated>2021-09-30T08:47:28.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210927141630387.png" alt="image-20210927141630387"></p><p>IO (Input/Output，输入/输出)即数据的读取（接收）或写入（发送）操作，通常用户进程中的一个完整IO分为两阶段：用户进程空间&lt;–&gt;内核空间、内核空间&lt;–&gt;设备空间（磁盘、网络等）。IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。</p><p>LINUX中进程无法直接操作I/O设备，其必须通过系统调用请求kernel来协助完成I/O动作；内核会为每个I/O设备维护一个缓冲区。</p><p>对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，没有的话再到设备中读取，因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间。</p><p>所以，对于一个网络输入操作通常包括两个不同阶段：</p><ul><li><p>等待网络数据到达网卡→读取到内核缓冲区，数据准备好；</p></li><li><p>从内核缓冲区复制数据到进程空间。</p><p><strong>从TCP发送数据的流程说起</strong></p></li></ul><p>要深入的理解各种IO模型，那么必须先了解下产生各种IO的原因是什么，要知道这其中的本质问题那么我们就必须要知一条消息是如何从过一个人发送到另外一个人的；</p><p>以两个应用程序通讯为例，我们来了解一下当“A”向”B” 发送一条消息，简单来说会经过如下流程：</p><p><strong>第一步</strong>：应用A把消息发送到 TCP发送缓冲区。</p><p><strong>第二步：</strong> TCP发送缓冲区再把消息发送出去，经过网络传递后，消息会发送到B服务器的TCP接收缓冲区。</p><p><strong>第三步：</strong>B再从TCP接收缓冲区去读取属于自己的数据。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-5311954c22d15ca91e47ab52168b7ada_720w.jpg" alt="img"></p><p>根据上图我们基本上了解消息发送要经过 应用A、应用A对应服务器的TCP发送缓冲区、经过网络传输后消息发送到了应用B对应服务器TCP接收缓冲区、然后最终B应用读取到消息。</p><p>《UNIX网络编程》说得很清楚，5种IO模型分别是阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动的IO模型、异步IO模型；前4种为同步IO操作，只有异步IO模型是异步IO操作。</p><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p><strong>思考一个问题：</strong></p><p>因为应用之间发送消息是间断性的，也就是说在上图中TCP缓冲区还没有接收到属于应用B该读取的消息时，那么此时应用B向TCP缓冲区发起读取申请，TCP接收缓冲区是应该马上告诉应用B 现在没有你的数据，还是说让应用B在这里等着，直到有数据再把数据交给应用B。</p><p>把这个问题应用到第一个步骤也是一样，应用A在向TCP发送缓冲区发送数据时，如果TCP发送缓冲区已经满了，那么是告诉应用A现在没空间了，还是让应用A等待着，等TCP发送缓冲区有空间了再把应用A的数据访拷贝到发送缓冲区。</p><p><strong>什么是阻塞IO</strong></p><p>阻塞IO就是当应用B发起读取数据申请时，在内核数据没有准备好之前，应用B会一直处于等待数据状态，直到内核把数据准备好了交给应用B才结束。</p><p><strong>术语描述</strong>：在应用调用recvfrom读取数据时，其系统调用直到数据包到达且被复制到应用缓冲区中或者发送错误时才返回，在此期间一直会等待，进程从调用到返回这段时间内都是被阻塞的称为阻塞IO；</p><p><strong>流程：</strong></p><p>1、应用进程向内核发起recfrom读取数据。</p><p>2、准备数据报（应用进程阻塞）。</p><p>3、将数据从内核负责到应用空间。</p><p>4、复制完成后，返回成功提示。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210927142530568.png" alt="image-20210927142530568"></p><p><strong>1、典型应用：阻塞socket、Java BIO；</strong></p><p><strong>2、特点：</strong></p><ul><li>进程阻塞挂起不消耗CPU资源，及时响应每个操作；</li><li>实现难度低、开发应用较容易；</li><li>适用并发量小的网络应用开发；</li></ul><p>不适用并发量大的应用：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。</p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>非阻塞IO就是当应用B发起读取数据申请时，如果内核数据没有准备好会即刻告诉应用B，不会让B在这里等待。</p><p><strong>术语</strong>：非阻塞IO是在应用调用recvfrom读取数据时，如果该缓冲区没有数据的话，就会直接返回一个EWOULDBLOCK错误，不会让应用一直等待中。在没有数据的时候会即刻返回错误标识，那也意味着如果应用要读取数据就需要不断的调用recvfrom请求，直到读取到它数据要的数据为止。</p><p><strong>流程：</strong></p><p>1、应用进程向内核发起recvfrom读取数据。</p><p>2、没有数据报准备好，即刻返回EWOULDBLOCK错误码。</p><p>3、应用进程向内核发起recvfrom读取数据。</p><p>4、已有数据包准备好就进行一下 步骤，否则还是返回错误码。</p><p>5、将数据从内核拷贝到用户空间。</p><p>6、完成后，返回成功提示。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210927155649702.png" alt="image-20210927155649702"></p><p>1、典型应用：socket是非阻塞的方式（设置为NONBLOCK）</p><p>2、特点：</p><ul><li>进程轮询（重复）调用，消耗CPU的资源；</li><li>实现难度低、开发应用相对阻塞IO模式较难；</li><li>适用并发量较小、且不需要及时响应的网络应用开发；</li></ul><h2 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a><strong>IO复用模型</strong></h2><p><strong>思考一个问题：</strong></p><p>我们还是把视角放到应用B从TCP缓冲区中读取数据这个环节来。如果在并发的环境下，可能会N个人向应用B发送消息，这种情况下我们的应用就必须创建多个线程去读取数据，每个线程都会自己调用recvfrom 去读取数据。那么此时情况可能如下图：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-529734ac694c4da96ac78eeebd7deb6b_720w.jpg" alt="img"></p><p>如上图一样，并发情况下服务器很可能一瞬间会收到几十上百万的请求，这种情况下应用B就需要创建几十上百万的线程去读取数据，同时又因为应用线程是不知道什么时候会有数据读取，为了保证消息能及时读取到，那么这些线程自己必须不断的向内核发送recvfrom 请求来读取数据；</p><p>那么问题来了，这么多的线程不断调用recvfrom 请求数据，先不说服务器能不能扛得住这么多线程，就算扛得住那么很明显这种方式是不是太浪费资源了，线程是我们操作系统的宝贵资源，大量的线程用来去读取数据了，那么就意味着能做其它事情的线程就会少。</p><p>所以，有人就提出了一个思路，能不能提供一种方式，可以由一个线程监控多个网络请求（<strong>我们后面将称为fd文件描述符，linux系统把所有网络请求以一个fd来标识</strong>），这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO复用模型的思路。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-2c65fd3534e58d3a54cdeae778a31446_720w.jpg" alt="img"></p><p>正如上图，IO复用模型的思路就是系统提供了一种函数可以同时监控多个fd的操作，这个函数就是我们常说到的select、poll、epoll函数，有了这个函数后，应用线程通过调用select函数就可以同时监控多个fd，select函数监控的fd中只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时询问线程再去通知处理数据的线程，对应线程此时再发起recvfrom请求去读取数据。</p><p><strong>术语描述：</strong>进程通过将一个或多个fd传递给select，阻塞在select操作上，select帮我们侦测多个fd是否准备就绪，当有fd准备就绪时，select返回数据可读状态，应用程序再调用recvfrom读取数据。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210927160639013.png" alt="image-20210927160639013"></p><p>复用IO的基本思路就是通过slect或poll、epoll 来监控多fd ，来达到不必为每个fd创建一个对应的监控线程，从而减少线程资源创建的目的。</p><p>可以看到，多个进程注册IO后，只有另一个select调用进程被阻塞。</p><p>1、典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;Java NIO;</p><p>2、特点：</p><ul><li>专一进程解决多个进程IO的阻塞问题，性能好；Reactor模式;</li><li>实现、开发应用难度较大；</li><li>适用高并发服务应用开发：一个进程（线程）响应多个请求；</li></ul><p>3、select、poll、epoll</p><ul><li>Linux中IO复用的实现方式主要有select、poll和epoll：</li><li>Select：注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_SIZE；</li><li>Poll：原理和Select相似，没有数量限制，但IO数量大扫描线性性能下降；</li><li>Epoll ：事件驱动不阻塞，mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持；</li></ul><h2 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a><strong>信号驱动IO模型</strong></h2><p>复用IO模型解决了一个线程可以监控多个fd的问题，但是select是采用轮询的方式来监控多个fd的，通过不断的轮询fd的可读状态来知道是否就可读的数据，而无脑的轮询就显得有点暴力，因为大部分情况下的轮询都是无效的，所以有人就想，能不能不要我总是去问你是否数据准备就绪，能不能我发出请求后等你数据准备好了就通知我，所以就衍生了信号驱动IO模型。</p><p>于是信号驱动IO不是用循环请求询问的方式去监控数据就绪状态，而是在调用sigaction时候建立一个SIGIO的信号联系，当内核数据准备好之后再通过SIGIO信号通知线程数据准备好后的可读状态，当线程收到可读状态的信号后，此时再向内核发起recvfrom读取数据的请求，因为信号驱动IO的模型下应用线程在发出信号监控后即可返回，不会阻塞，所以这样的方式下，一个应用线程也可以同时监控多个fd。</p><p>类似于下图描述：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-2461c8df6a154930afb4e7c345442835_720w.jpg" alt="img"></p><p><strong>术语描述：</strong>首先开启套接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数，此时请求即刻返回，当数据准备就绪时，就生成对应进程的SIGIO信号，通过信号回调通知应用线程调用recvfrom来读取数据。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210927161210407.png" alt="image-20210927161210407"></p><p> IO复用模型里面的select虽然可以监控多个fd了，但select其实现的本质上还是通过不断的轮询fd来监控数据状态， 因为大部分轮询请求其实都是无效的，所以信号驱动IO意在通过这种建立信号关联的方式，实现了发出请求后只需要等待数据就绪的通知即可，这样就可以避免大量无效的数据状态轮询操作。</p><p>特点：回调机制，实现、开发应用难度大；</p><h2 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a><strong>异步IO模型</strong></h2><p>不管是IO复用还是信号驱动，我们要读取一个数据总是要发起两阶段的请求，第一次发送select请求，询问数据状态是否准备好，第二次发送recevform请求读取数据。</p><p><strong>思考一个问题：</strong></p><p>也许你一开始就有一个疑问，为什么我们明明是想读取数据，什么非得要先发起一个select询问数据状态的请求，然后再发起真正的读取数据请求,能不能有一种一劳永逸的方式，我只要发送一个请求我告诉内核我要读取数据，然后我就什么都不管了，然后内核去帮我去完成剩下的所有事情？</p><p>当然既然你想得出来，那么就会有人做得到，有人设计了一种方案，应用只需要向内核发送一个read 请求,告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，内核会主动把数据从内核复制到用户空间，等所有操作都完成之后，内核会发起一个通知告诉应用，我们称这种一劳永逸的模式为异步IO模型。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-96009f54d89ade0d8c4001bc67395c57_720w.jpg" alt="img"></p><p><strong>术语描述：</strong> 应用告知内核启动某个操作，并让内核在整个操作完成之后，通知应用，这种模型与信号驱动模型的主要区别在于，信号驱动IO只是由内核通知我们合适可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210927161941186.png" alt="image-20210927161941186"></p><p><strong>总结：</strong>异步IO的优化思路是解决了应用程序需要先后发送询问请求、发送接收数据请求两个阶段的模式，在异步IO的模式下，只需要向内核发送一次请求就可以完成状态询问和数拷贝的所有操作。</p><h2 id="IO模型比较"><a href="#IO模型比较" class="headerlink" title="IO模型比较"></a><strong>IO模型比较</strong></h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210927164055422.png" alt="image-20210927164055422"></p><h3 id="阻塞IO调用和非阻塞IO调用、阻塞IO模型和非阻塞IO模型"><a href="#阻塞IO调用和非阻塞IO调用、阻塞IO模型和非阻塞IO模型" class="headerlink" title="阻塞IO调用和非阻塞IO调用、阻塞IO模型和非阻塞IO模型"></a><strong>阻塞IO调用和非阻塞IO调用、阻塞IO模型和非阻塞IO模型</strong></h3><p>注意这里的阻塞IO调用和非阻塞IO调用不是指阻塞IO模型和非阻塞IO模型：</p><ul><li>阻塞IO调用 ：在用户进程（线程）中调用执行的时候，进程会等待该IO操作，而使得其他操作无法执行。</li><li>非阻塞IO调用：在用户进程中调用执行的时候，无论成功与否，该IO操作会立即返回，之后进程可以进行其他操作（当然如果是读取到数据，一般就接着进行数据处理）。</li></ul><p>这个直接理解就好，进程（线程）IO调用会不会阻塞进程自己。所以这里两个概念是相对调用进程本身状态来讲的。</p><p>从上面对比图片来说，阻塞IO模型是一个阻塞IO调用，而非阻塞IO模型是多个非阻塞IO调用+一个阻塞IO调用，因为多个IO检查会立即返回错误，不会阻塞进程。</p><p>而上面也说过了，非阻塞IO模型对于阻塞IO模型来说区别就是，内核数据没准备好需要进程阻塞的时候，就返回一个错误，以使得进程不被阻塞。</p><h3 id="同步IO和异步IO"><a href="#同步IO和异步IO" class="headerlink" title="同步IO和异步IO"></a><strong>同步IO和异步IO</strong></h3><ul><li>同步IO：导致请求进程阻塞，直到I/O操作完成。</li><li>异步IO：不导致请求进程阻塞。</li></ul><p>上面两个定义是《UNIX网络编程 卷1：套接字联网API》给出的。这不是很好理解，我们来扩展一下，先说说同步和异步，同步和异步关注的是双方的消息通信机制：</p><ul><li>同步：双方的动作是经过双方协调的，步调一致的。</li><li>异步：双方并不需要协调，都可以随意进行各自的操作。</li></ul><p>这里我们的双方是指，用户进程和IO设备；明确同步和异步之后，我们在上面网络输入操作例子的基础上，进行扩展定义：</p><ul><li>同步IO：用户进程发出IO调用，去获取IO设备数据，双方的数据要经过内核缓冲区同步，完全准备好后，再复制返回到用户进程。而复制返回到用户进程会导致请求进程阻塞，直到I/O操作完成。</li><li>异步IO：用户进程发出IO调用，去获取IO设备数据，并不需要同步，内核直接复制到进程，整个过程不导致请求进程阻塞。</li></ul><p>所以， 阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动的IO模型者为同步IO模型，只有异步IO模型是异步IO。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20</summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
