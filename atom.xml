<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Ai</title>
  
  <subtitle>春暖花开去见你</subtitle>
  <link href="https://leslieaibin.github.io/atom.xml" rel="self"/>
  
  <link href="https://leslieaibin.github.io/"/>
  <updated>2021-08-20T12:14:50.022Z</updated>
  <id>https://leslieaibin.github.io/</id>
  
  <author>
    <name>Leslie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2.Java集合</title>
    <link href="https://leslieaibin.github.io/2021/08/20/Collection/2.%E9%9B%86%E5%90%88[2]/"/>
    <id>https://leslieaibin.github.io/2021/08/20/Collection/2.%E9%9B%86%E5%90%88[2]/</id>
    <published>2021-08-19T16:15:42.000Z</published>
    <updated>2021-08-20T12:14:50.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合容器概述"><a href="#集合容器概述" class="headerlink" title="集合容器概述"></a>集合容器概述</h1><h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><ul><li>集合就是一个放数据的容器，准确的说是放数据对象引用的容器</li><li>集合类存放的都是对象的引用，而不是对象的本身</li><li>集合类型主要有三种： set(集)、list(列表) 和 map(映射)</li></ul><h2 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h2><ul><li><p>集合用于存储对象的容器，对象是用来封装数据，对象多了也需要存储集中式管理</p></li><li><p>和数组对比对象的大小是不确定的，集合的长度是可变的，数组需要提前定义大小</p></li></ul><h2 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h2><ul><li>数组是 固定长度的，集合可变长度的</li><li>数组可以存储基本数据类型，也可以存储引用数据类型，集合只能存储引用数据类型</li><li>数组存储的元素必须是同一个数据类型，集合存储的对象可以是不同数据类型</li></ul><h2 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h2><ul><li>容量自增长</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量</li><li>可以方便的扩展或改写集合，提高代码复用性和可操作性</li><li>通过使用JDK自带的集合类，降低代码维护和学习新API成本</li></ul><h2 id="常用的集合类有哪些"><a href="#常用的集合类有哪些" class="headerlink" title="常用的集合类有哪些"></a>常用的集合类有哪些</h2><ul><li>Map接口和Collection接口是所有集合框架的父接口</li><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要包括：HashMap、TreeMap、Hashtable、weakHashMap等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有： ArrayList、LinkedList、Stack以及Vector等</li></ul><h2 id="List、Map-、Set三者的区别"><a href="#List、Map-、Set三者的区别" class="headerlink" title="List、Map 、Set三者的区别"></a>List、Map 、Set三者的区别</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e70de4bd~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li><p>Java容器分为Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</p></li><li><p>Collection 集合主要有List 和 Set 两大接口</p><ul><li>List：一个有序的（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有ArrayList、LinkedList 和 Vector</li><li>Set：一个无序的（存入和取出顺序有可能不一致）容器，不可以存储重复元素，值允许存入一个null 元素，必须保证元素的唯一性。Set接口常用实现类 HashSet、LinkedHashSet 以及 TreeSet。</li></ul></li><li><p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p><ul><li>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</li></ul></li></ul><h2 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h2><ul><li><p>List </p><ul><li>ArrayList：Object数组</li><li>Vector: Object数组</li><li>LinkedList：双向循环链表</li></ul></li><li><p>Set</p><ul><li>HashSet（无序，唯一）：基于HashMap实现的，底层采用HashMap来保存元素</li><li>LinkedHashSet：LinkedHashSet继承与HashSet，并且其内部是通过LinkedHashMap实现的。</li><li>TreeSet(有序，唯一)： 红黑树（自平衡的排序二叉树）</li></ul></li><li><p>Map</p><ul><li>HashMap：JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要解决哈希冲突而存在的（”拉链法”解决冲突）JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转换为红黑树，以减少搜索时间</li><li>LinkedHashMap：LinkedHashMap 继承自HashMap，所以它的底层也是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap在上面结构基础上，增加一条双向链表，使得上面的结构可以保持键值对的插入顺序，同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable：数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul></li></ul><h2 id="那些集合类是线程安全的"><a href="#那些集合类是线程安全的" class="headerlink" title="那些集合类是线程安全的"></a>那些集合类是线程安全的</h2><ul><li>Vector：就比Arraylist 多个synchronized(线程安全)，因为效率较低，不建议使用</li><li>hashTable：就比hashMap多了个Synchronized（线程安全），不建议使用</li><li>ConcurrentHashMap：是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。（推荐使用）</li></ul><h2 id="Java集合的快速失败机制-“fail-fast”？"><a href="#Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”？"></a>Java集合的快速失败机制 “fail-fast”？</h2><ul><li><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p></li><li><p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p></li><li><p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p></li><li><p>解决办法：</p><ol><li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li><li>使用CopyOnWriteArrayList来替换ArrayList</li></ol></li></ul><h2 id="怎样确保一个集合不能被修改"><a href="#怎样确保一个集合不能被修改" class="headerlink" title="怎样确保一个集合不能被修改"></a>怎样确保一个集合不能被修改</h2><ul><li>可以使用Collections.unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任操作都会抛出Java.lang.UnsupportedOperationException异常</li></ul><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><h3 id="迭代器Iterator是什么"><a href="#迭代器Iterator是什么" class="headerlink" title="迭代器Iterator是什么"></a>迭代器Iterator是什么</h3><ul><li><p>Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器允许调用者在迭代过程中移除元素</p></li><li><p>所有Collection接继承了Iterator迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Iterator-怎么使用-，有什么特点"><a href="#Iterator-怎么使用-，有什么特点" class="headerlink" title="Iterator 怎么使用 ，有什么特点"></a>Iterator 怎么使用 ，有什么特点</h3><ul><li><p>Iterator使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String obj = it.next();</span><br><span class="line">    Sysrtem.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Iterator的特点是只能单向遍历，但是更加安全，因为他可以确保在当前遍历集合元素被更改的时候，就会抛出ConcurrentModificationException 异常。</p></li></ul><h3 id="如何边遍历边移除-Collection-中的元素"><a href="#如何边遍历边移除-Collection-中的元素" class="headerlink" title="如何边遍历边移除 Collection 中的元素"></a>如何边遍历边移除 Collection 中的元素</h3><ul><li><p>边遍历边修改Collection的正确方式是使用Iterator.remove()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的</span></span><br><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    it.romove();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误的</span></span><br><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">   list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p></li></ul><h3 id="Iterator-和-ListIterator-有什么区别"><a href="#Iterator-和-ListIterator-有什么区别" class="headerlink" title="Iterator 和 ListIterator 有什么区别"></a>Iterator 和 ListIterator 有什么区别</h3><ul><li>Iterator可以遍历Set 和 List 集合，而ListIterator 只能遍历List</li><li>Iterator只能单向遍历，而ListIterator可以双向遍历（向前/先后）</li><li>LsitIterator实现Iterator接口，然后添加了一些额外的功能，比如添加一个元素，替换一个元素，获取前面或后面的元素的索引位置</li></ul><h3 id="遍历一个-List-有哪些不同的方式，每种方法的实现原理是什么，Java-中-List-遍历的最佳实践是什么"><a href="#遍历一个-List-有哪些不同的方式，每种方法的实现原理是什么，Java-中-List-遍历的最佳实践是什么" class="headerlink" title="遍历一个 List 有哪些不同的方式，每种方法的实现原理是什么，Java 中 List 遍历的最佳实践是什么"></a>遍历一个 List 有哪些不同的方式，每种方法的实现原理是什么，Java 中 List 遍历的最佳实践是什么</h3><p><strong>方式三种：</strong></p><ul><li>for循环遍历，基于计数器。在集合外部维护一个计数器，然后一次读取每个位置的元素，当读取到最后一个元素停止</li><li>迭代器遍历，Iterator。Iterator是面向对象的一个设计模式，目的设计屏蔽不同数据集合的特点，统一遍历集合接口。Java在Collection中支持Iterator模式</li><li>foreach循环遍历。foreach内部也是采用了Iterator的方式实现，使用时不需要显示声明Iterator或计数器。优点：代码简洁，缺点是只能做简单的遍历，不能在遍历过程中操作数据集合（删除，替换）</li></ul><p><strong>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</strong></p><ul><li>推荐做法，支持Random Access的列表可用for循环遍历，否则建议使用Iterator 或 foreach遍历</li><li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li><li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li></ul><h3 id="说一下ArrayList的优缺点"><a href="#说一下ArrayList的优缺点" class="headerlink" title="说一下ArrayList的优缺点"></a>说一下ArrayList的优缺点</h3><ul><li>ArrayList的优点如下<ul><li>ArrayList底层是以数组实现的，是一种随机访问模式。ArrayList实现了RandomAccess接口，因此查找的时候非常快</li><li>ArrayList在顺序添加一个元素的时候非常方便。</li></ul></li><li>ArrayList的缺点<ul><li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能</li><li>插入元素的时候也需要做一次元素复制，缺点同上</li></ul></li><li>ArrayList比较适合顺序添加，随机访问的场景</li></ul><h3 id="如何实现数组和List之间的转换"><a href="#如何实现数组和List之间的转换" class="headerlink" title="如何实现数组和List之间的转换"></a>如何实现数组和List之间的转换</h3><ul><li>数组转List: Arrays.asList(array)进行转换</li><li>List转换数组：使用 List 自带的 toArray() 方法</li></ul><h3 id="ArrayList-和-LinkedList的区别是什么"><a href="#ArrayList-和-LinkedList的区别是什么" class="headerlink" title="ArrayList 和 LinkedList的区别是什么"></a>ArrayList 和 LinkedList的区别是什么</h3><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li><li>LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</li></ul><h3 id="ArrayList-和-Vector-的区别是什么"><a href="#ArrayList-和-Vector-的区别是什么" class="headerlink" title="ArrayList 和 Vector 的区别是什么"></a>ArrayList 和 Vector 的区别是什么</h3><ul><li><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p><ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul></li><li><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p></li><li><p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p></li></ul><h3 id="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？"></a>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</h3><ul><li>ArrayList和Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</li><li>Vector 中的方法由于加了 synchronized 修饰，因此 <strong>Vector</strong> <strong>是线程安全容器，但性能上较ArrayList差</strong>。</li><li>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 <strong>LinkedList</strong> <strong>插入速度较快</strong>。</li></ul><h3 id="多线程场景下如何使用ArrayList"><a href="#多线程场景下如何使用ArrayList" class="headerlink" title="多线程场景下如何使用ArrayList"></a>多线程场景下如何使用ArrayList</h3><ul><li>ArrayList不是线程安全的，如果遇到多线程场景，可以通过Collections 的 synchronizedList 方法将其转换成线程安全的容器在使用</li></ul><h3 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a>List 和 Set 的区别</h3><ul><li>List，Set 都是继承自Collection接口</li><li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li><li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li><li>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</li><li>Set和List对比<ul><li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li><li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</li></ul></li></ul><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><h3 id="说下HashSet的实现原理"><a href="#说下HashSet的实现原理" class="headerlink" title="说下HashSet的实现原理"></a>说下HashSet的实现原理</h3><ul><li>HashSet是基于HashMap实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为present，因此HashSet的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</li></ul><h3 id="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"><a href="#HashSet如何检查重复？HashSet是如何保证数据不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h3><ul><li><p>向HashSet中add()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equals方法比较。</p></li><li><p>HashSet中的add()方法会使用HashMap()的putf()方法</p></li><li><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p></li></ul><h3 id="hashCode（）与equals（）的相关规定："><a href="#hashCode（）与equals（）的相关规定：" class="headerlink" title="hashCode（）与equals（）的相关规定："></a><strong>hashCode（）与equals（）的相关规定</strong>：</h3><ol><li>如果两个对象相等，则hashcode一定也是相同的<ul><li>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值</li></ul></li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals 的区别"></a>== 和 equals 的区别</h3><ul><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例指向的内存空间值是不是相同的</li><li>== 是指对内存地址进行比较 equals()是对字符串</li></ul><h3 id="HashSet-与-HashMap的区别"><a href="#HashSet-与-HashMap的区别" class="headerlink" title="HashSet 与 HashMap的区别"></a>HashSet 与 HashMap的区别</h3><table><thead><tr><th align="center">HashMap</th><th align="center">HashSet</th></tr></thead><tbody><tr><td align="center">实现了Map接口</td><td align="center">实现Set接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用put（）向map中添加元素</td><td align="center">调用add（）方法向Set中添加元素</td></tr><tr><td align="center">HashMap使用键（Key）计算Hashcode</td><td align="center">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td align="center">HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td><td align="center">HashSet较HashMap来说比较慢</td></tr></tbody></table><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><h2 id="什么是Hash算法"><a href="#什么是Hash算法" class="headerlink" title="什么是Hash算法"></a>什么是Hash算法</h2><p>哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值</p><h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><ul><li>链表是可以将物理地址上不连续的数据连接起来，通过指针来对物理地址进行操作，实现增删改查等功能</li><li>链表大致分为单链表和双向链表<ul><li>单链表：每个节点包含两部分，一部分存放数据变量data，另一部分是指向下一个节点的next指针</li><li>双向链表：除了包含单链表的部分，还增加的pre前一个节点的指针</li></ul></li><li>链表的优点：<ul><li>插入删除速度快（因为next指针指向其下一个节点，通过改变指针的指向可以方便的增加删除元素）</li><li>内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时间才创建空间）</li><li>大小没有固定，拓展很灵活</li></ul></li><li>链表的缺点<ul><li>不能随机查找，必须从第一个开始遍历，查找效率低</li></ul></li></ul><h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><ul><li>HashMap：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是他不保证该顺序恒久不变</li><li>HashMap的数据结构：在Java编程语言中，最基本的结构就是两种，一个是数组，另一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个”链表散列”的数据结构，即数组和链表的结合体</li><li>HashMap 基于 Hash 算法实现的<ul><li>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</li><li>存储时，如果出现hash值相同的key，此时有两种情况<ul><li>如果key相同，则覆盖原始值</li><li>如果key不同（出现冲突），则将当前的key-value放入链表中</li></ul></li><li>获取时，直接找到hash值对应的下标，再进一步判断key是否相同，从而找到对应值</li><li>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</li></ul></li><li>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</li></ul><h2 id="HashMap在JDK1-7和JDK1-8中有哪些不同？-HashMap的底层实现"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？-HashMap的底层实现" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？ HashMap的底层实现"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？ HashMap的底层实现</h2><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。</p><p>数组的特点：寻址容易，插入和删除困难</p><p>链表的特点：寻址困难，但插入和删除容易</p><p>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突</p><ul><li><p><strong>HashMap JDK1.8之前</strong></p><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表当中即可。</p></li><li><p><strong>HashMap JDK1.8之后</strong></p><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p></li><li><p><strong>JDK1.7 VS JDK1.8比较</strong></p><p>JDK1.8主要解决或优化了一些问题：</p><ol><li>resize扩容优化</li><li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法</li><li>解决了多线程死循环问题，但仍是非线程安全，多线程可能会造成数据丢失</li></ol></li></ul><h2 id="什么是红黑树"><a href="#什么是红黑树" class="headerlink" title="什么是红黑树"></a>什么是红黑树</h2><p>说道红黑树先讲什么是二叉树： 二叉树简单来说就是每一个节上可以关联两个子节点</p><p><strong>红黑树</strong></p><p>红黑树是一种特殊的二叉查找树。红黑树的每个节点都有存储位表示节点的颜色，可以是红或黑</p><p>红黑树的每个结点是黑色或者红色。当是不管怎么样他的根结点是黑色。每个叶子结点（叶子结点代表终结、结尾的节点）也是黑色 [注意：这里叶子结点，是指为空(NIL或NULL)的叶子结点！]</p><p>如果一个结点是红色的，则它的子结点必须是黑色的。</p><p>每个结点到叶子结点NIL所经过的黑色结点的个数一样的。[确保没有一条路径会比其他路径长出俩倍，所以红黑树是相对接近平衡的二叉树的！]</p><p>红黑树的基本操作是<strong>添加、删除</strong>。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的结点之后，红黑树的结构就发生了变化，可能不满足上面三条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转和变色，可以使这颗树重新成为红黑树。简单点说，旋转和变色的目的是让树保持红黑树的特性。</p><h2 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h2><ul><li>当我们put的时候，首先计算 <code>key</code>的<code>hash</code>值，这里调用了 <code>hash</code>方法，<code>hash</code>方法实际是让<code>key.hashCode()</code>与<code>key.hashCode()&gt;&gt;&gt;16</code>进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<code>index = (table.length - 1) &amp; hash</code>，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</li></ul><h2 id="HashMap的扩容操作是怎么实现的？"><a href="#HashMap的扩容操作是怎么实现的？" class="headerlink" title="HashMap的扩容操作是怎么实现的？"></a>HashMap的扩容操作是怎么实现的？</h2><ul><li><p>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p></li><li><p>每次扩展的时候，都是扩展2倍</p></li><li><p>扩展后Node对象的位置要么是原位置，要么移动到原偏移量两倍的位置</p></li><li><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p></li></ul><h2 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h2><ul><li>Hash，一般翻译为“散列”，也有直接音译为“哈希”的， Hash就是指使用哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。</li><li>hash冲突：当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把他叫做哈希碰撞</li></ul><p><strong>总结</strong></p><p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p><ul><li>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；</li><li>开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</li></ul><h2 id="能否使用任何类作为Map的Key"><a href="#能否使用任何类作为Map的Key" class="headerlink" title="能否使用任何类作为Map的Key"></a>能否使用任何类作为Map的Key</h2><p>可以使用任何类作为Map的Key，然而在使用之前需要考虑一下几点：</p><ul><li>如果类重写了equals()方法，也应该重写hashCode()方法</li><li>类的所有实例需要遵循与euqals()和hashCode()相关的规则</li><li>如果一个类没有使用equals，不应该在hashCode()中使用它</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><h2 id="为什么HashMap中String、Integer这样的包装类适合作为K？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为K？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为K？"></a>为什么HashMap中String、Integer这样的包装类适合作为K？</h2><ul><li>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率<ul><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li></ul></li></ul><h2 id="如果使用Object-作为HashMap的Key，应该怎么办"><a href="#如果使用Object-作为HashMap的Key，应该怎么办" class="headerlink" title="如果使用Object 作为HashMap的Key，应该怎么办"></a>如果使用Object 作为HashMap的Key，应该怎么办</h2><p>答：重写<code>hashCode()</code>和<code>equals()</code>方法</p><p><strong>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</p><p><strong>重写<code>equals()</code>方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</p><h2 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h2><ul><li>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</li><li><strong>那怎么解决呢？</strong><ol><li>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li><li>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li></ol></li></ul><h2 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h2><ul><li>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</li><li><strong>这个算法应该如何设计呢？</strong><ul><li>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</li></ul></li><li><strong>那为什么是两次扰动呢？</strong><ul><li>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</li></ul></li></ul><h2 id="HashMap-与-HashTable-有什么区别？"><a href="#HashMap-与-HashTable-有什么区别？" class="headerlink" title="HashMap 与 HashTable 有什么区别？"></a>HashMap 与 HashTable 有什么区别？</h2><ol><li><p><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</p></li><li><p><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</p></li><li><p><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</p></li><li><p>初始容量大小和每次扩充容量大小的不同</p><p> ：</p><ol><li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</li><li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li></ol></li><li><p><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p></li><li><p>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p></li></ol><h2 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h2><ol><li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li><li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li></ol><h2 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h2><ul><li>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。<ul><li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li>实现线程安全的方式</li><li><strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li><li>② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul></li></ul><h2 id="ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h2><p><strong>JDK1.7</strong></p><ul><li><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p></li><li><p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p></li><li><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735524c5089b8~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li><li><p>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</p><p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</p></li></ul><p><strong>JDK1.8</strong></p><ul><li>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</li></ul><h1 id="辅助工具类"><a href="#辅助工具类" class="headerlink" title="辅助工具类"></a>辅助工具类</h1><h2 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h2><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><h2 id="如何实现-Array-和-List-之间的转换？"><a href="#如何实现-Array-和-List-之间的转换？" class="headerlink" title="如何实现 Array 和 List 之间的转换？"></a>如何实现 Array 和 List 之间的转换？</h2><ul><li>Array 转 List： Arrays. asList(array) ；</li><li>List 转 Array：List 的 toArray() 方法。</li></ul><h2 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h2><ul><li><p>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</p></li><li><p>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</p></li><li><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p></li></ul><h2 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h2><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h2 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h2><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li><li>Collections 工具类的 sort 方法有两种重载的形式，</li><li>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li></ul><p>？</p><ul><li><p>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</p></li><li><p>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</p></li><li><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p></li></ul><h2 id="Collection-和-Collections-有什么区别？-1"><a href="#Collection-和-Collections-有什么区别？-1" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h2><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h2 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？-1"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？-1" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h2><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li><li>Collections 工具类的 sort 方法有两种重载的形式，</li><li>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li><li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;集合容器概述&quot;&gt;&lt;a href=&quot;#集合容器概述&quot; class=&quot;headerlink&quot; title=&quot;集合容器概述&quot;&gt;&lt;/a&gt;集合容器概述&lt;/h1&gt;&lt;h2 id=&quot;什么是集合&quot;&gt;&lt;a href=&quot;#什么是集合&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Collection" scheme="https://leslieaibin.github.io/categories/Collection/"/>
    
    
    <category term="Collection" scheme="https://leslieaibin.github.io/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>3.计算机网络 —— 传输层</title>
    <link href="https://leslieaibin.github.io/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://leslieaibin.github.io/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2021-07-04T01:15:42.000Z</published>
    <updated>2021-07-04T11:58:43.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1614160878-FiFlkq-image.png" alt="image.png"></p><p>三次握手是TCP连接的建立过程。在握手之前，主动打开连接的客户端结束CLOSE阶段，被动打开的服务器也结束CLOSE阶段，并进入LISTEN阶段。随后进入三次握手阶段：</p><ol><li>首先客户端向服务器发送一个SYN包，并等待服务器确认，其中：<ul><li>标志位为SYN，表示请求建立连接。</li><li>序号为Seq = x (x 一般为1)</li><li>随后客户端进入SYN-SENT阶段</li></ul></li><li>服务器接收到客户端发来的SYN包后，对该包进行确认后结束LISTEN阶段，并返回一段TCP报文，其中：<ul><li>标志位为SYN和ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接。</li><li>序号为Seq = y</li><li>确认号为ACK = x + 1, 表示收到客户端的序号Seq并将其值加1 作为自己确认号Ack的值，随后服务器端进入SYN-RECV阶段。</li></ul></li><li>客户端接收到发送的SYN+ACK包后，明确了从客户端到服务器的数据传输是正常的，从而结束SYN-SENT阶段。并返回最后一段报文。其中：<ul><li>标志位为ACK，表示确认收到服务器端同意连接的信号</li><li>序号为Seq = x + 1，表示收到服务器端的确认号ACK，并将其作为自己的序号值</li><li>确认号为ACK = y + 1，表示收到服务器端序号Seq， 并将其值加1作为自己的确认号ACK的值</li><li>随后客户端进入到ESTABLISHED</li></ul></li></ol><p>当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束SYN-RECV阶段，进入ESTABLISHED阶段，从而完成三次握手。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210704172933433.png" alt="image-20210704172933433"></p><p>四次挥手即TCP连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束ESTABLISHED阶段，随后开始四次挥手：</p><ol><li>首先客户端向服务器发送一段TCP报文表明其想要释放TCP连接，其中：<ul><li>标记位为FIN，表示请求释放连接；</li><li>序号为Seq = u;</li><li>随后客户端进入FIN-WAIT-1阶段，即半关闭阶段，并且停止向服务器端发送通信数据。</li></ul></li><li>服务器接收到客户端请求断开连接的FIN报文后，结束ESTABLISHED阶段，进入CLOSE-WAIT阶段并返回一段TCP报文，其中：<ul><li>标记位为ACK，表示接收到客户端释放连接的请求；</li><li>序号为Seq = v;</li><li>确认号为ACK = u + 1，表示是收到客户端报文的基础上，将其序号值加1作为本段报文确认号ACK的值</li><li>随后服务器开始准备释放服务器端到客户端方向上的连接</li></ul></li></ol><p>客户端收到服务器发送过来的TCP报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段</p><ol start="3"><li><p>服务器端在发送ACK确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后经过CLOSE-WAIT阶段，便做好了释放服务器端到客户端的连接准备，再向客户端发出一段TCP报文，其中：</p><ul><li>标记位为FIN和ACK，表示已经准备好释放连接了。</li><li>序号为Seq = w；</li><li>确认号ACK = u + 1，表示是在收到客户端报文的基础上，将其序号 Seq 的值加 1 作为本段报文确认号 Ack 的值。</li></ul><p>随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止向客户端发送数据。</p></li><li><p>客户端收到从服务器发来的 TCP 报文，确认了服务器已经做好释放连接的准备，于是结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器发送一段报文，其中：</p><ul><li>标记位为ACK，表示接收到服务器准备好释放连接的信号</li><li>序号为Seq = u + 1,表示是在收到服务器报文的基础上，将其确认号ACK值作为本段序号的值</li><li>确认号为ACK = w + 1，表示已经收到服务器报文的基础上，将其序号Seq的值作为本段报文确认号的值。</li></ul><p>随后客户端开始在TIME-WAIT阶段等待2MSL。服务器端收到从客户端发出的TCP报文之后结束LAST-ACK阶段，进入CLOSED阶段。由此正式确认关闭服务器到客户端方向上的连接。客户端等待完 2 MSL 之后，结束 TIME-WAIT 阶段，进入 CLOSED 阶段，由此完成「四次挥手」。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h1&gt;&lt;h2 id=&quot;三次握手&quot;&gt;&lt;a href=&quot;#三次握手&quot; class=&quot;headerlink&quot; title=&quot;三次握手&quot;&gt;&lt;/a&gt;三次握</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>2.计算机网络 —— 应用层</title>
    <link href="https://leslieaibin.github.io/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>https://leslieaibin.github.io/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-07-04T01:15:42.000Z</published>
    <updated>2021-07-04T11:58:40.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP头部包含那些信息"><a href="#HTTP头部包含那些信息" class="headerlink" title="HTTP头部包含那些信息"></a>HTTP头部包含那些信息</h2><p>HTTP头部本质上是一个传递额外重要信息的键值对。主要分为：<strong>通用头部、请求头部、响应头部、实体头部</strong></p><h3 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h3><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Cache-Control</td><td>用来指定当前的请求/回复中是否使用缓存机制</td><td>Cache-Control:no-store</td></tr><tr><td>Connection</td><td>客户端（浏览器）想要优先使用的连接类型</td><td>Connetion: keep-alive(Upgrade)</td></tr><tr><td>Date</td><td>报文创建时间</td><td>Date：Dec,26 2015 17:30:00 GMT</td></tr><tr><td>Trailer</td><td>会实现说明在报文主体后记录那些首部字段，该首部字段可以使用在HTTP/1.1版本分块传输编码时</td><td>Trailer:Expiress</td></tr><tr><td>Transfer-Encoding</td><td>用来改变报文格式</td><td>Transfer-Encoding: chunked</td></tr><tr><td>Upgrade</td><td>要求服务器升级到一个高版本协议</td><td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td>Via</td><td>告诉服务器，这个请求是由哪些代理发出的</td><td>Via: 1.0 fred, 1.1 <a href="http://itbilu.com.com/">itbilu.com.com</a> (Apache/1.1)</td></tr><tr><td>Warning</td><td>一个一般性的警告，表示在实体内容中可能存在错误</td><td>Warning: 199 Miscellaneous warning</td></tr></tbody></table><h3 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h3><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Accept</td><td>告诉服务器自己允许哪些媒体类型</td><td>Accept: text/plain</td></tr><tr><td>Accept-Charset</td><td>浏览器申明可接受的字符集</td><td>Accept-Charset: utf-8</td></tr><tr><td>Accept-Encoding</td><td>浏览器申明自己接收的编码方法</td><td>Accept-Encoding: gzip, deflate</td></tr><tr><td>Accept-Language</td><td>浏览器可接受的响应内容语言列表</td><td>Accept-Language: en-US</td></tr><tr><td>Authorization</td><td>用于表示 HTTP 协议中需要认证资源的认证信息</td><td></td></tr><tr><td>Expect</td><td>表示客户端要求服务器做出特定的行为</td><td>Expect: 100-continue</td></tr><tr><td>From</td><td>发起此请求的用户的邮件地址</td><td>From: <a href="mailto:&#117;&#115;&#101;&#114;&#64;&#x69;&#116;&#98;&#105;&#108;&#x75;&#46;&#x63;&#x6f;&#109;">&#117;&#115;&#101;&#114;&#64;&#x69;&#116;&#98;&#105;&#108;&#x75;&#46;&#x63;&#x6f;&#109;</a></td></tr><tr><td>Host</td><td>表示服务器的域名以及服务器所监听的端口号</td><td>Host: <a href="http://www.itbilu.com/">www.itbilu.com:80</a></td></tr><tr><td>If-XXX</td><td>条件请求</td><td>If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td></tr><tr><td>Max-Forwards</td><td>限制该消息可被代理及网关转发的次数</td><td>Max-Forwards: 10</td></tr><tr><td>Range</td><td>表示请求某个实体的一部分，字节偏移以 0 开始</td><td>Range: bytes=500-999</td></tr><tr><td>Referer</td><td>表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面</td><td>Referer: <a href="http://itbilu.com/nodejs">http://itbilu.com/nodejs</a></td></tr><tr><td>User-Agent</td><td>浏览器的身份标识字符串</td><td>User-Agent: Mozilla/……</td></tr></tbody></table><h3 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h3><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>字段的值表示可用于定义范围的单位</td><td>Accept-Ranges: bytes</td></tr><tr><td>Age</td><td>创建响应的时间</td><td>Age：5744337</td></tr><tr><td>ETag</td><td>唯一标识分配的资源</td><td>Etag：W/“585cd998-7c0f”</td></tr><tr><td>Location</td><td>表示重定向后的 URL</td><td>Location: <a href="http://www.zcmhi.com/archives/94.html">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td>Retry-After</td><td>告知客户端多久后再发送请求</td><td>Retry-After: 120</td></tr><tr><td>Server</td><td>告知客户端服务器信息</td><td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td></tr><tr><td>Vary</td><td>缓存控制</td><td>Vary: Origin</td></tr></tbody></table><h3 id="实体头部"><a href="#实体头部" class="headerlink" title="实体头部"></a>实体头部</h3><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Allow</td><td>对某网络资源的有效的请求行为，不允许则返回405</td><td>Allow: GET, HEAD</td></tr><tr><td>Content-encoding</td><td>返回内容的编码方式</td><td>Content-Encoding: gzip</td></tr><tr><td>Content-Length</td><td>返回内容的字节长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Language</td><td>响应体的语言</td><td>Content-Language: en,zh</td></tr><tr><td>Content-Location</td><td>请求资源可替代的备用的另一地址</td><td>Content-Location: /index.htm</td></tr><tr><td>Content-MD5</td><td>返回资源的MD5校验值</td><td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td>Content-Range</td><td>在整个返回体中本部分的字节位置</td><td>Content-Range: bytes 21010-47021/47022</td></tr><tr><td>Content-Type</td><td>返回内容的MIME类型</td><td>Content-Type: text/html; charset=utf-8</td></tr><tr><td>Expires</td><td>Expires</td><td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td>Last-Modified</td><td>请求资源的最后修改时间</td><td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr></tbody></table><h2 id="Keep-Alive-和非-Keep-Alive区别，对服务性能有影响么"><a href="#Keep-Alive-和非-Keep-Alive区别，对服务性能有影响么" class="headerlink" title="Keep-Alive 和非 Keep-Alive区别，对服务性能有影响么"></a>Keep-Alive 和非 Keep-Alive区别，对服务性能有影响么</h2><p>在早期的<strong>HTTP/1.0</strong>中，浏览器每次发起请求都要与服务器创建一个新的TCP连接，服务器完成请求立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。然而创建和关闭连接的过程需要<strong>消耗资源和时间</strong>，为了减少资源消耗，缩短响应时间，就需要重用连接。在HTTP/1.1版本中默认使用持久连接，在此之前的HTTP版本的默认连接都是使用非持久连接，如果想要在旧版本的HTTP协议上维持持久连接，则需要指定<code>connection</code>的首部字段的值为Keep-Alive来告诉对方这个请求响应完成后不要关闭，下次咱们还用这几个请求继续交流：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210610235948369.png" alt="image-20210610235948369"></p><p>对于非 Keep=Alive 来说，必须为每一个请求的对象建立和维护一个全新的连接。对于每一个这样的连接，客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担，因为一台 Web 服务器可能同时服务于数以百计的客户机请求。在 Keep-Alive 方式下，服务器在响应后保持该 TCP 连接打开，在同一个客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。甚至位于同一台服务器的多个 Web 页面在从该服务器发送给同一个客户机时，可以在单个持久 TCP 连接上进行。</p><p>然而，Keep-Alive 并不是没有缺点的，当长时间的保持 TCP 连接时容易<strong>导致系统资源被无效占用</strong>，若对 Keep-Alive 模式配置不当，将有可能比非 Keep-Alive 模式带来的损失更大。因此，我们需要正确地设置 keep-alive timeout 参数，当 TCP 连接在传送完最后一个 HTTP 响应，该连接会保持 keepalive_timeout 秒，之后就开始关闭这个链接。</p><h2 id="HTTP-长连接短连接使用场景是什么"><a href="#HTTP-长连接短连接使用场景是什么" class="headerlink" title="HTTP 长连接短连接使用场景是什么"></a>HTTP 长连接短连接使用场景是什么</h2><p><strong>长连接：</strong>多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</p><p><strong>短连接：</strong>用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</p><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>http/1.0定义了三种请求方法： <strong>GET、POST和HEAD方法</strong></p><p>http/1.1增加了六种请求方法：<strong>OPTIONS、PUT、PATCH、DELETE、TRACE和CONNECT方法</strong></p><ul><li><p><strong>GET</strong></p><p>请求指定的页面信息，并返回具体内容，通常只用于读取数据</p></li><li><p><strong>HEAD</strong></p><p>类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</p></li><li><p><strong>POST</strong></p><p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的更改。</p></li><li><p><strong>PUT</strong></p><p>替换指定的资源，没有的话就新增</p></li><li><p><strong>DELETE</strong></p><p>请求服务器删除URL标识的资源数据</p></li><li><p><strong>CONNECT</strong></p><p>将服务器作为代理，让服务器代替用户进行访问</p></li><li><p><strong>OPTIONS</strong></p><p>向服务发送该方法，会返回对指定资源所支持的HTTP请求方法</p></li><li><p><strong>TRACE</strong></p><p>回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断</p></li><li><p><strong>PATCH</strong></p><p>是对PUT方法的补充，用来对已知资源进行局部更新。</p></li></ul><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><ul><li>get提交的数据会放在URL之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在URL中，可能会存在安全问题，因此往往用于获取资源信息。而PSOT参数放在请求主体中，并且参数不会被保留，相较于get方法，post方法更安全，主要用于修改服务器上的资源。</li><li>get请求只支持URL编码，post请求支持多种编码格式</li><li>get只支持ASCII字符格式的参数，而post方法没有限制</li><li>get提交的数据大小有限制（这里所说的限制是针对浏览器而言），而POST方法的数据没限制</li><li>get方法需要使用Request.QueryString 来去的变量的值，而post方式通过Request.From来获取。</li><li>get方法产生一个TCP数据包，post方法产生两个（并不是所有的浏览器都产生两个）</li></ul><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。</p><p>对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。</p><h2 id="GET的长度限制是多少？"><a href="#GET的长度限制是多少？" class="headerlink" title="GET的长度限制是多少？"></a>GET的长度限制是多少？</h2><p>URL构成：协议 + :// + 认证信息 + @ + 域名 or IP地址 + 端口号 + 资源路径 + ? + 查询字符串 + # + 片段标识符;</p><p>所以这里说整个URL 的长度，就是指包含上述所有组成部分在内的总长度，数据部分就是指查询字符串。</p><p>HTTP中的GET方法是通过URL传递数据的，而URL本身并没有对数据的长度进行限制，<strong>真正限制GET长度的是浏览器</strong>，例如IE浏览器对URL的最大限制为2000多字符，大概2KB左右。像 Chrome, FireFox 等浏览器能支持的 URL 字符数更多，其中 FireFox 中 URL 最大长度限制为 65536 个字符，Chrome 浏览器中 URL 最大长度限制为 8182 个字符。并且这个长度不是只针对数据部分，而是针对整个 URL 而言，在这之中，不同的服务器同样影响 URL 的最大长度限制。因此对于特定的浏览器，GET的长度限制不同。</p><p>由于 POST 方法请求参数在请求主体中，理论上讲<strong>，post 方法是没有大小限制的，而真正起限制</strong></p><h2 id="HTTP-与-HTTPs-的工作方式【建立连接的过程】"><a href="#HTTP-与-HTTPs-的工作方式【建立连接的过程】" class="headerlink" title="HTTP 与 HTTPs 的工作方式【建立连接的过程】"></a>HTTP 与 HTTPs 的工作方式【建立连接的过程】</h2><ul><li>HTTP</li></ul><p><strong>HTTP（Hyper Text Transfer Protocol: 超文本传输协议）</strong>是一种简单的请求—响应协议， 被用于在Web浏览器和网站服务之间传递消息。HTTP使用Tcp(而不是UDP)作为它的支撑运输层协议。其默认工作在TCP协议80端口，HTTP客户端发起一个与服务器的TCP连接，一旦连接建立。客户机从套接字接口发送HTTP请求报文和接收HTTP响应报文。类似的，服务器也是从套接字接口接收HTTP请求报文和发送HTTP响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务端关闭连接。</p><ul><li>HTTPS</li></ul><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：</p><p>① 客户端发起一个 HTTPS 请求，并连接到服务器的 443 端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；</p><p>② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。</p><p>③ 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。</p><p>④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。</p><p>⑤ SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secre，并且该报文是经过证书中的公钥加密过的。</p><p>⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre 加密的。</p><p>⑦ 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。</p><p>⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。</p><p>当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。</p><p>HTTP:默认用TCP协议的80端口（可以改），通信内容明文传输，不处理<br>HTTPS:</p><p>请求：443端口，支持算法，密钥长度<br>理解：两网友约定明天出去玩，玩什么呢？爬山，游泳，游乐园选一个吧<br>响应：选择一种，将其密钥组件一起发给客户端<br>理解：我们去游乐园吧<br>响应：数字证书<br>理解：为了证明我是个合法公民。给你看看我的身份证，身份证是XX公安局发的，身份证号是XX,10年后过期<br>响应：协商完成<br>理解：OK，我同意去游乐园<br>生成随机密码串，并使用证书公钥加密<br>理解：为了互相证明我们是协商的网友，每个句尾加个“喵”<br>请求：尝试使用加密串加密<br>理解：我们试试，我是客户端喵<br>响应：发送finish结束<br>理解：我说完了你试试<br>响应：和客户端相同进行加密发送<br>理解：服务端喵</p><h2 id="HTTPS-和-HTTP-的区别"><a href="#HTTPS-和-HTTP-的区别" class="headerlink" title="HTTPS 和 HTTP 的区别"></a>HTTPS 和 HTTP 的区别</h2><ul><li>http协议以明文方式发送内容，数据都是未加密的，安全性较差。https数据传输过程是加密的，安全性较好。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80端口，后者是443端口</li><li>https协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。</li><li>http页面响应比https快，主要因为HTTP使用三次握手建立连接，客户端和服务器需要握手三次，而HTTPS除了TCP的3次握手，还需要经历一个SSL协商过程。</li></ul><p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全(Transport Layer Security，TLS)是为网络通信提供安全及数据完整性的一种安全协议。如今被广泛使用，如网页，电子邮件，互联网传真，即时消息和语音在IP电话（VoIP）。其中网站是通过使用TLS来保护WEB浏览器与服务器之间的通信安全。</p><h2 id="HTTPS的加密方式"><a href="#HTTPS的加密方式" class="headerlink" title="HTTPS的加密方式"></a>HTTPS的加密方式</h2><p>https采用对称加密和非对称假期相结合的方式，首先使用SSL/TLS协议进行加密传输，为了弥补非对称加密的缺点，https采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称秘钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个https的流程。</p><h2 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议,如何保存用户状态"></a>HTTP 是不保存状态的协议,如何保存用户状态</h2><p>假定某个特定的客户机在短时间内两次请求同一个对象，服务器并不会因为刚刚为该用户提供了该对象不再做出反应，而是重新发送该对象，就像该服务器已经完全忘记不就之前所做过的是一样。因为一个HTTP服务器并不保存关于客户机的任何信息，所以我们说http是一个无状态协议。</p><ul><li><p>基于Session实现的会话保持</p><p>在客户端第一次向服务器发送HTTP请求后，服务器会创建一个Session对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（Sessionld）客户端，这个会话标识一般保存在客户端Cookie中，之后每次该浏览器发送http请求都会带上Cookie中的Sessionld到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。</p><p>优点：安全性高，因为状态信息保存在服务端</p><p>缺点：由于大型网站往往采用分布式服务器，浏览器发送的http请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。</p><p><strong>【解决方法：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息】</strong></p></li><li><p>基于Cookie实现的会话保持</p><p>当服务器发送响应消息时，在http响应头中设置Set-Cookie字段，用来存储客户端的状态信息。客户端解析出http响应头中的字段信息，并根据其生命周期创建不同的Cookie，这样一来每次浏览器发送http请求的时候都会带上Cookie字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。</p><p>优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。</p><p>缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。</p></li></ul><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>HTTP状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类作用。HTTP状态码共有5中类型。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>1xx:</p><p>指示信息–表示请求正在处理</p></li><li><p>2xx:</p><p>成功–表示请求已被成功处理完毕</p></li><li><p>3xx:</p><p>重定向–要完成的请求需要进行附加操作</p></li><li><p>4xx:</p><p>客户端错误–请求有语法错误或者请求无法实现，服务器无法处理请求</p></li><li><p>5xx：</p><p>服务器端错误–服务器处理请求出现错误</p></li></ul><h3 id="相应的HTTP状态码列表"><a href="#相应的HTTP状态码列表" class="headerlink" title="相应的HTTP状态码列表"></a>相应的HTTP状态码列表</h3><ul><li><p>100： Continue</p><p>继续，客户端继续处理请求。</p></li><li><p>101：Switching Protocol</p><p>切换协议，服务器根据客户端的请求切换到更高的协议</p></li><li><p>200：OK</p><p>请求成功。请求所希望的响应头或数据体将随此响应返回</p></li><li><p>201：Created</p><p>请求以实现，并且有一个新的资源已经依据需求而建立</p></li><li><p>202： Accepted</p><p>请求已接受，已经接受请求但还未处理完成</p></li><li><p>203：Non-Authoritative Information</p><p>非授权信息，请求成功。但返回的meta信息不再原始的服务器中，而是一个副本。</p></li><li><p>204： No Content</p><p>无内容，服务器成功处理了请求，但不需要返回任何实体内容</p></li><li><p>205：Reset Content </p><p>重置内容，与204类似，不同点是返回此状态码的响应要求请求者重置文档视图</p></li><li><p>206：Partial Content</p><p>部分内容。服务器成功处理了部分Get请求。</p></li><li><p>300：Multiple Choices</p><p> 多种选择。被请求的资源有一系列可供选择的回馈信息，用户或浏览器能够自行选择一个首选地址进行重定向</p></li><li><p>301：Moved Permanently</p><p>永久移动。请求的资源已被永久地移动到新 URI，返回信息会包含新的 URI，浏览器会自动定向到新 URI</p></li><li><p>302：Found</p><p> 临时移动。与 301 类似。但资源只是临时被移动，客户端应继续使用原有URI</p></li><li><p>303： See Other</p><p>查看其它地址。与301类似。使用GET和POST请求查看</p></li><li><p>304： Not Modified</p><p>未修改。如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码</p></li><li><p>305：Use Proxy</p><p>使用代理。被请求的资源必须通过指定的代理才能被访问</p></li><li><p>306： Unused</p><p> 在最新版的规范中，306状态码已经不再被使用</p></li><li><p>307： Temporary Redirect</p><p>临时重定向。请求的资源现在临时从不同的URI 响应请求，与302类似</p></li><li><p>400：Bad Request</p><p>客户端请求的语法错误，服务器无法理解；请求的参数有误</p></li><li><p>401：Unauthorized</p><p>当前请求需要用户验证</p></li><li><p>402： Payment Required</p><p>该状态码是为了将来可能的需求而预留的</p></li><li><p>403： Forbidden</p><p> 服务器已经理解请求，但是拒绝执行它</p></li><li><p>404：Not Found</p><p>请求失败，请求所希望得到的资源未被在服务器上发现</p></li><li><p>405： Method Not Allowed</p><p>客户端请求中的方法被禁止</p></li><li><p>406：Not Acceptable</p><p>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体</p></li><li><p>407：Proxy Authentication Required</p><p>与401响应类似，只不过客户端必须在代理服务器上进行身份验证</p></li><li><p>408： Request Time-out</p><p>请求超时。服务器等待客户端发送的请求时间过长，超时</p></li><li><p>409：Conflict</p><p>由于和被请求的资源的当前状态之间存在冲突，请求无法完成</p></li><li><p>410： Gone</p><p>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址</p></li><li><p>411： Length Required</p><p>服务器拒绝在没有定义 Content-Length 头的情况下接受请求</p></li><li><p>412： Precondition Failed</p><p>客户端请求信息的先决条件错误</p></li><li><p>413：Request Entity Too Large</p><p>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围</p></li><li><p>414：Request-URI Too Large</p><p>请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务</p></li><li><p>415：Unsupported Media Type</p><p> 服务器无法处理请求附带的媒体格式</p></li><li><p>416：Requested range not satisfiable</p><p>客户端请求的范围无效</p></li><li><p>417：Expectation Failed</p><p>服务器无法满足Expect的请求头信息</p></li><li><p>500：Internal Server</p><p> 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理</p></li><li><p>501：Not Implemented</p><p>服务器不支持当前请求所需要的某个功能</p></li><li><p>502：Bad Gateway</p><p>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到无效的响应</p></li><li><p>503：Service Unavailable</p><p>由于临时的服务器维护或者过载，服务器当前无法处理请求，一段时间后可能恢复正常</p></li><li><p>504： Gateway Time-out</p><p>充当网关或代理的服务器，未及时从远端服务器获取请求</p></li><li><p>505：HTTP Version not supported</p><p>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本</p></li></ul><p>200 请求成功</p><p>204 请求成功但无内容返回</p><p>206 范围请求成功</p><p>301 永久重定向； 30(2|3|7)临时重定向，语义和实现有略微区别；</p><p>304 带if-modified-since 请求首部的条件请求，条件没有满足</p><p>400 语法错误（前端挨打）</p><p>401 需要认证信息</p><p>403 拒绝访问</p><p>404 找不到资源</p><p>412 除if-modified-since 以外的条件请求，条件未满足</p><p>500 服务器错误（后端挨打）</p><p>503 服务器宕机了（DevOps or IT 挨打）</p><h2 id="HTTP-1-1-和-HTTP-1-0-的区别"><a href="#HTTP-1-1-和-HTTP-1-0-的区别" class="headerlink" title="HTTP/1.1 和 HTTP/1.0 的区别"></a>HTTP/1.1 和 HTTP/1.0 的区别</h2><ul><li><p><strong>长链接</strong></p><p>HTTP/1.0默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成后立即断开TCP连接。HTTP/1.1版本的默认使用的是持久连接，其支持在同一个TCP请求中传送多个HTTP请求和响应。此之前的HTTP版本的默认连接都是使用非持久连接，如果想要在旧版的HTTP协议维持持久连接，则需要指定Connection的首部字段的值为Keep-alive.</p></li><li><p><strong>缓存处理</strong></p><p>1.1请求头中增加了一些和缓存的相关的字段，比如IF-MATCH，可以更加灵活的控制缓存策略。</p><p>HTTP缓存</p><p>访问一个网站的时候，浏览器会向服务器请求很多资源，比如css、js这些静态文件，如果每次请求都要让服务器发送所有资源，请求多了会对服务器造成很大的压力</p><p>HTTP为了解决这个问题，就引入了缓存，缓存有两种策略：</p><p>1、强缓存：每次请求资源的时候会先去缓存里找，如果有就直接用，没有才去向服务器请求资源</p><p>2、对比缓存：每次请求资源的时候先发个消息和服务器确认一下，如果服务器返回304，说明缓存可以用，浏览器就会去缓存里寻找资源</p></li><li><p><strong>节约带宽</strong></p><p>1.0默认把资源相关的整个对象都发给客户端，但是可能客户端不需要所有的信息，这就浪费了带宽资源，1.1的请求头引入了Range头域，可以只请求部分资源，比如断点下载的时候可以用Range</p></li><li><p><strong>错误通知的管理</strong></p><p>1.1增加了一些错误的状态响应码（24个），比如410表示请求的资源已经被永远删除</p></li><li><p>Host<strong>请求头</strong></p><p>1.0的时候每台服务器都绑定唯一的IP地址，后面出现了虚拟主机，一个服务器可以有多个虚拟主机，一起共享同一个IP地址，所以为了区分不同虚拟主机，1.1添加了host请求头部</p></li></ul><h2 id="HTTP-1-X-和-HTTP-2-0-的区别"><a href="#HTTP-1-X-和-HTTP-2-0-的区别" class="headerlink" title="HTTP/1.X 和 HTTP/2.0 的区别"></a>HTTP/1.X 和 HTTP/2.0 的区别</h2><ul><li><p><strong>二进制传送</strong></p><p>之前的版本数据都是用文本传输，因为文本有多种格式，所以不能很好地适应所有的场景，2.0传送的是二进制，相当于统一了格式</p></li><li><p><strong>多路复用</strong></p><p>1.1虽然默认复用TCP连接，但是每个请求时串行执行的，如果前面的请求超时，后面的请求智能等待（也就是线头阻塞）2.0的时候每个请求有自己的ID，多个请求可以在同一TCP连接上并行执行，不会相互影响。</p></li><li><p><strong>header压缩</strong></p><p>每次进行HTTP请求响应的时候，头部里很多的字段都是重复的，在2.0中，将字段记录到一张表中，头部只需要存放字段对应的编码就行，用的时候只需要拿着编号去表里查找就行，减少传输的数据量。</p></li><li><p><strong>服务器推送</strong></p><p>服务器会在客户端没发起请求的时候会主动推送一些需要的资源，比如客户端请求一个html文件，服务器发送完之后会把和这个html相关的静态文件也发送给客户端，当客户端准备向服务器请求静态文件的时候，就可以直接缓存中获取，就不需要在发起请求了。</p></li></ul><h2 id="HTTP-3-了解吗"><a href="#HTTP-3-了解吗" class="headerlink" title="HTTP/3 了解吗"></a>HTTP/3 了解吗</h2><p><strong>HTTP2.0存在的问题</strong></p><p>我们知道，传统Web平台的数据传输都基于TCP协议，而TCP协议在创建之前不可以避免的需要三次握手，如果需要提高数据交互的安全性，即增加传输层安全协议（TLS），还会增加更多的握手次数。HTTP从1.0到2.0，其传输层都基于TCP协议的。即使是带来了巨大性能提升的HTTP2，也无法完全解决TCP协议存在的固有问题。此外，HTTP/2 多路复用只是减少了连接数，其队头的拥塞问题并没有完全解决，倘若 TCP 丢包率过大，则 HTTP/2 的表现将不如 HTTP/1.1。</p><p><strong>QUIC协议</strong></p><p>QUIC（Quick UDP Internet COnnections)，直译为快速UDP网络连接，是谷歌制定的一种基于UDP的低延迟传输协议。其主要目的是解决采用传输层TCP协议存在的问题，同时满足传输层和应用层对多连接，低延迟等的需求。该协议融合了TCP，TLS，HTTP2等协议的特性，并基于 UDP传输。该协议带来的主要提升有：</p><p>低延迟连接。当客户端第一次连接服务器时，QUIC 只需要 1 RTT（Round-Trid Time）延迟就可以建立安全可靠的连接（采用 TLS 1.3 版本），相比于 TCP + TLS 的 3 次 RTT 要更加快捷。之后，客户端可以在本地缓存加密的认证信息，当再次与服务器建立连接时可以实现 0 RTT 的连接建立延迟。</p><p>QUIC 复用了 HTTP/2 协议的多路复用功能，由于 QUIC 基于 UDP，所以也避免了 HTTP/2存在的队头阻塞问题。</p><p>基于 UDP 协议的 QUIC 运行在用户域而不是系统内核，这使得 QUIC 协议可以快速的更新和部署，从而很好地解决了 TPC 协议部署及更新的困难。</p><p>QUIC 的报文是经过加密和认证的，除了少量的报文，其它所有的 QUIC 报文头部都经过了认证，报文主体经过了加密。只要有攻击者篡改 QUIC 报文，接收端都能及时发现。</p><p>具有向前纠错机制，每个数据包携带了除了本身内容外的部分其他数据包的内容，使得在出现少量丢包的情况下，尽量地减少其它包的重传次数，其通过牺牲单个包所携带的有效数据大小换来更少的重传次数，这在丢包数量较小的场景下能够带来一定程度的性能提升。</p><p><strong>HTTP3</strong></p><p>HTTP3是在QUIC基础上发展起来的，其底层使用UDP进行数据传输，上层仍然使用HTTP2，在UDP与HTTP2之间存在一个QUIC层，其中TLS加密过程在该层进行处理。HTTP3主要有以下几个特点：</p><p>① 使用 UDP 作为传输层进行通信；</p><p>② 在 UDP 之上的 QUIC 协议保证了 HTTP/3 的安全性。QUIC 在建立连接的过程中就完成了 TLS 加密握手；</p><p>③ 建立连接快，正常只需要 1 RTT 即可建立连接。如果有缓存之前的会话信息，则直接验证和建立连接，此过程 0 RTT。建立连接时，也可以带有少量业务数据；</p><p>④ 不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立；</p><p>⑤ 使用 QPACK 进行头部压缩，因为 在 HTTP/2 中的 HPACK 要求传输过程有序，这会导致队头阻塞，而 QPACK 不存在这个问题。</p><p>最后我们使用一张图来清晰的表示出 HTTP 协议的发展变化：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210703151748265.png" alt="image-20210703151748265"></p><h2 id="DNS-的作用和原理"><a href="#DNS-的作用和原理" class="headerlink" title="DNS 的作用和原理"></a>DNS 的作用和原理</h2><p><code>DNS（Domain Name System)</code>是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于TCP/IP网络。</p><p><strong>DNS的作用</strong></p><p>通常我们有两种方式识别主机：通过主机名或者IP地址。人们喜欢便于记忆的主机名表示，而路由器则喜欢定长的、有层次结构的IP地址。为了满足这些不同的偏好，我们需要一种能够进行主机名到IP地址转换的目录服务，域名系统作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。</p><p><strong>DNS域名解析原理</strong></p><p>DNS采用了分布式的设计方案，其域名空间采用一种树形的层次结构：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210703153043428.png" alt="image-20210703153043428"></p><p>上图展示了 DNS 服务器的部分层次结构，从上到下依次为根域名服务器、顶级域名服务器和权威域名服务器。其实根域名服务器在因特网上有13个，大部分位于北美洲。第二层为顶级域服务器，这些服务器负责顶级域名（如 com、org、net、edu）和所有国家的顶级域名（如uk、fr、ca 和 jp）。在第三层为权威 DNS 服务器，因特网上具有公共可访问主机（例如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录由组织机构的权威 DNS 服务器负责保存，这些记录将这些主机的名称映射为 IP 地址。</p><p>除此之外，还有一类重要的 DNS 服务器，叫做本地 DNS 服务器。本地 DNS 服务器严格来说不在 DNS 服务器的层次结构中，但它对 DNS 层次结构是很重要的。一般来说，每个网络服务提供商（ISP） 都有一台本地 DNS 服务器。当主机与某个 ISP 相连时，该 ISP 提供一台主机的 IP 地址，该主机具有一台或多台其本地 DNS 服务器的 IP 地址。主机的本地 DNS 服务器通常和主机距离较近，当主机发起 DNS 请求时，该请求被发送到本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次结构中。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210703154357430.png" alt="image-20210703154357430"></p><p>以一个例子了解DNS的工作原理，假设主机A（IP地址为abc.xyz.edu.)想知道主机B的IP地址（def.mn.edu）。</p><ul><li><p>主机A首先向它的本地DNS服务器发送一个DNS查询报文。该查询报文含有被转换的主机名def.mn.edu。</p></li><li><p>本地DNS服务器将该报文转发到根DNS服务器，</p></li><li><p>根DNS服务器注意到查询的ip地址前缀为edu后向本地DNS服务器返回负责edu的顶级域名服务器的IP地址列表。</p></li><li><p>该本地DNS服务器则再次向这些顶级域名服务器发送查询报文。该顶级域名服务器注意到mn.edu的前缀，并用权威域名服务器的ip地址进行相应。</p></li><li><p>通常情况下，顶级域名服务器并不总是知道每台主机的权威 DNS 服务器的 IP 地址，而只知道中间的某个服务器，该中间 DNS 服务器依次能找到用于相应主机的 IP 地址，我们假设中间经历了权威服务器 ① 和 ②，最后找到了负责 def.mn.edu 的权威 DNS 服务器 ③，之后，本地 DNS 服务器直接向该服务器发送查询报文从而获得主机 B 的IP 地址。</p></li></ul><p>IP 地址的查询其实经历了两种查询方式，分别是递归查询和迭代查询。</p><p><strong>递归查询：</strong></p><p>如果主机所询问的本地域名服务器不知道被查询域名的ip地址，那么本地域名服务器就以DNS客户端的身份，向其他域名服务器鸡血发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询。</p><p><strong>迭代查询:</strong></p><p>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询</p><h2 id="DNS为什么用UDP"><a href="#DNS为什么用UDP" class="headerlink" title="DNS为什么用UDP"></a>DNS为什么用UDP</h2><p>DNS既使用TCP又使用UDP</p><ul><li>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用TCP，因为数据同步传送数据量比一个请求和应答的数据量要多，而TCP允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的TCP。</li><li>当客户端向DNS服务器查询域名（域名解析）的时候，一般返回的内容不会超过UDP报文的最大长度，即512字节。用UDP传输时，不需要经过TCP三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</li></ul><h2 id="socket-套接字有哪些"><a href="#socket-套接字有哪些" class="headerlink" title="socket() 套接字有哪些"></a>socket() 套接字有哪些</h2><p>套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。例如 TCP 用主机的 IP 地址 + 端口号作为 TCP 连接的端点，这个端点就叫做套接字。</p><p>套接字主要有以下三种类型：</p><ul><li><p>流套接字（SOCK_STREAM）：流套接字基于 TCP 传输协议，主要用于提供面向连接、可靠的数据传输服务。由于 TCP 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。</p></li><li><p>数据报套接字（SOCK_DGRAM）：和流套接字不同，数据报套接字基于 UDP 传输协议，对应于无连接的 UDP 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 UDP 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 UDP 套接字时，丢包等问题需要在程序中进行处理。</p></li><li><p>原始套接字（SOCK_RAW）：由于流套接字和数据报套接字只能读取 TCP 和 UDP 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。</p></li></ul><h2 id="URI（统一资源标识符）和-URL（统一资源定位符）之间的区别"><a href="#URI（统一资源标识符）和-URL（统一资源定位符）之间的区别" class="headerlink" title="URI（统一资源标识符）和 URL（统一资源定位符）之间的区别"></a>URI（统一资源标识符）和 URL（统一资源定位符）之间的区别</h2><p>URL，即统一资源定位符 (Uniform Resource Locator )，URL 其实就是我们平时上网时输入的网址，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。</p><p>从定义即可看出，URL 是 URI 的一个子集，两者都定义了资源是什么，而 URL 还定义了如何能访问到该资源。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。简单地说，只要能唯一标识资源的就是 URI，在 URI 的基础上给出其资源的访问方式的就是 URL。</p><h2 id="用户输入网址到显示对应页面的全过程"><a href="#用户输入网址到显示对应页面的全过程" class="headerlink" title="用户输入网址到显示对应页面的全过程"></a>用户输入网址到显示对应页面的全过程</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210703185939090.png" alt="image-20210703185939090"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;应用层&quot;&gt;&lt;a href=&quot;#应用层&quot; class=&quot;headerlink&quot; title=&quot;应用层&quot;&gt;&lt;/a&gt;应用层&lt;/h1&gt;&lt;h2 id=&quot;HTTP头部包含那些信息&quot;&gt;&lt;a href=&quot;#HTTP头部包含那些信息&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>1.计算机网络 —— 协议层次以及服务</title>
    <link href="https://leslieaibin.github.io/2021/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B/"/>
    <id>https://leslieaibin.github.io/2021/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-06-09T01:15:42.000Z</published>
    <updated>2021-07-04T11:58:42.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1612150605-NindRH-image.png" alt="image.png"></p><p>OSI模型全称为<code>开放式通信系统互连参考模型</code>，是国际标准化（ISO）提出的一个视图使各种计算机在世界范围内互连为网络的标准框架。OSI将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高的一层。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层位于OSI参考模型的第七层，其作用是<strong>通过应用程序间的交互来完成特定的网络应用。</strong>该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统DNS，支持万维网应用的HTTP协议，电子邮件系统采用SMTP协议等。在应用层交互的数据单位我们称之为报文。</p><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>表示层的作用是使<strong>通信的应用程序能够解释交换数据的含义</strong>，其位于OSI参考模型的第六层，向上为应用层提供服务，向下接受来自会话层的服务。该层提供的服务只要包括数据压缩，数据加密以及数据描述。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。</p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>会话层就是<strong>负责建立、管理和终止表示层实体之间的通信会话。</strong>该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p><strong>传输层的主要任务是为了两台主机进程之间的通信提供服务。</strong>应用程序利用该服务传送应用层报文，该服务并不针对某一特定的应用，多种应用可以使用同一传输层服务。由于一台主机可同时运行多个线程，因此传输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面的传输层的服务，分用和复用相反，是传输层把收到的信息分别交付上面应用层中的相应进程。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。网络层的主要任务就是<strong>选择合适的网间路由和交换节点，确保数据按时成功传送。</strong>在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>作为 OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。<strong>使其上面的数据链路层不必考虑网络的具体传输介质是什么。</strong>该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。</p><h1 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h1><p>OSI七层模型在提出时的出发点是基于标准化的考虑，而没有考虑到具体的时长需求，使得该模型结构复杂，部分功能冗余，因而完全实现OSI参考模型的系统不多。而TCP/IP参考模型直接面向时长需求，实现起来比较容易，因此在一经提出便得到广泛的应用。基于TCP/IP的参考模型将协议分成四个层次，如上图所示，分别为：<code>网络互连层</code>、<code>网际互联层</code>、<code>传输层</code>、<code>应用层</code>。</p><h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><p>TCP/IP模型将OSI参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP等。</p><h2 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h2><p>该层对应于OSI参考模型的传输层，为上层实体提供源端到对端主机的通信功能。传输层定义了两个主要协议：<code>传输控制协议（TCP Transmission Control Protocol）</code> 和<code>用户数据报协议（UDP User Data Protocol）</code> 。其中面向连接的TCP协议保证的数据传输可靠性，面向无连接的UDP协议能够实现数据包简单、快速的传输。</p><h2 id="网际互联层"><a href="#网际互联层" class="headerlink" title="网际互联层"></a>网际互联层</h2><p>网际互联层对应OSI参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。在网际互联层，IP协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报头中的目的地址将数据传送到目的地址，在这个过程中IP负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是<code>互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</code></p><h2 id="网络接入层"><a href="#网络接入层" class="headerlink" title="网络接入层"></a>网络接入层</h2><p>网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p><h1 id="TCP-IP五层参考模型"><a href="#TCP-IP五层参考模型" class="headerlink" title="TCP/IP五层参考模型"></a>TCP/IP五层参考模型</h1><p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括：</p><ul><li>应用层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层。</li></ul><p>其中应用层对应 OSI 的上三层，下四层和 OSI 相同。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p><h1 id="OSI模型与TCP-IP的异同比较"><a href="#OSI模型与TCP-IP的异同比较" class="headerlink" title="OSI模型与TCP/IP的异同比较"></a>OSI模型与TCP/IP的异同比较</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul><li>OSI参考模型与TCP/IP参考模型都采用了层次结构</li><li>都能够提供面向连接和无连接两种通信服务机制</li></ul><p><strong>面向无连接：</strong></p><ul><li><strong>面向无连接</strong>是通信技术之一。是指通信双方不需要事先建立一条通信线路，而是把每个带有目的地址的包（报文分组）送到线路上，由系统自主选定路线进行传输。邮政系统是一个无连接的模式，天罗地网式的选择路线，天女散花式的传播形式；<strong>IP、UDP协议就是一种无连接协议。</strong></li></ul><p><strong>面向连接：</strong></p><ul><li>Connection－oriented 面向连接：<strong>一种网络协议,依赖发送方和接收器之间的显示通信和阻塞以管理双方的数据传输.网络系统需要在两台计算机之间发送数据之前先建立连接的一种特性。面向连接网络类似于电话系统，在开始通信前必须先进行一次呼叫和应答。</strong>TCP协议就是一种面向连接服务的协议,电话系统是一个面向连接的模式。</li></ul><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ul><li>OSI采用的七层模型；TCP/IP是四层结构</li><li>TCP/IP参考模型没有对网络接口层进行细分，只是一些概念性的描述；OSI参考模型对服务和协议做了明确的区分。</li><li>OSI先有模型，后有协议规范，适合于描述各种网络；TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络。</li><li>TCP/IP一开始就提出面向连接和无连接，而OSI一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</li><li>OSI参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP/IP参考模型虽然很多不尽人意的地方，但作为一种简化的分层结构还是比较成功的。</li></ul><h1 id="OSI和TCP-IP协议之间的对应关系"><a href="#OSI和TCP-IP协议之间的对应关系" class="headerlink" title="OSI和TCP/IP协议之间的对应关系"></a>OSI和TCP/IP协议之间的对应关系</h1><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210608153545012.png" alt="image-20210608153545012"></p><h1 id="为什么TCP-IP去除了表示层和会话层"><a href="#为什么TCP-IP去除了表示层和会话层" class="headerlink" title="为什么TCP/IP去除了表示层和会话层"></a>为什么TCP/IP去除了表示层和会话层</h1><p>OSI参考模式在提出时，他们的理想是非常好的，但实际上，由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的，例如，我们几乎不会认为数据的压缩、加密算法算是一种协议，而会话的概念则更为抽象，难以用协议来进行描述，所以在后来的 TCP/IP 协议框架的设计中，便将表示层和会话层与应用层整合在一起，让整个过程更为清晰明了。</p><h1 id="数据如何在各层之间传输——数据的封装过程"><a href="#数据如何在各层之间传输——数据的封装过程" class="headerlink" title="数据如何在各层之间传输——数据的封装过程"></a>数据如何在各层之间传输——数据的封装过程</h1><p>在发送主机端，一个应用层报文被传送到运输层。在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。该数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧，在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OSI七层模型&quot;&gt;&lt;a href=&quot;#OSI七层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI七层模型&quot;&gt;&lt;/a&gt;OSI七层模型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://test-1874253.oss-cn-beijing.aliyu</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>16.JVM —— 垃圾回收器</title>
    <link href="https://leslieaibin.github.io/2021/06/05/JVM/16.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>https://leslieaibin.github.io/2021/06/05/JVM/16.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</id>
    <published>2021-06-05T01:15:42.000Z</published>
    <updated>2021-06-09T06:54:15.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商，不用版本的JVM来实现。</p><p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p><p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p><p>Java不同版本新特性</p><ul><li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum</li><li>API层面：Stream API、新的日期时间、OPtional、String、集合框架</li><li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池位置变化</li></ul><h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h3><h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a>按线程数分</h4><p>按线程数分（垃圾回收线程数），可以分为<code>串行垃圾回收器</code>和<code>并行垃圾回收器</code></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713083030867.png" alt="image-20200713083030867"></p><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><ul><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能可以远超并行回收器和并发回收器。所以，串行回收器默认被应用在客户端的Client模式下的JVM中。</li><li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li></ul><p>和串行回收相反，并行收集可以运行多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了”STW”机制。</p><h4 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h4><p>按照工作模式分，可以分为<code>并发式垃圾回收器</code>和<code>独占式垃圾回收器</code>。</p><ul><li>并发式垃圾回收器与应用线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序的所有用户线程，知道垃圾回收过程完全结束。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713083443486.png" alt="image-20200713083443486"></p><h4 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="headerlink" title="按碎片处理方式分"></a>按碎片处理方式分</h4><p>按碎片处理方式分，分为<code>压缩式垃圾回收器</code>和<code>非压缩式垃圾回收器</code></p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片</li><li>非压缩式的垃圾回收器不进行这步操作</li></ul><p>按照工作的区间分，又可分为年轻代垃圾回收器和老年垃圾回收器。</p><h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><ul><li><strong>吞吐量：</strong> 运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li><li><strong>垃圾收集开销：</strong> 吞吐量的补数，垃圾收集所用时间与总运行时间的比例</li><li><strong>暂停时间：</strong>执行垃圾收集时，程序的工作线程被暂停的时间</li><li><strong>收集频率：</strong>相对于应用程序的执行，收集操作发生的频率</li><li><strong>内存占用：</strong>Java堆区所占的内存大小</li><li><strong>快速：</strong>一个对象从诞生到被回收所经历的时间</li></ul><p>吞吐量、暂停时间、内存占用这三者共同努力构成一个”不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的垃圾收集器最多同时满足其中两项。这三项里，暂停时间的重要性日益凸显。随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高吞吐量。而内存的扩大，对延迟反而带来了负面效果。</p><p>简单来说，主要抓住两点：</p><ul><li>吞吐量</li><li>暂停时间</li></ul><h3 id="性能指标：吞吐量"><a href="#性能指标：吞吐量" class="headerlink" title="性能指标：吞吐量"></a>性能指标：吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）</p><p>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%</p><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=0.4</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713084726176.png" alt="image-20200713084726176"></p><h3 id="性能指标：暂停时间"><a href="#性能指标：暂停时间" class="headerlink" title="性能指标：暂停时间"></a>性能指标：暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态</p><p>例如，GC期间100ms的暂停时间意味着在这期间内没有应用程序线程时活动的。暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713085306400.png" alt="image-20200713085306400"></p><h3 id="吞吐量VS暂停时间"><a href="#吞吐量VS暂停时间" class="headerlink" title="吞吐量VS暂停时间"></a>吞吐量VS暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><p><strong>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</strong></p><p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p><p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p><p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p><p>那么，Java常见的垃圾收集器有哪些？</p><blockquote><p>GC垃圾收集器和JVM一脉相承的，它是和JVM进行搭配使用，在不同的使用场景对应的收集器也是有区别的</p></blockquote><h3 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="headerlink" title="垃圾回收器发展史"></a>垃圾回收器发展史</h3><p>有了虚拟机，就一定需要手机垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p><ul><li>1999年随JDK1.3.1一起来的是串行方式的serialGc，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li><li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li><li>Parallel GC在JDK6之后成为HotSpot默认GC。</li><li>2012年，在JDK1.7u4版本中，G1可用。</li><li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li><li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。·2019年9月，JDK13发布。增强zGC，自动返回未用堆内存给操作系统。</li><li>2020年3月，JDK14发布。删除cMs垃圾回收器。扩展zGC在macos和Windows上的应用</li></ul><h3 id="7种经典的垃圾收集器"><a href="#7种经典的垃圾收集器" class="headerlink" title="7种经典的垃圾收集器"></a>7种经典的垃圾收集器</h3><ul><li>串行回收器：Serial、Serial old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G1</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713093551365.png" alt="image-20200713093551365"></p><h3 id="7款经典收集器与垃圾分代之间的关系"><a href="#7款经典收集器与垃圾分代之间的关系" class="headerlink" title="7款经典收集器与垃圾分代之间的关系"></a>7款经典收集器与垃圾分代之间的关系</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713093757644.png" alt="image-20200713093757644"></p><p>新生代收集器：Serial、ParNew、Paralle1 Scavenge；</p><p>老年代收集器：Serial old、Parallel old、CMS；</p><p>整堆收集器：G1；</p><h3 id="垃圾收集器的组和关系"><a href="#垃圾收集器的组和关系" class="headerlink" title="垃圾收集器的组和关系"></a>垃圾收集器的组和关系</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713094745366.png" alt="image-20200713094745366"></p><ul><li>两个收集器间有连线，表明他们可以搭配使用：<ul><li>Serial——Serial old</li><li>Serial——CMS</li><li>ParNew——Serial old</li><li>ParNew——CMS</li><li>Parallel Scavenge——Serial Old</li><li>Parallel Scavenge——Parallel</li><li>G1</li></ul></li><li>其中Serial o1d作为CMs出现”Concurrent Mode Failure”失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14中：弃用Paralle1 Scavenge和Serialold GC组合（JEP366）</li><li>（青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）</li></ul><p>为什么要有很多收集器，一个不够么？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同垃圾收集器，提高垃圾收集的性能。</p><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p><h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p><p>Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。</p><p>Serial收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</p><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。Serial old收集器同样也采用了串行回收和”stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</p><ul><li>Serial old是运行在Client模式下默认的老年代的垃圾回收器</li><li>Serial 0ld在Server模式下主要有两个用途：<ul><li>与新生代的Parallel scavenge配合使用</li><li>作为老年代CMS收集器的后备垃圾收集方案</li></ul></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713100703799.png" alt="image-20200713100703799"></p><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><p>优势：简单而高效（与其他收集器的单线程比），对于限定单个cPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><p>运行在client模式下的虚拟机是个不错的选择。</p><p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p><p>在HotSpot虚拟机中，使用-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。</p><p>等价于新生代用Serial GC，且老年代用Serial old GC</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p><h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><p>如果说serialGC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。</p><ul><li>Par是Parallel的缩写，New：只能处理的是新生代</li></ul><p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”stop-the-World”机制。</p><p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713102030127.png" alt="image-20200713102030127"></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？</p><p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p><p>在程序中，开发人员可以通过选项”-XX：+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</p><h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p><p>那么Parallel 收集器的出现是否多此一举？</p><ul><li>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。</li></ul><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel old收集器，用来代替老年代的serialold收集器</p><p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”stop-the-World”机制。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713110359441.png" alt="image-20200713110359441"></p><p>在程序吞吐量优先的应用场景中，IParalle1收集器和Parallel old收集器的组合，在server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>-XX：+UseParallelGC 手动指定年轻代使用Paralle1并行收集器执行内存回收任务。</p><p>-XX：+UseParalleloldcc 手动指定老年代都是使用并行回收收集器。</p><ul><li>分别适用于新生代和老年代。默认jdk8是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul><p>-XX:ParallelGcrhreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>在默认情况下，当CPU数量小于8个，ParallelGcThreads的值等于CPU数量。</p><p>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU Count]/8]</p><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。</p><p>为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。<br>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</p><p>-XX:GCTimeRatio垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p><p>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1。</p><p>与前一个-xx:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p><p>-XX:+UseAdaptivesizepplicy 设置Parallel scavenge收集器具有自适应调节策略</p><p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMil1s），让虚拟机自己完成调优工作。</p><h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><p>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>CMS的垃圾收集算法采用标记-清除算法，并且也会”stop-the-world”</p><p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p><p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713205154007.png" alt="image-20200713205154007"></p><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即<strong>初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</strong>。(涉及STW的阶段主要是：初始标记 和 重新标记)</p><ul><li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li><li><strong>并发标记</strong>（Concurrent-Mark）阶段：从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p><p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”<br>失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713212230352.png" alt="image-20200713212230352"></p><h3 id="CMS为什么不使用标记整理算法？"><a href="#CMS为什么不使用标记整理算法？" class="headerlink" title="CMS为什么不使用标记整理算法？"></a>CMS为什么不使用标记整理算法？</h3><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”<br>这种场景下使用</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>并发收集</li><li>低延迟</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</p></li><li><p>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p></li><li><p>CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</p></li></ul><h3 id="设置的参数"><a href="#设置的参数" class="headerlink" title="设置的参数"></a>设置的参数</h3><ul><li>-XX：+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务。</li></ul><p>开启该参数后会自动将-xx：+UseParNewGC打开。即：ParNew（Young区用）+CMS（01d区用）+Serial old的组合。</p><ul><li>-XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</li></ul><p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次cMs回收。JDK6及以上版本默认值为92%</p><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</p><ul><li>-XX：+UseCMSCompactAtFullCollection用于指定在执行完Ful1</li></ul><p>GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p><ul><li><p>-XX:CMSFullGCsBeforecompaction 设置在执行多少次Ful1GC后对内存空间进行压缩整理。</p></li><li><p>-XX:ParallelcMSThreads 设置cMs的线程数量。</p></li></ul><p>CMs默认启动的线程数是（Paralle1GCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</p><p>请记住以下口令：</p><ul><li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li><li>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</li></ul><h3 id="JDK后续版本中CMS的变化"><a href="#JDK后续版本中CMS的变化" class="headerlink" title="JDK后续版本中CMS的变化"></a>JDK后续版本中CMS的变化</h3><p><strong>JDK9新特性</strong>：CMS被标记为eprecate了（JEP291）&gt;如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX：<br>+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p><p>JDK14新特性：删除CMs垃圾回收器（JEP363）移除了CMS垃圾收集器，如果在JDK14中使用<br>XX：+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p><h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><h3 id="既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？"><a href="#既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？" class="headerlink" title="既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？"></a>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</h3><p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p><p><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong>。</p><h3 id="为什么名字叫-Garbage-First-G1-呢？"><a href="#为什么名字叫-Garbage-First-G1-呢？" class="headerlink" title="为什么名字叫 Garbage First(G1)呢？"></a>为什么名字叫 Garbage First(G1)呢？</h3><p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p><p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</p><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Paralle1+Parallel old组合。被orac1e官方称为“全功能的垃圾收集器”。</p><p>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-xx：+UseG1GC来启用。</p><h3 id="G1垃圾收集器的优点"><a href="#G1垃圾收集器的优点" class="headerlink" title="G1垃圾收集器的优点"></a>G1垃圾收集器的优点</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><p><strong>并行与并发</strong></p><ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><p><strong>分代收集</strong></p><ul><li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><p>G1所谓的分代，已经不是下面这样的了</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713215105293.png" alt="image-20200713215105293"></p><p>而是这样的一个区域</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713215133839.png" alt="image-20200713215133839"></p><p><strong>空间整合</strong></p><ul><li>CMS：“标记-清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li><li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ul><p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong><br>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><h3 id="G1垃圾收集器的缺点"><a href="#G1垃圾收集器的缺点" class="headerlink" title="G1垃圾收集器的缺点"></a>G1垃圾收集器的缺点</h3><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</p><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p><h3 id="G1参数设置"><a href="#G1参数设置" class="headerlink" title="G1参数设置"></a>G1参数设置</h3><ul><li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li><li>-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li><li>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li><li>-XX:+ParallelGcThread 设置STW工作线程数的值。最多设置为8</li><li>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li><li>-XX:InitiatingHeapoccupancyPercent 设置触发并发Gc周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li></ul><h3 id="G1收集器的常见操作步骤"><a href="#G1收集器的常见操作步骤" class="headerlink" title="G1收集器的常见操作步骤"></a>G1收集器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Fu11GC，在不同的条件下被触发。</p><h3 id="G1收集器的适用场景"><a href="#G1收集器的适用场景" class="headerlink" title="G1收集器的适用场景"></a>G1收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p><p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p><p>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于e.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次Gc停顿时间不会过长）。<br>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用61可能比CMS好：</p><ul><li>超过5e%的Java堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC停顿时间过长（长于e.5至1秒）</li></ul><p>HotSpot垃圾收集器里，除了61以外，其他的垃圾收集器使用内置的JVM线程执行Gc的多线程操作，而G1GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h3 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区Region：化整为零</h3><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p><p>XX:G1HeapRegionsize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713223244886.png" alt="image-20200713223244886"></p><p>一个region有可能属于Eden，Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于survivor内存区域，o表示属于01d内存区域。图中空白的表示未使用的内存空间。</p><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p><p><strong>设置H的原因：</strong>对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Fu11Gc。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p>每个Region都是通过指针碰撞来分配空间</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713223509993.png" alt="image-20200713223509993"></p><h3 id="G1垃圾回收器的回收过程"><a href="#G1垃圾回收器的回收过程" class="headerlink" title="G1垃圾回收器的回收过程"></a>G1垃圾回收器的回收过程</h3><p>G1GC的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li></ul><p>（如果需要，单线程、独占式、高强度的Fu11GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713224113996.png" alt="image-20200713224113996"></p><p>顺时针，young gc-&gt;young gc+concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</p><p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p><p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p><p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><p>一个对象被不同区域引用的问题</p><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p><p>在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？这样的话会降低MinorGC的效率；</p><p><strong>解决方法：</strong></p><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p><p>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过cardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713224716715.png" alt="image-20200713224716715"></p><h3 id="G1回收过程-年轻代GC"><a href="#G1回收过程-年轻代GC" class="headerlink" title="G1回收过程-年轻代GC"></a>G1回收过程-年轻代GC</h3><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p><p>YGC时，首先G1停止应用程序的执行（stop-The-Wor1d），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713225100632.png" alt="image-20200713225100632"></p><p>然后开始如下回收过程：</p><ul><li>第一阶段，扫描根</li></ul><p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p><ul><li>第二阶段，更新RSet</li></ul><p>处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p><ul><li>第三阶段，处理RSet</li></ul><p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p><ul><li>第四阶段，复制对象。</li></ul><p>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p><ul><li>第五阶段，处理引用</li></ul><p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p><h3 id="G1回收过程-并发标记过程"><a href="#G1回收过程-并发标记过程" class="headerlink" title="G1回收过程-并发标记过程"></a>G1回收过程-并发标记过程</h3><ul><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是sTw的，并且会触发一次年轻代GC。</li><li>根区域扫描（Root Region Scanning）：G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在youngGC之前完成。</li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是sTw的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ul><h3 id="G1回收过程-混合回收"><a href="#G1回收过程-混合回收" class="headerlink" title="G1回收过程 - 混合回收"></a>G1回收过程 - 混合回收</h3><p>当越来越多的对象晋升到老年代o1d region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old GC，除了回收整个Young Region，还会回收一部分的old Region。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些o1d Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200713225810871.png" alt="image-20200713225810871"></p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</p><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，</p><p>XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为1e%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于1e%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p><h3 id="G1回收可选的过程4-Full-GC"><a href="#G1回收可选的过程4-Full-GC" class="headerlink" title="G1回收可选的过程4 - Full GC"></a>G1回收可选的过程4 - Full GC</h3><p>G1的初衷就是要避免Fu11GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（stop-The-world），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免Fu11GC的发生，一旦发生需要进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到ful1gc，这种情况可以通过增大内存解决。<br>导致61Fu11GC的原因可能有两个：</p><ul><li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><h3 id="G1回收的优化建议"><a href="#G1回收的优化建议" class="headerlink" title="G1回收的优化建议"></a>G1回收的优化建议</h3><p> 从oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><p>年轻代大小</p><ul><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖</li></ul><p>暂停时间目标暂停时间目标不要太过严苛</p><ul><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul><h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714075738203.png" alt="image-20200714075738203"></p><p>GC发展阶段：Seria l=&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7/8后所有收集器及组合如下图</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714080151020.png" alt="image-20200714080151020"></p><h3 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a>怎么选择垃圾回收器</h3><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p><ul><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li><li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ul><p>最后需要明确一个观点：</p><ul><li>没有最好的收集器，更没有万能的收集</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ul><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。<br>这里较通用、基础性的部分如下：</p><p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p><p>垃圾收集器工作的基本流程。</p><p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p><h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><p>通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。<br>内存分配与垃圾回收的参数列表</p><ul><li>-XX:+PrintGc输出GC日志。类似：-verbose:gc</li><li>-XX:+PrintGcDetails输出Gc的详细日志</li><li>-XX:+PrintGcTimestamps 输出Gc的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDatestamps 输出Gc的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）</li><li>-XX:+PrintHeapAtGC在进行Gc的前后打印出堆的信息</li><li>-Xloggc:../logs/gc.1og日志文件的输出路径</li></ul><h3 id="verbose-gc"><a href="#verbose-gc" class="headerlink" title="verbose:gc"></a>verbose:gc</h3><p>打开GC日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc</span><br></pre></td></tr></table></figure><p>这个只会显示总的GC堆的变化，如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714081610474.png" alt="image-20200714081610474"></p><p>参数解析</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714081622526.png" alt="image-20200714081622526"></p><h3 id="PrintGCDetails"><a href="#PrintGCDetails" class="headerlink" title="PrintGCDetails"></a>PrintGCDetails</h3><p>打开GC日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>输入信息如下</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714081909309.png" alt="image-20200714081909309"></p><p>参数解析</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714081925767.png" alt="image-20200714081925767"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>[GC”和”[Fu11GC”说明了这次垃圾收集的停顿类型，如果有”Fu11”则说明GC发生了”stop The World”</li><li>使用Seria1收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</li><li>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</li><li>使用Paralle1 scavenge收集器在新生代的名字是”[PSYoungGen”</li><li>老年代的收集和新生代道理一样，名字也是收集器决定的</li><li>使用G1收集器的话，会显示为”garbage-first heap”</li></ul><p>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p><p>[PSYoungGen：5986K-&gt;696K（8704K）]5986K-&gt;704K（9216K）中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p><p>user代表用户态回收耗时，sys内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过rea1时间</p><h3 id="Young-GC图片"><a href="#Young-GC图片" class="headerlink" title="Young GC图片"></a>Young GC图片</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714082555688.png" alt="image-20200714082555688"></p><h3 id="FullGC图片、"><a href="#FullGC图片、" class="headerlink" title="FullGC图片、"></a>FullGC图片、</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714082714690.png" alt="image-20200714082714690"></p><h3 id="GC回收举例"><a href="#GC回收举例" class="headerlink" title="GC回收举例"></a>GC回收举例</h3><p>我们编写一个程序，用来说明GC收集的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GC垃圾收集过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 陌溪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-14-8:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCUseTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> *_1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> *_1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> *_1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> *_1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设置JVM启动参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714083332238.png" alt="image-20200714083332238"></p><p>然后我们将4M对象存入到Eden区中</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714083526790.png" alt="image-20200714083526790"></p><p>可以用一些工具去分析这些GC日志</p><p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p><p><strong>GCViewer</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714084921184.png" alt="image-20200714084921184"></p><p><strong>GC easy</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714084726824.png" alt="image-20200714084726824"></p><h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><p>GC仍然处于飞速发展之中，目前的默认选项G1GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Fu11GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</p><p>即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。</p><p>比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</p><p>Epsilon:A No-Op GarbageCollector（Epsilon垃圾回收器，”No-Op（无操作）”回收器）<a href="http://openidk.iava.net/iep">http://openidk.iava.net/iep</a> s/318</p><p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）</p><p>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12）</p><blockquote><p>主打特点：低停顿时间</p></blockquote><h3 id="Open-JDK12的Shenandoash-GC"><a href="#Open-JDK12的Shenandoash-GC" class="headerlink" title="Open JDK12的Shenandoash GC"></a>Open JDK12的Shenandoash GC</h3><p>Open JDK12的shenandoash GC：低停顿时间的GC（实验性）</p><p>Shenandoah，无疑是众多GC中最孤独的一个。是第一款不由oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDk没有区别的Oracle公司仍拒绝在oracleJDK12中支持Shenandoah。</p><p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</p><p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714090608807.png" alt="image-20200714090608807"></p><p>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：</p><blockquote><p>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。<br>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</p></blockquote><p>总结</p><ul><li>shenandoah Gc的弱项：高运行负担下的吞吐量下降。</li><li>shenandoah GC的强项：低延迟时间。</li></ul><h3 id="革命性的ZGC"><a href="#革命性的ZGC" class="headerlink" title="革命性的ZGC"></a>革命性的ZGC</h3><p>zGC与shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p><p>《深入理解Java虚拟机》一书中这样定义zGC：2GC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p><p>ZGC的工作过程可以分为4个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong> 等。</p><p>ZGC几乎在所有地方并发执行的，除了初始标记的是STw的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714091201073.png" alt="image-20200714091201073"></p><p>停顿时间对比</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714091401511.png" alt="image-20200714091401511"></p><p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。<br>未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714093243028.png" alt="image-20200714093243028"></p><p>JDK14之前，2GC仅Linux才支持。</p><p>尽管许多使用zGc的用户都使用类Linux的环境，但在Windows和macos上，人们也需要zGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，2GC特性被移植到了Windows和macos上。</p><p>现在mac或Windows上也能使用zGC了，示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions-XX：+UseZGC</span><br></pre></td></tr></table></figure><h3 id="AliGC"><a href="#AliGC" class="headerlink" title="AliGC"></a>AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200714093604012.png" alt="image-20200714093604012"></p><p>当然，其它厂商也提供了各种别具一格的GC实现，例如比较有名的低延迟GC Zing</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收器&quot;&gt;&lt;a href=&quot;#垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收器&quot;&gt;&lt;/a&gt;垃圾回收器&lt;/h1&gt;&lt;h2 id=&quot;GC分类与性能指标&quot;&gt;&lt;a href=&quot;#GC分类与性能指标&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>15.JVM —— 垃圾回收概述</title>
    <link href="https://leslieaibin.github.io/2021/05/25/JVM/15.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/"/>
    <id>https://leslieaibin.github.io/2021/05/25/JVM/15.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/</id>
    <published>2021-05-25T01:15:42.000Z</published>
    <updated>2021-05-25T06:26:30.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>内存的分配与回收</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712084539884.png" alt="image-20200712084539884"></p><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>在提到什么是垃圾之前，我们先看下面一张图</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712085456113.png" alt="image-20200712085456113"></p><p>从上图可以看到，Java和C++的区别，就在于垃圾收集技术和内存动态分配上，C语言没有垃圾收集技术，需要我们手动的收集</p><p>垃圾收集 不是Java的伴生物，早在1960年，第一门开始使用内存动态分配和垃圾收集的Lisp语言诞生</p><p>关于垃圾收集的三个经典问题：</p><ul><li>那些内存需要回收</li><li>什么时候回收</li><li>如何回收</li></ul><p>垃圾收集机制是Java的招牌能力，极大的提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战。</p><p><strong>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾</strong></p><p>如果不及时对内存中的垃圾进行清理，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其他对象使用，甚至可能导致内存溢出</p><h2 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h2><ul><li>清理内存垃圾，防止OOM</li><li>整理内存空间，方便内存分配</li></ul><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。</p><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p><h2 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h2><p>机械硬盘需要进行磁盘整理，同时还有坏道</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712090848669.png" alt="image-20200712090848669"></p><h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><p>早期的C/C++时代，垃圾回收基本上是手工进行的，开发人员可以使用new关键字进行内存的申请，并使用delete关键字急性内存释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MinBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line"><span class="comment">// 如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span>(pBridge-&gt;Register(kDestroy) != NO ERROR)</span><br><span class="line">    <span class="keyword">delete</span> pBridge;</span><br></pre></td></tr></table></figure><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存管理的负担。倘若有一处内存区间犹豫程序猿编码的问题忘记被回收，那么就会产生内存泄漏。垃圾对象永远无法被清楚，随着系统运行时间不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃</p><p>有了垃圾回收机制后，上述代码极有可能变成这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge=<span class="keyword">new</span> cmBaseGroupBridge(); </span><br><span class="line">pBridge-&gt;Register(kDestroy);</span><br></pre></td></tr></table></figure><p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。</p><h2 id="java垃圾回收机制"><a href="#java垃圾回收机制" class="headerlink" title="java垃圾回收机制"></a>java垃圾回收机制</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>自动管理内存，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和溢出的风险</li><li>没有垃圾回收，Java和C++一样，各种悬垂指针，野指针，泄漏问题让人头疼</li><li>自动管理机制，将程序员从繁重的内存管理中释放出来，可以专心业务开发</li></ul><h3 id="担忧："><a href="#担忧：" class="headerlink" title="担忧："></a>担忧：</h3><ul><li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</li><li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li><li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</li></ul><h3 id="GC主要关注的区域"><a href="#GC主要关注的区域" class="headerlink" title="GC主要关注的区域"></a>GC主要关注的区域</h3><p>GC主要关注于<code> 方法区 和堆中的垃圾收集</code></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712092427246.png" alt="image-20200712092427246"></p><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收</p><ul><li>其中，Java堆是垃圾收集器的工作重点</li></ul><p>从次数上讲：</p><ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ul><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h2><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中那些是存活对象，那些是已经死亡的对象。只有被标记为已经死亡的对象，GC才会执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们称为<strong>垃圾标记阶段</strong></p><p>那么在JVM中究竟是如何标记一个死亡对象呢？ 简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：<strong>引用计数算法</strong> 和 <strong>可达性分析算法</strong></p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p><p><strong>优点：</strong> 实现简单，垃圾对象便于辨识，判定效率高，回收没有延迟性</p><p><strong>缺点：</strong> 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销</p><p>每次赋值都需要更新计数器，伴随着假发和减法操作，这增加了时间开销。引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一个致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</p><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712102205795.png" alt="image-20200712102205795"></p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>我们使用一个案例来测试Java中是否采用的是引用计数算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这个成员属性的唯一作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 引用</span></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGc();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: <span class="number">15490</span>K-&gt;<span class="number">808</span>K(<span class="number">76288</span>K)] <span class="number">15490</span>K-&gt;<span class="number">816</span>K(<span class="number">251392</span>K), <span class="number">0.0061980</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.36</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 808K-&gt;0<span class="title">K</span><span class="params">(<span class="number">76288</span>K)</span>] [ParOldGen: 8K-&gt;672<span class="title">K</span><span class="params">(<span class="number">175104</span>K)</span>] 816K-&gt;672<span class="title">K</span><span class="params">(<span class="number">251392</span>K)</span>, [Metaspace: 3479K-&gt;3479<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0045983 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">76288</span>K, used <span class="number">655</span>K [<span class="number">0x000000076b500000</span>, <span class="number">0x0000000770a00000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space <span class="number">65536</span>K, <span class="number">1</span>% used [<span class="number">0x000000076b500000</span>,<span class="number">0x000000076b5a3ee8</span>,<span class="number">0x000000076f500000</span>)</span><br><span class="line">  from space <span class="number">10752</span>K, <span class="number">0</span>% used [<span class="number">0x000000076f500000</span>,<span class="number">0x000000076f500000</span>,<span class="number">0x000000076ff80000</span>)</span><br><span class="line">  to   space <span class="number">10752</span>K, <span class="number">0</span>% used [<span class="number">0x000000076ff80000</span>,<span class="number">0x000000076ff80000</span>,<span class="number">0x0000000770a00000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">175104</span>K, used <span class="number">672</span>K [<span class="number">0x00000006c1e00000</span>, <span class="number">0x00000006cc900000</span>, <span class="number">0x000000076b500000</span>)</span><br><span class="line">  object space <span class="number">175104</span>K, <span class="number">0</span>% used [<span class="number">0x00000006c1e00000</span>,<span class="number">0x00000006c1ea8070</span>,<span class="number">0x00000006cc900000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3486</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 385<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p>我们能够看到，上述进行了GC收集的行为，将上述的新生代中的两个对象都进行回收了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K)</span><br></pre></td></tr></table></figure><p>如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712103230349.png" alt="image-20200712103230349"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。Python如何解决循环引用？</p><blockquote><p>手动解除：很好理解，就是在合适的时机，解除引用关系。<br>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</p></blockquote><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>可达性分析算法： 也可以成为 根搜索算法，追踪性垃圾收集</p><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p><p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫做追踪性垃圾收集（Tracing Garbage Cokkection）</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>所谓”GCRoots” 根集合就是一组必须活跃的引用</p><p>基本思路：</p><ul><li>可达性分析算法是以根对象集合(GCRoots) 为起始点，按照从上到下的方式搜索被跟对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Referebcen Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是活的对象</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712104149246.png" alt="image-20200712104149246"></p><h4 id="GC-Roots可以是那些？"><a href="#GC-Roots可以是那些？" class="headerlink" title="GC Roots可以是那些？"></a>GC Roots可以是那些？</h4><ul><li>虚拟机栈中引用的对象<ul><li>各个线程被调用的方法使用到的参数，局部变量等</li></ul></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性的引用的对象<ul><li>Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>字符串常量池（String Table) 里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException，outofMemoryError），系统类加载器。</li></ul></li><li>反应Java虚拟机内部情况JMXBean，JVMTI中注册的回调，本地代码缓存等</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712104622677.png" alt="image-20200712104622677"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>除了堆空间外的一些结构，比如 虚拟机栈， 本地方法栈，方法区，字符串常量池等地方对堆空间进行引用的， 都可以作为GC Roots 进行可达性分析。</p><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾回收器以及当前回收的内存区域不同，还可以有其他对象”临时性”的加入，共同构成完整的GC Roots集合。比如：分代收集 和 局部回收</p><p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p><h5 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h5><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证</p><p>这点也是导致GC进行时必须”Stop The World”的一个重要原因</p><p>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的</p><h2 id="对象的Finalization机制"><a href="#对象的Finalization机制" class="headerlink" title="对象的Finalization机制"></a>对象的Finalization机制</h2><p>Java语言提供了<code>对象终止（Finalization）</code>机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p><p>当垃圾回收器发生没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p><p>finalze()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件，套接字和数据库连接等</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>永远不要主动调用某个对象的finalize（）方法，应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li>在finalize（）时可能会导致对象复活。</li><li>finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。<ul><li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ul></li><li>一个糟糕的finalize（）会严重影响Gc的性能。</li></ul><p>从功能上来说，finalize（）方法与c++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质上不同于C++中的析构函数。</p><p>由于finalize（）方法的存在，虚拟机中的对象一般处于三种可能的状态。</p><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</li><li>不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<strong>finalize()只会被调用一次</strong>。</li></ul><p>以上3种状态中，是由于finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ul><li><p>如果对象objA到GC Roots没有引用链，则进行第一次标记。</p></li><li><p>进行筛选，判断此对象是否有必要执行finalize（）方法</p><ul><li>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li><li>finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li></ul></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712110411885.png" alt="image-20200712110411885"></p><p>上图就是我们看到的Finalizer线程</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>我们使用重写 finalize()方法，然后在方法的内部，重写将其存放到GC Roots中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Object类中finalize()方法</span></span><br><span class="line"><span class="comment"> * 对象复活场景</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanReliveObj</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类变量，属于GC Roots的一部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj canReliveObj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">        canReliveObj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        canReliveObj = <span class="keyword">new</span> CanReliveObj();</span><br><span class="line">        canReliveObj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------第一次gc操作------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------第二次gc操作------------&quot;</span>);</span><br><span class="line">        canReliveObj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------第一次gc操作------------</span><br><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">obj is still alive</span><br><span class="line">-----------------第二次gc操作------------</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure><p>在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。</p><h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><h3 id="MAT是什么？"><a href="#MAT是什么？" class="headerlink" title="MAT是什么？"></a>MAT是什么？</h3><p><code>MAT是Memory Analyzer的简称</code>，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p><p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p><p>大家可以在<a href="http://www.eclipse.org/mat/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E4%BD%BF%E7%94%A8MAT">http://www.eclipse.org/mat/下载并使用MAT</a></p><h3 id="命令行使用-jmap"><a href="#命令行使用-jmap" class="headerlink" title="命令行使用 jmap"></a>命令行使用 jmap</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712112026317.png" alt="image-20200712112026317"></p><h3 id="使用JVIsualVM"><a href="#使用JVIsualVM" class="headerlink" title="使用JVIsualVM"></a>使用JVIsualVM</h3><p>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</p><p>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择Heap Dump（堆Dump）。</p><p>在Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application（应用程序）栏中对应一个含有时间戳的节点。</p><p>右击这个节点选择save as（另存为）即可将heap dump保存到本地。</p><h3 id="使用MAT打开Dump文件"><a href="#使用MAT打开Dump文件" class="headerlink" title="使用MAT打开Dump文件"></a>使用MAT打开Dump文件</h3><p>打开后，我们就可以看到有哪些可以作为GC Roots的对象</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712112512720.png" alt="image-20200712112512720"></p><p>里面我们能够看到有一些常用的Java类，然后Thread线程。</p><h3 id="JProfiler的GC-Roots溯源"><a href="#JProfiler的GC-Roots溯源" class="headerlink" title="JProfiler的GC Roots溯源"></a>JProfiler的GC Roots溯源</h3><p>我们在实际的开发中，一般不会查找全部的GC Roots，可能只是查找某个对象的整个链路，或者称为GC Roots溯源，这个时候，我们就可以使用JProfiler</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712113256075.png" alt="image-20200712113256075"></p><h3 id="如何判断什么原因造成OOM"><a href="#如何判断什么原因造成OOM" class="headerlink" title="如何判断什么原因造成OOM"></a>如何判断什么原因造成OOM</h3><p>当我们程序出现OOM的时候，我们就需要进行排查，我们首先使用下面的例子进行说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存溢出排查</span></span><br><span class="line"><span class="comment"> * -Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建1M的文件</span></span><br><span class="line">    <span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> HeapOOM());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;count:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用HeapDumpOnOutOfMemoryError将出错时候的dump文件输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure><p>我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712150229048.png" alt="image-20200712150229048"></p><p>然后我们通过线程，还能够定位到哪里出现OOM</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712150303710.png" alt="image-20200712150303710"></p><h2 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是：</p><ul><li><strong>标记-清除算法（Mark Swap)</strong></li><li><strong>复制算法（Mark Copy）</strong></li><li><strong>标记-压缩算法（Mark Compact）</strong></li></ul><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除算法（Mark Swap）是一种非常基础和常见的垃圾收集算法。</p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为 Stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p><ul><li><strong>标记：</strong> Collector 从引用根节点开始遍历，<strong>标记所有被引用的对象</strong>，一般实在对象的Header中记录为可达对象。<strong>标记的是引用对象，不是垃圾</strong>。</li><li><strong>清除：</strong> Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，将其回收</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712150935078.png" alt="image-20200712150935078"></p><h4 id="什么是清除？"><a href="#什么是清除？" class="headerlink" title="什么是清除？"></a>什么是清除？</h4><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下面有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p><p>关于空闲列表是在为对象分配内存的时候</p><ul><li>如果内存规整<ul><li>采用指针碰撞的方式进行内存分配</li></ul></li><li>如果内存不规整<ul><li>虚拟机需要委会一个列表</li><li>空闲列表分配</li></ul></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空间内存是不连续的，产生碎片，需要维护一个空闲列表</li></ul><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。</p><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>将活着的内存分为两块，每次只是用其中一块，在垃圾回收时将正在使用的内存中存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存角色，最后完成垃圾回收。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712151916991.png" alt="image-20200712151916991"></p><p>把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712152029615.png" alt="image-20200712152029615"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul><p>标记-复制算法的优点是解决了<strong>大对象</strong>分配内存的<code>内存碎片问题</code>，也解决了标记-清除算法中大量垃圾对象导致的<code>清除效率问题</code>。</p><p>缺点也非常的明显，那就是<strong>可分配的内存空间少了整整一半</strong>，而且如果某次存活的对象较多，甚至<strong>全部存活</strong>，那么复制的效率将会非常低。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>复制算法的高效性建立在存活对象少，垃圾对象多的前提下。这种情况在新生代经常发生，但是在老年代，更常见的情况下是大部分对象都是存活对象。如果依然采用复制算法，由于存活对象较多，复制成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他算法。</p><p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JvM的设计者需要在此基础之上进行改进。标记-整理（Mark-Compact）算法由此诞生。</p><h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210519230914716.png" alt="image-20210519230914716"></p><h4 id="标清和标整的区别"><a href="#标清和标整的区别" class="headerlink" title="标清和标整的区别"></a>标清和标整的区别</h4><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p><p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><h4 id="标整的优缺点"><a href="#标整的优缺点" class="headerlink" title="标整的优缺点"></a>标整的优缺点</h4><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><p>综合我们可以找到，没有最好的算法，只有最合适的算法</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li>年轻代（Young Gen）</li></ul><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><ul><li>老年代（Tenured Gen）</li></ul><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>compact阶段的开销与存活对象的数据成正比。</li></ul><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理</strong>，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。<br>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712165318590.png" alt="image-20200712165318590"></p><h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h2><p>在默认情况下，通过system.gc() 或者 Runtime.getRuntime().gc()调用，会显示触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。（不能确保立即生效）</p><p>JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该自动进行，无需手动触发。在一些特殊情况下，如我们编写一个性能基准，我们在运行之间调用System.gc();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemGCTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> class <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemGCTest();</span><br><span class="line">        <span class="comment">// 提醒JVM进行垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// System.runFinalization();</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fianlize</span><span class="params">()</span> <span class="keyword">throws</span> <span class="title">Throwable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.fialize();</span><br><span class="line">        System.out.println(<span class="string">&quot;SystemGCTest 执行了 fialize方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，但是不一定会触发销毁的方法，调用<strong>System.runFinalization()</strong> 会强制调用失去引用对象的finalize()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SystemGCTest 执行了 finalize方法</span><br></pre></td></tr></table></figure><h3 id="手动GC来理解不可达对象的回收"><a href="#手动GC来理解不可达对象的回收" class="headerlink" title="手动GC来理解不可达对象的回收"></a>手动GC来理解不可达对象的回收</h3><p>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 局部变量回收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVarGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发YoungGC的时候，已经被回收了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不会被回收，因为它还存放在局部变量表索引为1的槽中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * localvarGC5中的数组已经被回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        localvarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVarGC localVarGC = <span class="keyword">new</span> LocalVarGC();</span><br><span class="line">        localVarGC.localvarGC3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是印发程序崩溃的罪魁祸首之一。</p><p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</p><p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的<strong>FullGC</strong> ，这时候回回收大量的内存，供应用程序继续使用。</p><p>javadoc中outofMemoryError的解释是，没有空闲空间内存，并且垃圾收集器无法提供更多的内存。</p><p><strong>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</strong></p><ul><li>Java虚拟机的堆内存设置不够。</li></ul><p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</p><ul><li><strong>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</strong></li></ul><p>对于老版本的oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</p><p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的ooM有所改观，出现ooM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</p><p>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><blockquote><p>例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。<br>在java.nio.BIts.reserveMemory（）方法中，我们能清楚的看到，System.gc（）会被调用，以清理空间。</p></blockquote><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><p>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>也称作”<strong>内存渗漏</strong>“。严格来说，只要对象不会再被程序用到，但是GC又不能回收的情况，才叫内存泄漏。</p><p>但是实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的”内存泄漏”</p><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OOM异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理空间，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p><blockquote><p>买房子：80平的房子，但是有10平是公摊的面积，我们是无法使用这10平的空间，这就是所谓的内存泄漏</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712195158470.png" alt="image-20200712195158470"></p><p>Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。</p><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><ul><li><p>单例模式</p><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象不能被回收的，则会导致内存泄漏的产生</p></li><li><p>一些提供Close的资源未关闭导致内存泄漏</p><p>数据库连接（dataSource.getConnection()），网络连接(socket) 和 io 连接必须手动close，否则是不能被回收的。</p></li></ul><h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p> stop-the-world，简称STw，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p><p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。</p><ul><li><p>分析工作必须在一个能确保一致性的快照中进行</p></li><li><p>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</p></li><li><p>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</p></li></ul><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STw的发生。</p><p>STW事件和采用哪款GC无关所有的GC都有这个事件。</p><p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>开发中不要用system.gc() 会导致stop-the-world的发生。</p><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一处理器上运行。</p><p>并发不是真正意义上的 “同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理的得当，即可让用户感觉是多个应用程序同时进行。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712202522051.png" alt="image-20200712202522051"></p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Paralle1）。</p><p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p><p>适合科学计算，后台处理等弱交互场景</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712202822129.png" alt="image-20200712202822129"></p><h3 id="并发和并行对比"><a href="#并发和并行对比" class="headerlink" title="并发和并行对比"></a>并发和并行对比</h3><p><strong>并发</strong>，指的是多个事情，在同一时间段内同时发生了。</p><p><strong>并行</strong>，指的是多个事情，在同一时间点上同时发生了。</p><p>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</p><p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。</p><p>否则，看似同时发生的事情，其实都是并发执行的。</p><h3 id="垃圾回收的并行与并发-1"><a href="#垃圾回收的并行与并发-1" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><ul><li><p>并行（Paralle1）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel old；</p></li><li><p>串行（Serial）</p><ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li></ul></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712203607845.png" alt="image-20200712203607845"></p><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。&gt;用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</p><blockquote><p>如：CMS、G1</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712203815517.png" alt="image-20200712203815517"></p><h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为<code>“安全点（Safepoint）”</code>。</p><p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p><p>如何在cc发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p><ul><li><strong>抢先式中断</strong>：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li><strong>主动式中断</strong>：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li></ul><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于sleep-状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p><p><strong>执行流程：</strong></p><ul><li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Relgion，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li></ul><h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p><p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？<br>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p><ul><li><code>强引用（Strong Reference）</code></li><li><code>软引用（Soft Reference）</code></li><li><code>弱引用（Weak Reference）</code></li><li><code>虚引用（Phantom Reference）</code></li></ul><p>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.1ang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p><p>.<img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712205813321.png" alt="image-20200712205813321"></p><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ul><li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object（）”这种引用关系。无论任何情况下，==只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象==。</li><li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li><li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。==为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知==。</li></ul><h2 id="再谈引用：强引用"><a href="#再谈引用：强引用" class="headerlink" title="再谈引用：强引用"></a>再谈引用：强引用</h2><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p><p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p><h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>强引用的案例说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;hello mogublog&quot;</span>);</span><br></pre></td></tr></table></figure><p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712211501377.png" alt="image-20200712211501377"></p><p>如果此时，在运行一个赋值语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;hello mogublog&quot;</span>);</span><br><span class="line">StringBuffer str1 = str;</span><br></pre></td></tr></table></figure><p>对应的内存结构为:</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200712211732976.png" alt="image-20200712211732976"></p><p>那么我们将 str = null; 则 原来堆中的对象也不会被回收，因为还有其它对象指向该区域</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ul><h2 id="再谈引用：-软引用"><a href="#再谈引用：-软引用" class="headerlink" title="再谈引用： 软引用"></a>再谈引用： 软引用</h2><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><blockquote><p>注意，这里的第一次回收是不可达的对象</p></blockquote><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p><blockquote><p>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</p></blockquote><p>在JDK1.2版之后提供了SoftReference类来实现软引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 创建一个软引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用，这是必须的，不然会存在强引用和软引用</span></span><br></pre></td></tr></table></figure><h2 id="再谈引用：弱引用"><a href="#再谈引用：弱引用" class="headerlink" title="再谈引用：弱引用"></a>再谈引用：弱引用</h2><blockquote><p>发现即回收</p></blockquote><p>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p><p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 创建一个弱引用</span></span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用，这是必须的，不然会存在强引用和弱引用</span></span><br></pre></td></tr></table></figure><p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p><p>面试题：你开发中使用过WeakHashMap吗？</p><p>WeakHashMap用来存储图片信息，可以在内存不足的时候，及时回收，避免了OOM</p><h2 id="再谈引用：虚引用"><a href="#再谈引用：虚引用" class="headerlink" title="再谈引用：虚引用"></a>再谈引用：虚引用</h2><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null</p><p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><blockquote><p>虚引用无法获取到我们的数据</p></blockquote><p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 声明引用队列</span></span><br><span class="line">ReferenceQueue phantomQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line"><span class="comment">// 声明虚引用（还需要传入引用队列）</span></span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="keyword">null</span>; </span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>我们使用一个案例，来结合虚引用，引用队列，finalize进行讲解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前类对象的声明</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;</span><br><span class="line">    <span class="comment">// 引用队列</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize方法&quot;</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.getStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> PhantomReferenceTest();</span><br><span class="line">        <span class="comment">// 构造了PhantomReferenceTest对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(phantomReference.get());</span><br><span class="line">            <span class="comment">// 去除强引用</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 第一次进行GC，由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第一次GC操作&quot;</span>);</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 不是 null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第二次GC操作&quot;</span>);</span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 不是 null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line">第一次GC操作</span><br><span class="line">调用当前类的finalize方法</span><br><span class="line">obj 不是 <span class="keyword">null</span></span><br><span class="line">第二次GC操作</span><br><span class="line">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="line">obj 是 <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>从上述运行结果我们知道，第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次gc，因为会调用finalize方法，将对象复活了，所以对象没有被回收，但是调用第二次gc操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是 将回收的值存入到引用队列中。</p><h2 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h2><p>它用于实现对象的finalize() 方法，也可以称为终结器引用</p><p>无需手动编码，其内部配合引用队列使用</p><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收概述&quot;&gt;&lt;a href=&quot;#垃圾回收概述&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收概述&quot;&gt;&lt;/a&gt;垃圾回收概述&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>14.JVM —— StringTable</title>
    <link href="https://leslieaibin.github.io/2021/05/17/JVM/14.StringTable/"/>
    <id>https://leslieaibin.github.io/2021/05/17/JVM/14.StringTable/</id>
    <published>2021-05-17T01:15:42.000Z</published>
    <updated>2021-05-25T06:24:06.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><ul><li><p>String：字符串，使用一对””引起来表示</p><ul><li>String s1 = “mogublog”； //  字面量的定义方式  创建一个对象 或者不创建对象</li><li>String s2 = new String(“moxi”)； //创建一个或者两个对象  s2 为新创建的</li></ul></li><li><p>String声明为final 的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String 可以比较大小</p></li><li><p>String在JDK8及以前内部定义了 fianl char[] value用于存储字符串数据。JDK9时改为byte[]</p></li></ul><h3 id="为什么JDK9改变了结构"><a href="#为什么JDK9改变了结构" class="headerlink" title="为什么JDK9改变了结构"></a>为什么JDK9改变了结构</h3><p>String类的当前实现将字符存储在char数组中，每个字符使用两个字节（16位）。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。</p><p>我们建议改变字符串的内部表示clasš从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1/Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。</p><p>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value</span><br></pre></td></tr></table></figure><p>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</p><h3 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h3><p>String：代表不可变的字符序列。简称：不可变性</p><p>当字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</p><p>当调用String 的replace() 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</p><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字面量定义的方式，“abc”存储在字符串常量池中</span></span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="comment">// 只要进行了修改，就会重新创建一个对象，这就是不可变性</span></span><br><span class="line">        s2 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s2 = s1.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">hello</span><br><span class="line">abc</span><br><span class="line">----------------</span><br><span class="line">abc</span><br><span class="line">abcdef</span><br><span class="line">----------------</span><br><span class="line">abc</span><br><span class="line">mbc</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p><p>String的string Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进string Pool的string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。</p><p>使用-XX:StringTablesize可设置stringTab1e的长度</p><p>在jdk6中stringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。stringTablesize设置没有要求</p><p>在jdk7中，stringTable的长度默认值是60013，</p><p>在JDK8中，StringTable可以设置的最小值为1009</p><h2 id="Sring的内存分配"><a href="#Sring的内存分配" class="headerlink" title="Sring的内存分配"></a>Sring的内存分配</h2><p>在Java语言中有8中基本数据类型和一种比较特殊的类型String。这些类型为了使他们在运行过程中速度更快、更节省内存、都提供了一种常量池概念。</p><p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。他的主要使用方法有两种</p><p>直接使用双引号声明出来的String对象会直接存储在常量池中</p><p>如果不是双引号声明的String对象，可以使用String提供的intern（）方法</p><p>Java 6及以前，字符串常量池存放在永久代</p><p>Java 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p><blockquote><p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p><p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用string.intern（）。</p></blockquote><p>Java8元空间，字符串常量在堆</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210516200425682.png" alt="image-20210516200425682"></p><h3 id="为什么StringTable从永久代调整到堆中"><a href="#为什么StringTable从永久代调整到堆中" class="headerlink" title="为什么StringTable从永久代调整到堆中"></a>为什么StringTable从永久代调整到堆中</h3><p>在JDK 7中，interned字符串不再在Java堆的永久生成中分配，而是在Java堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern()方法会看到更显著的差异。</p><ul><li>永久代的默认比较小</li><li>永久代垃圾回收频率低</li></ul><h2 id="String的基本操作"><a href="#String的基本操作" class="headerlink" title="String的基本操作"></a>String的基本操作</h2><p>java语言规范要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p><h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><ul><li>常量与常量的拼接结果在常量池，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用interm()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> +<span class="string">&quot;c&quot;</span>;  <span class="comment">// 得到abc的常量池</span></span><br><span class="line">    String s2 = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// abc存放在常量池中，直接将常量池的地址返回</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 最终java变异成.class、再执行.class</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true 因为存放在字符串常量池</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">//true </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;    </span><br><span class="line">        String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">        String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s3 == s5); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3 == s6); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3 == s7); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s5 == s6); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s5 == s7); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s6 == s7); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        String s8 = s6.intern();</span><br><span class="line">        System.out.println(s3 == s8); <span class="comment">// true</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述的结果我们可以知道：</p><p>如果拼接符号的前后出现了变量，则相当于在堆空间中<code>new String()</code>，具体的内容为拼接的结果。而调用intern方法，则会判断字符串常量池中是否存在JavaEEhadoop值，如果存在则返回常量池中的值，否则就在常量池中创建</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>拼接操作的底层其实使用了StringBuilder</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200711102231129.png" alt="image-20200711102231129"></p><p>s1 + s2的执行细节</p><ul><li>StringBuilder s = new StringBuilder();</li><li>s.append(s1);</li><li>s.append(s2);</li><li>s.toString();  -&gt; 类似于new String(“ab”);</li></ul><p>在JDK5之后，使用的是StringBuilder，在JDK5之前使用的是StringBuffer</p><p>在JDK5之后，使用的是StringBuilder，在JDK5之前使用的是StringBuffer</p><table><thead><tr><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td><td>StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td><td>可变类，速度更快</td></tr><tr><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td></td><td>线程安全</td><td>线程不安全</td></tr><tr><td></td><td>多线程操作字符串</td><td>单线程操作字符串</td></tr></tbody></table><p>注意，我们左右两边如果是变量的话，就是需要new StringBuilder进行拼接，但是如果使用的是final修饰，则是从常量池中获取。所以说拼接符号左右两边都是字符串常量或常量引用 则仍然使用编译器优化。<strong>也就是说被final修饰的变量，将会变成常量，类和方法将不能被继承、</strong></p><ul><li>在开发中，能够使用final的时候，建议使用上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String s4 = s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="拼接操作和append性能对比"><a href="#拼接操作和append性能对比" class="headerlink" title="拼接操作和append性能对比"></a>拼接操作和append性能对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>&#123;</span><br><span class="line">    String src = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src += <span class="string">&quot;a&quot;</span>; <span class="comment">// 每次循环都会创建一个StringBuilder对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法1耗费的时间：4005ms，方法2消耗时间：7ms</p><p>结论：</p><ul><li>通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法</li></ul><p>好处</p><ul><li>StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象</li><li>对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象</li><li>内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间</li></ul><p>改进的空间</p><ul><li>我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数</li><li>因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度</li></ul><h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h2><p><strong>intern是一个native方法，调用的是底层C的方法</strong></p><p>字符串池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串对象相等的字符串，则返回池中的字符串。否则，该字符串对象将被添加到池中，并返回对该字符串对象的引用。</p><p>如果不是用双引号声明的string对象，可以使用string提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String myInfo = <span class="keyword">new</span> string(<span class="string">&quot;I love atguigu&quot;</span>).intern();</span><br></pre></td></tr></table></figure><p>也就是说，如果在任意字符串上调用string.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>）.intern（）==<span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p>通俗点讲，Interned string就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p><h3 id="intern的空间效率测试"><a href="#intern的空间效率测试" class="headerlink" title="intern的空间效率测试"></a>intern的空间效率测试</h3><p>我们通过测试一下，使用了intern和不使用的时候，其实相差还挺多的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> String[MAX_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer [] data = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i%data.length])).intern();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论</strong>：对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省内存空间。</p><p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="new-String-“ab”-会创建几个对象"><a href="#new-String-“ab”-会创建几个对象" class="headerlink" title="new String(“ab”)会创建几个对象"></a>new String(“ab”)会创建几个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new String(&quot;ab&quot;) 会创建几个对象？ 看字节码就知道是2个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们转换成字节码来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #2 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 ldc #3 &lt;ab&gt;</span><br><span class="line"> 6 invokespecial #4 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line"> 9 astore_1</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure><p>这里面就是两个对象</p><ul><li>一个对象是：new关键字在堆空间中创建</li><li>另一个对象：字符串常量池中的对象</li></ul><h3 id="new-String-“a”-new-String-“b”-会创建几个对象"><a href="#new-String-“a”-new-String-“b”-会创建几个对象" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象"></a>new String(“a”) + new String(“b”) 会创建几个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new String(&quot;ab&quot;) 会创建几个对象？ 看字节码就知道是2个对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码文件为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #2 &lt;java&#x2F;lang&#x2F;StringBuilder&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 invokespecial #3 &lt;java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"> 7 new #4 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line">10 dup</span><br><span class="line">11 ldc #5 &lt;a&gt;</span><br><span class="line">13 invokespecial #6 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line">16 invokevirtual #7 &lt;java&#x2F;lang&#x2F;StringBuilder.append&gt;</span><br><span class="line">19 new #4 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line">22 dup</span><br><span class="line">23 ldc #8 &lt;b&gt;</span><br><span class="line">25 invokespecial #6 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line">28 invokevirtual #7 &lt;java&#x2F;lang&#x2F;StringBuilder.append&gt;</span><br><span class="line">31 invokevirtual #9 &lt;java&#x2F;lang&#x2F;StringBuilder.toString&gt;</span><br><span class="line">34 astore_1</span><br><span class="line">35 return</span><br></pre></td></tr></table></figure><p>我们创建了6个对象</p><ul><li>对象1：new StringBuilder()</li><li>对象2：new String(“a”)</li><li>对象3：常量池的 a</li><li>对象4：new String(“b”)</li><li>对象5：常量池的 b</li><li>对象6：toString中会创建一个 new String(“ab”)<ul><li>调用toString方法，不会在常量池中生成ab</li></ul></li></ul><h3 id="intern的使用：JDK6和JDK7"><a href="#intern的使用：JDK6和JDK7" class="headerlink" title="intern的使用：JDK6和JDK7"></a>intern的使用：JDK6和JDK7</h3><h4 id="JDK6中"><a href="#JDK6中" class="headerlink" title="JDK6中"></a>JDK6中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);  <span class="comment">// 在常量池中已经有了</span></span><br><span class="line">s.intern(); <span class="comment">// 将该对象放入到常量池。但是调用此方法没有太多的区别，因为已经存在了1</span></span><br><span class="line">String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">System.out.println(s == s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>为什么对象会不一样呢？</p><ul><li>一个是new创建的对象，一个是常量池中的对象，显然不是同一个</li></ul><p>如果是下面这样的，那么就是true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; new String(&quot;1&quot;);</span><br><span class="line">s &#x3D; s.intern();</span><br><span class="line">String s2 &#x3D; &quot;1&quot;;</span><br><span class="line">System.out.println(s &#x3D;&#x3D; s2); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>而对于下面的来说，因为 s3变量记录的地址是  new String(“11”)，然后这段代码执行完以后，常量池中不存在 “11”，这是JDK6的关系，然后执行 s3.intern()后，就会在常量池中生成 “11”，最后 s4用的就是s3的地址</p><blockquote><p>为什么最后输出的 s3 == s4  会为false呢？</p><p>这是因为在JDK6中创建了一个新的对象 “11”，也就是有了新的地址， s2 = 新地址</p><p>而在JDK7中，在JDK7中，并没有创新一个新对象，而是指向常量池中的新对象</p></blockquote><h4 id="JDK7中"><a href="#JDK7中" class="headerlink" title="JDK7中"></a>JDK7中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; new String(&quot;1&quot;);</span><br><span class="line">s.intern();</span><br><span class="line">String s2 &#x3D; &quot;1&quot;;</span><br><span class="line">System.out.println(s &#x3D;&#x3D; s2); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">String s3 &#x3D; new String(&quot;1&quot;) + new String(&quot;1&quot;);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 &#x3D; &quot;11&quot;;</span><br><span class="line">System.out.println(s3 &#x3D;&#x3D; s4); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200711145925091.png" alt="image-20200711145925091"></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;  <span class="comment">// 在常量池中生成的字符串</span></span><br><span class="line">s3.intern();  <span class="comment">// 然后s3就会从常量池中找，发现有了，就什么事情都不做</span></span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure><p>我们将 s4的位置向上移动一行，发现变化就会很大，最后得到的是 false</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结string的intern（）的使用：</p><p>JDK1.6中，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，会把此<strong>对象复制一份</strong>，放入串池，并返回串池中的对象地址</li></ul><p>JDK1.7起，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，则会把<strong>对象的引用地址</strong>复制一份，放入串池，并返回串池中的引用地址</li></ul><p>练习：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200711150859709.png" alt="image-20200711150859709"></p><ul><li>在JDK6中，在字符串常量池中创建一个字符串 “ab”</li><li>在JDK8中，在字符串常量池中没有创建 “ab”，而是将堆中的地址复制到 串池中。</li></ul><p>所以上述结果，在JDK6中是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>在JDK8中是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200711151326909.png" alt="image-20200711151326909"></p><p>针对下面这题，在JDK6和8中表现的是一样的</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200711151433277.png" alt="image-20200711151433277"></p><h2 id="StringTable的垃圾回收"><a href="#StringTable的垃圾回收" class="headerlink" title="StringTable的垃圾回收"></a>StringTable的垃圾回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的垃圾回收</span></span><br><span class="line"><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            String.valueOf(i).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h2><p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：</p><ul><li><p>堆存活数据集合里面string对象占了25%</p></li><li><p>堆存活数据集合里面重复的string对象有13.5%</p></li><li><p>string对象的平均长度是45</p></li></ul><p>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说：</p><p>stringl.equals（string2）= true。堆上存在重复的string对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的string对象。</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。</li><li>使用一个hashtab1e来记录所有的被string对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，string对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li></ul><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><p>命令行选项</p><blockquote><p>UsestringDeduplication（bool）：开启string去重，默认是不开启的，需要手动开启。<br>Printstringbeduplicationstatistics（bool）：打印详细的去重统计信息<br>stringpeduplicationAgeThreshold（uintx）：达到这个年龄的string对象被认为是去重的候选对象</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;StringTable&quot;&gt;&lt;a href=&quot;#StringTable&quot; class=&quot;headerlink&quot; title=&quot;StringTable&quot;&gt;&lt;/a&gt;StringTable&lt;/h1&gt;&lt;h2 id=&quot;String的基本特性&quot;&gt;&lt;a href=&quot;#String</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>13.JVM —— 执行引擎</title>
    <link href="https://leslieaibin.github.io/2021/05/15/JVM/13.%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>https://leslieaibin.github.io/2021/05/15/JVM/13.%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</id>
    <published>2021-05-15T11:15:42.000Z</published>
    <updated>2021-05-25T09:07:57.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><p>执行引擎属于JVM的下层，里面包括 <code>解析器、即时编译器、垃圾回收器</code></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710080707873.png" alt="image-20200710080707873"></p><p>执行引擎是Java虚拟核心的组成部分之一。”虚拟机”是一个相对于”物理机”的概念，这两种都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约的定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式</p><p>JVM的主要任务是负责装在字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令，符号表，以及其他辅助信息</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710081118053.png" alt="image-20200710081118053"></p><p>那么，如果想要让一个Java程序运行起来，<code>执行引擎（Execution Engine）</code>的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。<strong>简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</strong></p><h3 id="执行引擎的工作流程"><a href="#执行引擎的工作流程" class="headerlink" title="执行引擎的工作流程"></a>执行引擎的工作流程</h3><ul><li>执行引擎在执行的过程中究竟需要什么样的字节码指令完全依赖于PC寄存器</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710081627217.png" alt="image-20200710081627217"></p><p>从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p>大部分的程序代码转换为物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p><ul><li>前面橙色部分是生成字节码文件的过程，和JVM无关</li><li>后面蓝色和绿色才是JVM需要考虑的过程</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710082141643.png" alt="image-20200710082141643"></p><p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710082433146.png" alt="image-20200710082433146"></p><p>Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710083036258.png" alt="image-20200710083036258"></p><p>我们用一个总的图，来说说 解释器和编译器</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710083656277.png" alt="image-20200710083656277"></p><h3 id="什么是解释器（Interpreter）"><a href="#什么是解释器（Interpreter）" class="headerlink" title="什么是解释器（Interpreter）"></a>什么是解释器（Interpreter）</h3><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><h3 id="什么是IT编译器"><a href="#什么是IT编译器" class="headerlink" title="什么是IT编译器"></a>什么是IT编译器</h3><p><code>JIT（Just In Time Compiler）</code>编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p><h3 id="为什么Java是半编译半解释型语言"><a href="#为什么Java是半编译半解释型语言" class="headerlink" title="为什么Java是半编译半解释型语言"></a>为什么Java是半编译半解释型语言</h3><p>JDK1.e时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p><p>翻译成本地代码后，就可以做一个缓存操作，存储在方法区中</p><h2 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它编写程序，这就是机器语言。</p><p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它变成容易出差错。</p><p>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言变得程序相比执行速度最快。</p><p>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令</p><p>指令就是把机器码中的特定的0和1序列，简化成对应的指令（一般为英文简写，如mov、inc等）可读性稍好</p><p>由于不同的硬件平台，执行统一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>不同的硬件平台支持的指令是有差别的。因此每个平台所支持的指令称之为对应平台的指令集。</p><ul><li>x86指令集，对应的是X86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言</p><p>在汇编语言中，用助词符（Mnemonics）代替机器指令的操作码，用地址符（Symbo1）或标号（Labe1）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p><p>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行</p><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言</p><p>高级语言比机器语言、汇编语言更接近人的语言当计算机执行高级语言编写的程序时，仍然需要把程序解释和变异成机器的指令码。完成这个过程的程序就叫做<strong>解释程序或编译程序</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710085323733.png" alt="image-20200710085323733"></p><p>高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的C和C++</p><h3 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h3><p>编译过程又可以分成两个阶段：编译和汇编。</p><p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710085553258.png" alt="image-20200710085553258"></p><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p><ul><li>字节码典型的应用为：Java bytecode</li></ul><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM设计者们的初衷仅仅只是单纯的为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710090203674.png" alt="image-20200710090203674"></p><p>为什么Java源文件不直接翻译成JVM，而是翻译成字节码文件？可能是因为直接翻译的代码是比较大的</p><p>解释器真正意义上所承担的角色就是一个运行时”翻译者”，将字节码文件中的内容”翻译”为对应平台的本地机器指令执行。</p><p>当一条字节码指令被解释执行完后，接着再根据PC寄存器中记录的下一条需要执行的字节码指令执行解释操作。</p><h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><p>在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><p>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</p><p>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p><p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p><ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。</p><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><h3 id="Java代码的执行分类"><a href="#Java代码的执行分类" class="headerlink" title="Java代码的执行分类"></a>Java代码的执行分类</h3><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p><p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。</p><h3 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h3><p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p><ul><li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li></ul><p>首先明确：</p><p>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。<br>编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p>所以：<br>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</p><p>在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h3 id="HotSpot-JVM执行方式"><a href="#HotSpot-JVM执行方式" class="headerlink" title="HotSpot JVM执行方式"></a>HotSpot JVM执行方式</h3><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710095417462.png" alt="image-20200710095417462"></p><h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><ul><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）</li><li>把字节码转变成机器码的过程。</li><li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。</li></ul><p>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</p><p>JIT编译器：HotSpot VM的C1、C2编译器。</p><p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p><h3 id="热点探测技术"><a href="#热点探测技术" class="headerlink" title="热点探测技术"></a>热点探测技术</h3><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为<code>OSR（On Stack Replacement）</code>编译。</p><p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p><p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</p><p>采用基于计数器的热点探测，HotSpot V将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p><ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul><h3 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h3><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p><p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710101829934.png" alt="image-20200710101829934"></p><h3 id="热点衰减"><a href="#热点衰减" class="headerlink" title="热点衰减"></a>热点衰减</h3><p> 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）</p><ul><li>半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄</li></ul><p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<br>-XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p><p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p><h3 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h3><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710103103869.png" alt="image-20200710103103869"></p><h3 id="HotSpotVM-可以设置程序执行方法"><a href="#HotSpotVM-可以设置程序执行方法" class="headerlink" title="HotSpotVM 可以设置程序执行方法"></a>HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li>-Xint：完全采用解释器模式执行程序；</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200710103340273.png" alt="image-20200710103340273"></p><h3 id="HotSpotVM中-JIT-分类"><a href="#HotSpotVM中-JIT-分类" class="headerlink" title="HotSpotVM中 JIT 分类"></a>HotSpotVM中 JIT 分类</h3><p>JIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><p>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；</p><ul><li>C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。</li></ul></li><li><p>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。</p><ul><li>C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用C++）</li></ul></li></ul><h3 id="C1-和-C2编译器不同的优化策略"><a href="#C1-和-C2编译器不同的优化策略" class="headerlink" title="C1 和 C2编译器不同的优化策略"></a>C1 和 C2编译器不同的优化策略</h3><p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现樊进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul><p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p><ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul><h3 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h3><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p><p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>一般来讲，JIT编译出来的机器码性能比解释器搞</li><li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li></ul><h3 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h3><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p><p>Java 9引入了实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.java -&gt; .class -&gt; (使用jaotc) -&gt; .so</span><br></pre></td></tr></table></figure><p>最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</p><p>缺点：</p><ul><li>破坏了 java  “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ul><h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><ul><li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器</li><li>编译效果短短几年时间就追评了G2编译器，未来可期</li><li>目前，带着实验状态标签，需要使用开关参数去激活才能使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;执行引擎&quot;&gt;&lt;a href=&quot;#执行引擎&quot; class=&quot;headerlink&quot; title=&quot;执行引擎&quot;&gt;&lt;/a&gt;执行引擎&lt;/h1&gt;&lt;h2 id=&quot;执行引擎概述&quot;&gt;&lt;a href=&quot;#执行引擎概述&quot; class=&quot;headerlink&quot; title=&quot;执行引擎概</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>12.JVM —— 直接内存</title>
    <link href="https://leslieaibin.github.io/2021/05/15/JVM/12.%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98Direct%20Memory/"/>
    <id>https://leslieaibin.github.io/2021/05/15/JVM/12.%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98Direct%20Memory/</id>
    <published>2021-05-15T01:15:42.000Z</published>
    <updated>2021-05-25T09:08:12.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直接内存Direct-Memory"><a href="#直接内存Direct-Memory" class="headerlink" title="直接内存Direct Memory"></a>直接内存Direct Memory</h1><p>不是虚拟机运行数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</p><p>直接内存是在Java堆外的，直接想系统申请的内存区间</p><p><code>NIO（Non-blocking I/O，在Java领域，也称为New I/O）</code>，是一种同步非阻塞的I/O模型，也是I/O多路复用的基础</p><p>来源于NIO，通过存在堆中的<code>DirectByteBuffer</code>操作<code>Native内存</code></p><p>通常，访问直接内存的速度优于Java堆内存，即读写性能高</p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul><p>使用下面代码，直接分配本地内存空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> BUffER = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1GB</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocteDirect(BUFFER);</span><br></pre></td></tr></table></figure><h2 id="非直接缓存区和缓存区"><a href="#非直接缓存区和缓存区" class="headerlink" title="非直接缓存区和缓存区"></a>非直接缓存区和缓存区</h2><p>原来采用BIO的架构，我们需要从用户态切换成内核态</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200709170907611.png" alt="image-20200709170907611"></p><p>NIO的方式使用了缓存区的概念</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>也可能导致OOM异常</p><p>由于直接内存在Java堆外，因此它的大小不会直接首先-XMX指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于凑在哦系统能给出的最大内存。</p><p><strong>缺点</strong></p><ul><li>分配回收成本高</li><li>不受JVM内存回收管理</li></ul><p>直接内存大小可以通过MaxDirecyMemorySize设置</p><p>如果不指定，默认与堆的最大值-XMX参数值一致</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200709230647277.png" alt="image-20200709230647277"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;直接内存Direct-Memory&quot;&gt;&lt;a href=&quot;#直接内存Direct-Memory&quot; class=&quot;headerlink&quot; title=&quot;直接内存Direct Memory&quot;&gt;&lt;/a&gt;直接内存Direct Memory&lt;/h1&gt;&lt;p&gt;不是虚拟机运行数据区</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>11.JVM —— 对象实例化内存布局与访问定位</title>
    <link href="https://leslieaibin.github.io/2021/05/14/JVM/11.%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
    <id>https://leslieaibin.github.io/2021/05/14/JVM/11.%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</id>
    <published>2021-05-14T01:15:42.000Z</published>
    <updated>2021-05-25T09:08:11.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象实例化内存布局与访问定位"><a href="#对象实例化内存布局与访问定位" class="headerlink" title="对象实例化内存布局与访问定位"></a>对象实例化内存布局与访问定位</h1><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ul><li>对象在JVM是怎样存储的？</li><li>对象头信息里面有哪些东西？</li><li>Java对象头有什么？</li></ul><p>从对象创建的方式 和 步骤开始说</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200709095356247.png" alt="image-20200709095356247"></p><h3 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h3><ul><li>new : 最常见的方式、单例类中调用getInstance的静态方法，xxxFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为过时方法，因为只能调用空参构造器</li><li>Constructor的newInstance（xxx）：反射的方式，可以调用空参的，或者代参的构造器</li><li>使用clone（）：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</li><li>使用序列化：序列化一般用于Socketde 网络传输</li><li>第三方库Objenesis</li></ul><h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数是否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，适用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p><h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ul><li>如果内存规整：指针碰撞</li><li>如果内存不规整<ul><li>虚拟表需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p>如果内存是规整的，那么虚拟机将采用的是<code>指针碰撞（Bump The Point）</code>来为对象分配内存。</p><p>意思是所有用过的内存在一边，空闲的内存存放另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是吧指针指向空闲那边挪动一段与对象大小相等的距离。如果垃圾收集器选择的是Serial，ParNew这种局域压缩算法的，虚拟机采用这种分配方式。一般使用<code>Compact（整理）</code>过程的收集器，使用指针碰撞。</p><p>如果内存不是规整的，以使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护一个列表，记录那些内存块是可用的，在分配的时候从类表中找到一块足够大的空间划分给对象实例，并更新列表的内容。这种分配方式成为了”空闲列表（Free List）”。</p><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定的</p><h4 id="处理并发问题"><a href="#处理并发问题" class="headerlink" title="处理并发问题"></a>处理并发问题</h4><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配TLAB（Thread Local Allocation Buffer）- 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul><li>在Eden区给每个线程分配一块区域</li></ul></li></ul><h3 id="初始化分配到的内存"><a href="#初始化分配到的内存" class="headerlink" title="初始化分配到的内存"></a>初始化分配到的内存</h3><p>给对象属性赋值的操作</p><ul><li><p>属性的默认初始化</p></li><li><p>显示初始化</p></li><li><p>代码块中的初始化</p></li><li><p>构造器初始化</p></li><li><p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p></li></ul><h3 id="设置对象的对象头"><a href="#设置对象的对象头" class="headerlink" title="设置对象的对象头"></a>设置对象的对象头</h3><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><h3 id="执行init方法进行初始化"><a href="#执行init方法进行初始化" class="headerlink" title="执行init方法进行初始化"></a>执行init方法进行初始化</h3><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><h3 id="对象实例化的过程"><a href="#对象实例化的过程" class="headerlink" title="对象实例化的过程"></a>对象实例化的过程</h3><ul><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ul><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200709151033237.png" alt="image-20200709151033237"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包含了两部分，分别是<code> 运行时元数据（Mark Word）和 类型指针</code></p><blockquote><p>如果是数组，还需要记录数组的长度</p></blockquote><h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><ul><li>哈希值（HashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>翩向时间戳</li></ul><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</p><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200709152801713.png" alt="image-20200709152801713"></p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200709164149920.png" alt="image-20200709164149920"></p><h3 id="对象访问的两种方式"><a href="#对象访问的两种方式" class="headerlink" title="对象访问的两种方式"></a>对象访问的两种方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200709164342002.png" alt="image-20200709164342002"></p><p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p><h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200709164350466.png" alt="image-20200709164350466"></p><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对象实例化内存布局与访问定位&quot;&gt;&lt;a href=&quot;#对象实例化内存布局与访问定位&quot; class=&quot;headerlink&quot; title=&quot;对象实例化内存布局与访问定位&quot;&gt;&lt;/a&gt;对象实例化内存布局与访问定位&lt;/h1&gt;&lt;h2 id=&quot;对象实例化&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>10.JVM —— 方法区</title>
    <link href="https://leslieaibin.github.io/2021/05/14/JVM/10.%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <id>https://leslieaibin.github.io/2021/05/14/JVM/10.%E6%96%B9%E6%B3%95%E5%8C%BA/</id>
    <published>2021-05-13T21:15:42.000Z</published>
    <updated>2021-05-25T09:08:10.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708093918121.png" alt="image-20200708093918121"></p><p>从线程共享与否的角度来看</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708094507624.png" alt="image-20200708094507624"></p><p><code>ThreadLocal：</code>如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p><h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p>下面就涉及了对象的访问定位</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708094747667.png" alt="image-20200708094747667"></p><ul><li>Person: 存放在元空间，也可以说方法区</li><li>person: 存放在Java栈的局部变量表中</li><li>new Person(): 存放在Java堆中</li></ul><h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><p>《Java虚拟机规范》中明确说明：“尽管所有的方法在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做<code>Non-Heap(非堆)</code></p><p>所以，方法区看做是一块独立于Java堆的内存空间</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708095853544.png" alt="image-20200708095853544"></p><p><strong>方法区主要存放的是Class，而堆中主要存放的是实例化的对象</strong></p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域</li><li>方法区在Jvm启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展的</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>ava.lang.OutofMemoryError：PermGen space </code>或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul><li>加载大量的第三方的Jar包</li><li>Tomcat部署工程过多</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存</li></ul><h3 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h3><p>在JDK7及以前，习惯上把方法区，称为永久代。JDK开始，使用源空间取代了永久代。</p><ul><li>JDK1.8后，元空间存放在堆外内存中</li></ul><p>本质上，方法区和永久代并不等价。仅是对HotSpot而言。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM j9中不存在永久代的概念。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708102919149.png" alt="image-20200708102919149"></p><p>而到了JDK8，终于完全废弃了<code>永久代</code>的概念，改用与JRockit、J9一样在本地内存中实现的<code>元空间（Metaspace）</code>来代替</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708103055914.png" alt="image-20200708103055914"></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p><h2 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整</p><h3 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h3><ul><li>通过<code>-xx:Permsize</code>来设置永久代初始分配空间。默认值是<code>20.75M</code></li><li>–XX:MaxPermisze来设定永久代最大分配空间。32位机器默认为64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708111756800.png" alt="image-20200708111756800"></p><h3 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h3><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p><p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p><h3 id="如何解决这些OOM"><a href="#如何解决这些OOM" class="headerlink" title="如何解决这些OOM"></a>如何解决这些OOM</h3><ul><li><p>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</p><ul><li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li></ul></li><li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p></li><li><p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。 </p></li></ul><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210514213555101.png" alt="image-20210514213555101"></p><p>深入理解Java虚拟机中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210514214140750.png" alt="image-20210514214140750"></p><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个记载的类型（类class、接口interface、枚举enum、注解annotation）。JVM必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名 = 包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是Java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h3 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序</p><ul><li><p>方法名称</p></li><li><p>方法的返回类型（或Void)</p></li><li><p>方法参数的数量和类型（按顺序）</p></li><li><p>方法的修饰符（public、private、protected、static、final、synchronized、native、abstract）</p></li><li><p>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</p></li><li><p>异常表（abstract 和 native）</p><p>每个异常处理的开始位置，结束位置，代码处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引</p></li></ul><h3 id="non-finald的类变量"><a href="#non-finald的类变量" class="headerlink" title="non-finald的类变量"></a>non-finald的类变量</h3><p>静态变量和类关联在一7起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethonAreaTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> order();</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，即使我们把order设置为null， 也不会出现空指针异常</p><h3 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h3><p>全局常量就是使用 static fianl 进行修饰</p><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p><h3 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h3><p>运行时常量池，就是运行时常量池</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708171151384.png" alt="image-20200708171151384"></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区</li><li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708172357052.png" alt="image-20200708172357052"></p><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是<code>常量池表（Constant Pool Table）</code>，包括各种字面量和对类型、域和方法的符号引用</p><h3 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h3><p>一个Java源文件中的类，接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这个数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候回用到运行时常量池，之前有介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Ststem.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p><h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么"></a>常量池中有什么</h4><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p>例如下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会被翻译成如下字节码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new <span class="comment">#2  </span></span><br><span class="line">dup</span><br><span class="line">invokespecial</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><code>运行时常量池（Runtime Constant Pool）</code>是方法区的一部分。</p><p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p><p>运行时常量池，相对于Class文件常量池的另一重要特征是：<code>具备动态性。</code></p><p>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</p><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</p><h2 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h2><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x/y;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码执行过程展示</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708204750374.png" alt="image-20200708204750374"></p><p>首先现将操作数500放入到操作数栈中</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708204953552.png" alt="image-20200708204953552"></p><p>然后存储到局部变量表中</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708205029376.png" alt="image-20200708205029376"></p><p>然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708205221737.png" alt="image-20200708205221737"></p><p>将500 和 100 进行一个除法运算，在把结果入栈</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708205413721.png" alt="image-20200708205413721"></p><p>在最后就是输出流，需要调用运行时常量池的常量</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708205708057.png" alt="image-20200708205708057"></p><p>最后调用invokevirtual（虚方法调用），然后返回</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708205909176.png" alt="image-20200708205909176"></p><p>返回时</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708210540696.png" alt="image-20200708210540696"></p><p>程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p><h2 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h2><p>首先明确：只有HotPot才有永久代，</p><p>BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p><p>Hotspot中方法区的变化：</p><table><thead><tr><th>JDK1.6及以前</th><th>有永久代，静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p>JDK6的时候</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708211541300.png" alt="image-20200708211541300"></p><p>JDK7的时候</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708211609911.png" alt="image-20200708211609911"></p><p>JDK8的时候，元空间大小只受物理内存影响</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708211637952.png" alt="image-20200708211637952"></p><h3 id="为什么永久代要被元空间替代？"><a href="#为什么永久代要被元空间替代？" class="headerlink" title="为什么永久代要被元空间替代？"></a>为什么永久代要被元空间替代？</h3><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p><ul><li>为永久代设置空间大小是很难确定的。</li></ul><p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工<br>程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p><p><strong>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</strong><br><strong>因此，默认情况下，元空间的大小仅受本地内存限制。</strong></p><ul><li>对永久代进行调优是很困难的。<ul><li>主要是为了降低Full GC</li></ul></li></ul><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p><h3 id="StringTable为什么要调整位置"><a href="#StringTable为什么要调整位置" class="headerlink" title="StringTable为什么要调整位置"></a>StringTable为什么要调整位置</h3><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而ful1gc是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h3 id="静态变量存放在那里？"><a href="#静态变量存放在那里？" class="headerlink" title="静态变量存放在那里？"></a>静态变量存放在那里？</h3><p>静态引用对应的对象实体始终都存在堆空间</p><p>可以使用 jhsdb.ext，需要在jdk9的时候才引入的</p><p>staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708215025527.png" alt="image-20200708215025527"></p><p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。</p><p>接着，找到了一个引用该staticobj对象的地方，是在一个java.1ang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708215218078.png" alt="image-20200708215218078"></p><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点</p><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p><strong>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</strong></p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的权限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。<br>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200708220303243.png" alt="image-20200708220303243"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;方法区&quot;&gt;&lt;a href=&quot;#方法区&quot; class=&quot;headerlink&quot; title=&quot;方法区&quot;&gt;&lt;/a&gt;方法区&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>9.JVM —— 堆</title>
    <link href="https://leslieaibin.github.io/2021/05/14/JVM/9.%E5%A0%86/"/>
    <id>https://leslieaibin.github.io/2021/05/14/JVM/9.%E5%A0%86/</id>
    <published>2021-05-13T21:15:42.000Z</published>
    <updated>2021-05-15T07:37:24.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但进程包含多个线程，他们是共享同一堆空间的。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706195127740.png" alt="image-20200706195127740"></p><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p><p>Java堆区在JVM启动的时候即被创建，其空间的大小也就确定了，是JVM管理的最大一块内存空间。</p><ul><li>堆内存大小是可以调节的。</li></ul><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内训空间中，但在逻辑上它应该被视为连续的。</p><p>所有线程共享Java堆，在这里还可以划分线程私有的缓冲区<code>（Thread Local Allocation Buffer, TLAB)</code>  </p><ul><li><p>-Xms10m：最小堆内存</p></li><li><p>-Xmx10m：最大堆内存</p><p>下图就是使用: Java VisualVM查看堆空间的内容，通过JDK bin提供的插件</p></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706200739392.png" alt="image-20200706200739392"></p><p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><p>我要说的是: “几乎”所有的对象实例都在这里分配内存。</p><ul><li>因为还有一些对象是在栈上分配的。</li></ul><p>数组和对象可能永远不会在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会移除</p><ul><li><p>也就是触发了GC的时候，才会进行回收</p></li><li><p>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word堆，是<code>GC（Garbage Collection，垃圾收集器）</code>执行垃圾回收的重点区域</p></li></ul><p>  <img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706201904057.png" alt="image-20200706201904057"></p><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p><strong>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+<code>永久区</code></strong></p><ul><li>Young Generation Space 新生区  Young/New  <ul><li> 又被划分为Eden区和Survivor区</li></ul></li><li>Tenure generation space 养老区 Old/Tenure</li><li>Permanent Space 永久区   Perm</li></ul><p><strong>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+<code>元空间</code></strong></p><ul><li>Young Generation Space 新生区  Young/New <ul><li> 又被划分为Eden区和Survivor区</li></ul></li><li>Tenure generation space 养老区  Old/Tenure</li><li>Meta Space  元空间   Meta</li></ul><p>约定：新生区 -&gt; 新生代 -&gt; 年轻代   、  养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706203419496.png" alt="image-20200706203419496"></p><p>堆空间内部结构，JDK1.8之前从永久代  替换成 元空间</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706203835403.png" alt="image-20200706203835403"></p><h2 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项<code>&quot;-Xmx&quot; 和&quot;-Xms&quot;</code>进行设置</p><ul><li>“-Xmx”用于表示堆区的起始内存，等价于-xx:InitialHeaoSize</li><li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul><p>一旦堆区中的内存大小超过”-xmx”所指定的最大内存时，将会抛出<code>outofMemoryError</code>异常。</p><p>通常会将-Xmx 和-Xms两个参数配置相同的值，其目的是为能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</p><p>默认情况下:</p><ul><li>初始内存大小：物理电脑内存大小/64</li><li>最大内存大小：物理电脑内存大小/4</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* -Xms 用来设置堆空间(年轻代 + 老年代) 的初始内存大小</span></span><br><span class="line"><span class="comment">* -X 是jvm运行参数</span></span><br><span class="line"><span class="comment">* ms memory start</span></span><br><span class="line"><span class="comment">* -Xmx 用来设置堆空间(年轻代 + 老年代)的最大内存大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> /<span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机视图使用最大的堆内存</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() /<span class="number">1024</span> /<span class="number">1024</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms:&quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms:245M</span><br><span class="line">-Xmx:3614M</span><br></pre></td></tr></table></figure><p>如何查看堆内存的内存分配情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps  -&gt;  jstat -gc 进程id</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706205756045.png" alt="image-20200706205756045"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706205821919.png" alt="image-20200706205821919"></p><h3 id="OutOfMemory举例"><a href="#OutOfMemory举例" class="headerlink" title="OutOfMemory举例"></a>OutOfMemory举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">           list.add(<span class="keyword">new</span> Picture(<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706210000461.png" alt="image-20200706210000461"></p><p>我们简单的写一个OOM例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OOM测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 陌溪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-06-21:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="number">999999999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210513104641303.png" alt="image-20210513104641303"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="number">999999999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置启动参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx:10m</span><br></pre></td></tr></table></figure><p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706211652779.png" alt="image-20200706211652779"></p><h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>存储在JVM中的Java对象可以划分为两类：</p><ul><li><p>一类是声明周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</p><ul><li>生命周期短的，及时回收即可</li></ul></li><li><p>另一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</p><p>Java堆区进一步细分的，可以划分为<code>年轻代（YoungGen）和 老年代（oldGen）</code></p><p>其中年轻代又可以划分为<code>Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区，to区）</code></p></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707075847954.png" alt="image-20200707075847954"></p><p>下面这参数开发中一般不会调：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707080154039.png" alt="image-20200707080154039"></p><ul><li>Eden：From：to -&gt;  8:1:1</li><li>新生代：老年代  - &gt;  1 : 2</li></ul><p>配置新生代与老年代在堆结构的占比。</p><ul><li><p>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p></li><li><p>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p></li></ul><blockquote><p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p></blockquote><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p><p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p><blockquote><p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p><p>可以使用选项”-Xmn”设置新生代最大内存大小</p><p>这个参数一般使用默认值就可以了。</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707084208115.png" alt="image-20200707084208115"></p><h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ul><li>new的对象先放<code>Eden</code>。此区有大小限制</li><li>当<code>Eden</code>的空间填满时，程序有需要创建对象，JVM的垃圾回收器将对Eden进行垃圾回收<code>（MinorGC)</code>，将Eden中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到Eden中。</li><li>然后将<code>Eden</code>中的剩余对象移动到<code>Survivor0</code>中</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到<code>Survivor0</code>的，如果没有回收，就会放到<code>Survivor1</code>中</li><li>如果再次经历垃圾回收，此时会重新放回<code>Survivor0</code>区，如果没有回收，就会放到<code>Survivor1</code>区</li><li>什么时候能去<code>Old Gen</code>，可以设置次数，默认为15次</li><li>在<code>Old Gen</code>，相对悠闲。当<code>Old Gen</code>内存不足时，再次触发<code>GC：Major GC</code>，进行<code>Old Gen</code>的内存清理</li><li>若<code>Old Gen</code>执行了<code>Major GC</code>之后，发现依然无法进行对象的保存，就会产生<code>OOM</code>异常。</li></ul><h3 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h3><p>我们创建的对象，一般都是存放在<code>Eden</code>区的，当我们Eden区满了后，就会触发GC操作，一般被称为YGC/ Minor GC操作。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707084714886.png" alt="image-20200707084714886"></p><p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在<code>S0(Survivor From)</code>区。同时我们给每个对象设置了一个<code>年龄计数器</code>，一次回收后就是1。</p><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707085232646.png" alt="image-20200707085232646"></p><p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的<code>年龄达到15</code>的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象  晋升到 <code>老年代</code>中</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707085737207.png" alt="image-20200707085737207"></p><h3 id="思考：幸存区区满了后？"><a href="#思考：幸存区区满了后？" class="headerlink" title="思考：幸存区区满了后？"></a>思考：幸存区区满了后？</h3><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p><p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p><blockquote><p>举例：以当兵为例，正常人的晋升可能是 ：  新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</p><p>但是也有可能有些人因为做了非常大的贡献，直接从  新兵 -&gt; 排长</p></blockquote><h3 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707091058346.png" alt="image-20200707091058346"></p><h3 id="代码演示对象分配过程"><a href="#代码演示对象分配过程" class="headerlink" title="代码演示对象分配过程"></a>代码演示对象分配过程</h3><p>不断创建大对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapInstanceTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">200</span>)];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HeapInstanceTest());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置JVM参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms600m -Xmx600m</span><br></pre></td></tr></table></figure><p>然后cmd输入下面命令，打开VisualVM图形化界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvisualvm</span><br></pre></td></tr></table></figure><p>然后通过执行上面代码，通过VisualGC进行动态化查看</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.gif" alt="垃圾回收"></p><p>最终，在老年代和新生代都满了，就出现OOM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.atguigu.java.chapter08.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:13)</span><br><span class="line">at com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:17)</span><br></pre></td></tr></table></figure><h3 id="常用的调优工具"><a href="#常用的调优工具" class="headerlink" title="常用的调优工具"></a>常用的调优工具</h3><ul><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控  推荐~）</li><li>Jprofiler（推荐~）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li><li>新生代采用复制算法的目的：是为了减少内碎片</li></ul><h2 id="Minor-GC、MajorGC、Full-GC"><a href="#Minor-GC、MajorGC、Full-GC" class="headerlink" title="Minor GC、MajorGC、Full GC"></a>Minor GC、MajorGC、Full GC</h2><ul><li>Minor GC: 新生代的GC</li><li>Major GC: 老年代的GC</li><li>Full GC: 整堆收集，收集整个Java堆和方法区的垃圾收集</li></ul><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p><p>而 Major GC 和 Full GC出现<code>STW（Stop The World（停顿类型STW））</code>的时间，是Minor GC的10倍以上</p><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两种大类型：一种是部分收集（Partial GC）， 一种是整堆收集（Full GC）</p><p><strong>部分收集：</strong>不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li><li>老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul><p><strong>整堆收集（FullGC）</strong>：收集整个java堆和方法区的垃圾收集。</p><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p><p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p><blockquote><p>STW：stop the word</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707095606813.png" alt="image-20200707095606813"></p><h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p><p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li></ul><p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>触发Full GC执行的情况有如下五种：</p><ul><li>调用System.gc（）时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p><h3 id="GC-举例"><a href="#GC-举例" class="headerlink" title="GC 举例"></a>GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">&quot;mogu blog&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置JVM启动参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>打印出的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2038K-&gt;500K(2560K)] 2038K-&gt;797K(9728K), 0.3532002 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.36 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2108K-&gt;480K(2560K)] 2405K-&gt;1565K(9728K), 0.0014069 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2288K-&gt;0K(2560K)] [ParOldGen: 6845K-&gt;5281K(7168K)] 9133K-&gt;5281K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058675 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5281K-&gt;5281K(9728K), 0.0002857 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 5281K-&gt;5263K(7168K)] 5281K-&gt;5263K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058564 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 60K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0f138,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 7168K, used 5263K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 73% used [0x00000000ff600000,0x00000000ffb23cf0,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3514K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 388K, capacity 390K, committed 512K, reserved 1048576K</span><br><span class="line">  </span><br><span class="line">  Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOfRange(Arrays.java:3664)</span><br><span class="line">at java.lang.String.&lt;init&gt;(String.java:207)</span><br><span class="line">at java.lang.StringBuilder.toString(StringBuilder.java:407)</span><br><span class="line">at com.atguigu.java.chapter08.GCTest.main(GCTest.java:20)</span><br></pre></td></tr></table></figure><p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p><h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p>为什么要把Java堆分代？不分代就不能正常工作了么？经研究，不同对象的生命周期不同，70%-99%的对象是临时对象。</p><blockquote><p>新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。<br>老年代：存放新生代中经历多次GC仍然存活的对象。</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707101511025.png" alt="image-20200707101511025"></p><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707101543871.png" alt="image-20200707101543871"></p><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（<strong>默认为15岁，其实每个JVM、每个GC都有所不同</strong>）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阈值，可以通过选项<code>-xx：MaxTenuringThreshold</code>来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li><p>优先分配到Eden</p><ul><li>开发中比较长的字符串或者数组，会直接存到老年代，但是因为新创建的对象都是朝生夕死，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比Minor GC要更少，因此可能回收起来就会比较慢。</li></ul></li><li><p>对象直接分配到老年代</p><ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li><p>长期存活的对象分配到老年代</p></li><li><p>动态对象年龄判断</p><ul><li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于改年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li></ul><p>空间分配担保：-xx:HandlePromotionFailure</p></li><li><p>经过 Minor GC后，所有对象都存活，因为Survivor比较小，所以就需要将Survivor 无法容纳的对象，存放到老年代中</p></li></ul><h2 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h2><h3 id="问题：堆空间都是共享的么？"><a href="#问题：堆空间都是共享的么？" class="headerlink" title="问题：堆空间都是共享的么？"></a>问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p><h3 id="为什么有TLAB？"><a href="#为什么有TLAB？" class="headerlink" title="为什么有TLAB？"></a>为什么有TLAB？</h3><p><code>TLAB：Thread Local Allocation Buffer</code>，也就是为每个线程单独分配了一个缓冲区</p><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p><h3 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a>什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707103547712.png" alt="image-20200707103547712"></p><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p><p>在程序中，开发人员可以通过选项<code>“-Xx:UseTLAB”</code>设置是否开启TLAB空间。</p><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项<code>“-Xx:TLABWasteTargetPercent”</code>设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p><h3 id="TLAB分配过程"><a href="#TLAB分配过程" class="headerlink" title="TLAB分配过程"></a>TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707104253530.png" alt="image-20200707104253530"></p><h2 id="小结：堆空间的参数设置"><a href="#小结：堆空间的参数设置" class="headerlink" title="小结：堆空间的参数设置"></a>小结：堆空间的参数设置</h2><ul><li><p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p></li><li><p>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p></li><li><p>-Xms：初始堆空间内存（默认为物理内存的1/64）</p></li><li><p>-Xmx：最大堆空间内存（默认为物理内存的1/4）</p></li><li><p>-Xmn：设置新生代的大小。（初始值及最大值）</p></li><li><p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p></li><li><p>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</p></li><li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p></li><li><p>-XX：+PrintGCDetails：输出详细的GC处理日志</p><ul><li>打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc</li></ul></li><li><p>-XX:HandlePromotionFalilure：是否设置空间分配担保</p></li></ul><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul><li>如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则改为进行一次FullGC。</li><li>如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。</li></ul></li></ul><p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p><h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，<strong>那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</strong>这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><h4 id="逃逸分析举例"><a href="#逃逸分析举例" class="headerlink" title="逃逸分析举例"></a>逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要StringBuffer sb不发生逃逸，可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的逃逸分析代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span> ? <span class="keyword">new</span> EscapeAnalysis():obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">// getInstance().XXX  发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“-xx：+DoEscapeAnalysis”显式开启逃逸分析</li><li>通过选项“-xx：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p>常见的栈上分配的场景</p><blockquote><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p></blockquote><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析  和 未开启逃逸分析时候的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配</span></span><br><span class="line"><span class="comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 未发生逃逸</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置JVM参数，表示未开启逃逸分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>运行结果，同时还触发了GC操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为：664 ms</span><br></pre></td></tr></table></figure><p>然后查看内存的情况，发现有大量的User存储在堆中</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707203038615.png" alt="image-20200707203038615"></p><p>我们在开启逃逸分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为：5 ms</span><br></pre></td></tr></table></figure><p>在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707203441718.png" alt="image-20200707203441718"></p><h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p><p>例如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hellis) &#123;</span><br><span class="line">        System.out.println(hellis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将其转换成字节码</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707205634266.png" alt="image-20200707205634266"></p><h3 id="分离对象和标量替换"><a href="#分离对象和标量替换" class="headerlink" title="分离对象和标量替换"></a>分离对象和标量替换</h3><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p><h3 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></table></figure><p>这里设置参数如下：</p><ul><li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li><li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li><li>参数-Xmx10m：指定了堆空间最大为10MB</li><li>参数-XX:+PrintGC：将打印Gc日志</li><li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。<br>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p><p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p><p>当GC发生在老年代时则被称为Major Gc或者Full GC。一般的，Minor Gc的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h1&gt;&lt;h2 id=&quot;堆的核心概念&quot;&gt;&lt;a href=&quot;#堆的核心概念&quot; class=&quot;headerlink&quot; title=&quot;堆的核心概念&quot;&gt;&lt;/a&gt;堆的核心概</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>8.JVM —— 本地方法接口</title>
    <link href="https://leslieaibin.github.io/2021/05/13/JVM/8.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/"/>
    <id>https://leslieaibin.github.io/2021/05/13/JVM/8.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-05-12T21:15:42.000Z</published>
    <updated>2021-05-15T07:37:31.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h2><p>简单的讲，一个<code>Native Methodt</code>是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法，该方法的实现由非Java语言实现，比如C。这个特征并非Java所持有，很多其他的编程语言，都有这一机制，比如C++中，你可以用extern “c “告知编译器去调用一个c的函数</p><p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706164139252.png" alt="image-20200706164139252"></p><p>代码举例说明Native方法是如何编写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IhaveNatives</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Natives</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：标识符native可以与其它java标识连用，但是abstract除外</p><h2 id="为什么使用Naticve-Method"><a href="#为什么使用Naticve-Method" class="headerlink" title="为什么使用Naticve Method?"></a>为什么使用Naticve Method?</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><h3 id="与Java环境的交互"><a href="#与Java环境的交互" class="headerlink" title="与Java环境的交互"></a>与Java环境的交互</h3><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p><h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h3><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本地方法接口&quot;&gt;&lt;a href=&quot;#本地方法接口&quot; class=&quot;headerlink&quot; title=&quot;本地方法接口&quot;&gt;&lt;/a&gt;本地方法接口&lt;/h1&gt;&lt;h2 id=&quot;什么是本地方法&quot;&gt;&lt;a href=&quot;#什么是本地方法&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>7.JVM —— 虚拟机栈</title>
    <link href="https://leslieaibin.github.io/2021/05/12/JVM/7.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>https://leslieaibin.github.io/2021/05/12/JVM/7.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</id>
    <published>2021-05-11T21:15:42.000Z</published>
    <updated>2021-05-12T08:15:34.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h2><p>由于跨平台的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计基于寄存器的。</p><p>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>有不少Java开发人员一提到Java内存结构，就会非常粗粒度的将JVM中的内存区理解为仅有Java堆（heap）和Java栈（stack）为什么？</p><p>首先栈是运行时的单位，而堆是存储的单位</p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据</li><li>堆解决的是数据存储的问题，即数据怎么放，放在那里。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705163928652.png" alt="image-20200705163928652"></p><h3 id="Java虚拟机栈是什么"><a href="#Java虚拟机栈是什么" class="headerlink" title="Java虚拟机栈是什么"></a>Java虚拟机栈是什么</h3><p><code>Java虚拟机栈（Java Virtual Machine Stack）</code>，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的<code>栈帧（Stack Frame）</code>，对应着一次次的Java方法调用。</p><p><strong>线程私有</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705164722033.png" alt="image-20200705164722033"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>声明周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>主管Java程序的运行，它保存方法的局部变量，部分结果，并参与方法的调用和返回。</p><p>局部变量，它是相比于成员变量来说的（或属性）</p><p>基本数据类型变量 VS 引用类型变量（类、数组、接口）</p><h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序技术器。JVM直接对Java栈操作只有两个：</p><ul><li>每个方法执行，伴随着进展（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705165025382.png" alt="image-20200705165025382"></p><h3 id="开发中遇到哪些异常？"><a href="#开发中遇到哪些异常？" class="headerlink" title="开发中遇到哪些异常？"></a>开发中遇到哪些异常？</h3><p>栈中可能出现的异常</p><p>Java虚拟机孤帆允许Java栈的大小是动态的或者是固定不变的。</p><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<code>StackoverflowError</code>异常</p><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者创建新的线程时没够足够的内存去创建对应的虚拟机栈，那Java虚拟机栈将会抛出<code>outofMemoryError</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StackErrorTest&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.prinyln(count++);</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当栈深度达到9703的时候，就出现栈内存空间不足</p><h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h3><p>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1k</span><br></pre></td></tr></table></figure><h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p><p>在这个县城上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以栈帧格式存在。在这个线程上正在执行的每个方法都有各自对应一个栈帧。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中国的各种数据信息。</p><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循<strong>“先进后出”/“后进先出”</strong>原则。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705203142545.png" alt="image-20200705203142545"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackFrameTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1的开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = method02();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1的结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2的开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = method03();;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2的结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法3的开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法3的结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>的开始</span><br><span class="line">方法<span class="number">2</span>的开始</span><br><span class="line">方法<span class="number">3</span>的开始</span><br><span class="line">方法<span class="number">3</span>的结束</span><br><span class="line">方法<span class="number">2</span>的结束</span><br><span class="line">方法<span class="number">1</span>的结束</span><br></pre></td></tr></table></figure><p>满足栈先进后出的概念，通过Idea的 DEBUG，能够看到栈信息</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210512114320863.png" alt="image-20210512114320863"></p><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（operand Stack） （或表达式栈）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705204836977.png" alt="image-20200705204836977"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有各自的栈，并且每个栈里面都有很多栈帧，栈帧的到小主要由局部变量表 和 操作数栈决定的</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705205443993.png" alt="image-20200705205443993"></p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p><code>局部变量表：Local Variables</code>，被称之为局部变量数组或本地变量表</p><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p><p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p><h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p><p>局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p><p>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（1ong和double）占用两个slot。</p><blockquote><p>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。<br>   1ong和double则占据两个slot。</p></blockquote><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问1ong或doub1e类型变量）</p><p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705212454445.png" alt="image-20200705212454445"></p><h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVarl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVar2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时的b就会复用a的槽位；</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><p>变量的分类：</p><ul><li>按数据类型分：基本数据类型、引用数据类型</li><li>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量<ul><li>类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块</li><li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值</li><li>局部变量：在使用前必须进行显式赋值，不然编译不通过。</li></ul></li></ul><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>操作数栈：Operand Stack</code></p><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 <strong>操作数栈</strong>，也可以称之为 <strong>表达式栈</strong>（Expression Stack）</p><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706090618332.png" alt="image-20200706090618332"></p><p>代码举例</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706090833697.png" alt="image-20200706090833697"></p><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。.</p><blockquote><p>这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的</p></blockquote><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。</p><p>栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</p><p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p><h3 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h3><p>我们给定代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap 命令反编译class文件： javap -v 类名.class</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706092610730.png" alt="image-20200706092610730"></p><blockquote><p>byte、short、char、boolean 内部都是使用int型来进行保存的</p><p>从上面的代码我们可以知道，我们都是通过bipush对操作数 15 和  8进行入栈操作</p><p>同时使用的是 iadd方法进行相加操作，i -&gt; 代表的就是 int，也就是int类型的加法操作</p></blockquote><p>执行流程如下所示：</p><p>首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入栈。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706093131621.png" alt="image-20200706093131621"></p><p>执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706093251302.png" alt="image-20200706093251302"></p><blockquote><p>为什么局部变量表不是从0开始的呢？</p><p>其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了~</p></blockquote><p>然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706093646406.png" alt="image-20200706093646406"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706093751711.png" alt="image-20200706093751711"></p><p>然后从局部变量表中，依次将数据放在操作数栈中</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706093859191.png" alt="image-20200706093859191"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706093921573.png" alt="image-20200706093921573"></p><p>然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706094046782.png" alt="image-20200706094046782"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706094109629.png" alt="image-20200706094109629"></p><p>最后PC寄存器的位置指向10，也就是return方法，则直接退出方法</p><p>i++和++i的区别</p><h2 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h2><p><code>栈顶缓存技术：Top of Stack Cashing</code></p><p>栈顶缓存技术：Top Of Stack Cashing</p><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>动态链接：Dynamic Linking</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706100311886.png" alt="image-20200706100311886"></p><blockquote><p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p></blockquote><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</p><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</p><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706101251847.png" alt="image-20200706101251847"></p><blockquote><p>为什么需要运行时常量池？</p><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></blockquote><h2 id="方法调用：解析与分配"><a href="#方法调用：解析与分配" class="headerlink" title="方法调用：解析与分配"></a>方法调用：解析与分配</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期克制，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p><h4 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h3 id="绑定机制"><a href="#绑定机制" class="headerlink" title="绑定机制"></a>绑定机制</h3><p>对应的方法的绑定机制为：<strong>早期绑定（Early Binding）和晚期绑定（Late Binding）</strong>。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><h4 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h4><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><h4 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h4><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><h3 id="早晚期绑定的发展历史"><a href="#早晚期绑定的发展历史" class="headerlink" title="早晚期绑定的发展历史"></a>早晚期绑定的发展历史</h3><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><h3 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h3><ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、fina1方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><blockquote><p>子类对象的多态的使用前提</p><ul><li>类的继承关系</li><li>方法的重写</li></ul></blockquote><p>虚拟机中提供了以下几条方法调用指令：</p><h4 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h4><ul><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul><h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。</p><h3 id="invokednamic指令"><a href="#invokednamic指令" class="headerlink" title="invokednamic指令"></a>invokednamic指令</h3><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现动态类型语言】支持而做的一种改进。</p><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p><h3 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h3><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p><blockquote><p>Java：String info = “mogu blog”;     (Java是静态类型语言的，会先编译就进行类型检查)</p><p>JS：var name = “shkstart”;    var name = 10;    （运行时才进行检查）</p></blockquote><h3 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h3><h4 id="Java-语言中方法重写的本质："><a href="#Java-语言中方法重写的本质：" class="headerlink" title="Java 语言中方法重写的本质："></a>Java 语言中方法重写的本质：</h4><ul><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.1ang.I1legalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.1ang.AbstractMethodsrror异常。</li></ul><h4 id="IllegalAccessError介绍"><a href="#IllegalAccessError介绍" class="headerlink" title="IllegalAccessError介绍"></a>IllegalAccessError介绍</h4><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><h3 id="方法的调用：虚方法表"><a href="#方法的调用：虚方法表" class="headerlink" title="方法的调用：虚方法表"></a>方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表<br>（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>虚方法表是什么时候被创建的呢？</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706144954070.png" alt="image-20200706144954070"></p><p>如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。</p><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li><p>正常执行完成</p></li><li><p>出现未处理的异常，非正常退出</p></li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p><ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706154554604.png" alt="image-20200706154554604"></p><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p><h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h2><ul><li>举例栈溢出的情况？（StackOverflowError）<ul><li>通过 -Xss设置栈的大小</li></ul></li><li>调整栈大小，就能保证不出现溢出么？<ul><li>不能保证不溢出</li></ul></li><li>分配的栈内存越大越好么？<ul><li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li>垃圾回收是否涉及到虚拟机栈？<ul><li>不会</li></ul></li><li>方法中定义的局部变量是否线程安全？<ul><li>具体问题具体分析</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题</span></span><br><span class="line"><span class="comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> * 何为线程安全？</span></span><br><span class="line"><span class="comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span></span><br><span class="line"><span class="comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 陌溪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-06-16:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程内部创建的，属于局部变量</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stringBuilder 是线程不安全的，操作的是共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时并发的执行，会出现线程不安全的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        method02(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</strong></p><p>运行时数据区，是否存在Error和GC？</p><table><thead><tr><th>运行时数据区</th><th>是否存在Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>否</td></tr><tr><td>虚拟机栈</td><td>是</td><td>否</td></tr><tr><td>本地方法栈</td><td>是</td><td>否</td></tr><tr><td>方法区</td><td>是（OOM）</td><td>是</td></tr><tr><td>堆</td><td>是</td><td>是</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚拟机栈&quot;&gt;&lt;a href=&quot;#虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;虚拟机栈&quot;&gt;&lt;/a&gt;虚拟机栈&lt;/h1&gt;&lt;h2 id=&quot;虚拟机栈概述&quot;&gt;&lt;a href=&quot;#虚拟机栈概述&quot; class=&quot;headerlink&quot; title=&quot;虚拟机栈概</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>6.JVM —— 程序计数器</title>
    <link href="https://leslieaibin.github.io/2021/05/12/JVM/6.%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>https://leslieaibin.github.io/2021/05/12/JVM/6.%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</id>
    <published>2021-05-11T16:15:42.000Z</published>
    <updated>2021-05-12T08:15:01.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JVM中的<code>程序计数器（Program Counter Register)</code>中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有吧数据装在寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC寄存器（或指令寄存器）会更加贴切（也称为程序钩子)，并且不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705155551919.png" alt="image-20200705155551919"></p><p>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。</p><p>在JVM规范中，每个线程都会有自己的额程序计数器，是线程私有的，生命周期与线程的声明周期保持一致。</p><p>任何时间一个线程都是只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址：或者是执行native方法，则是未指定值（undefend）.</p><p>他是唯一一个在Java虚拟机规范中没有规定任何outMemoryError情况的区域。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705155728557.png" alt="image-20200705155728557"></p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i  = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j  = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k  = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: bipush        10</span><br><span class="line">2: istore_1</span><br><span class="line">3: bipush        20</span><br><span class="line">5: istore_2</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_2</span><br><span class="line">8: iadd</span><br><span class="line">9: istore_3</span><br><span class="line">10: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><p>通过PC寄存器，我们就可以知道当前程序执行到哪一步了 </p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705161007423.png" alt="image-20200705161007423"></p><h2 id="使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="使用PC寄存器存储字节码指令地址有什么用呢？"></a>使用PC寄存器存储字节码指令地址有什么用呢？</h2><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705161409533.png" alt="image-20200705161409533"></p><h2 id="PC寄存器为什么被设定为私有的？"><a href="#PC寄存器为什么被设定为私有的？" class="headerlink" title="PC寄存器为什么被设定为私有的？"></a>PC寄存器为什么被设定为私有的？</h2><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705161812542.png" alt="image-20200705161812542"></p><h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705161849557.png" alt="image-20200705161849557"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>5.JVM —— 运行时数据区概述及线程</title>
    <link href="https://leslieaibin.github.io/2021/05/11/JVM/5.%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://leslieaibin.github.io/2021/05/11/JVM/5.%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-05-10T16:15:42.000Z</published>
    <updated>2021-05-12T08:14:43.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="运行时数据区概述及线程"></a>运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，他是类加载完成后的阶段</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705111640511.png" alt="image-20200705111640511"></p><p>当我们通过前面的：类的<strong>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化</strong>  这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705111843003.png" alt="image-20200705111843003"></p><p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序实时运行，JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高校稳定运行。不同JVM对于内存的划分方式和管理机制存在着部分差异。</p><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁。</p><p>运行时数据区的完整图</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705112416101.png" alt="image-20200705112416101"></p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705112601211.png" alt="image-20200705112601211"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。<br>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li></ul><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p><h3 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h3><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|<br>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;运行时数据区概述及线程&quot;&gt;&lt;a href=&quot;#运行时数据区概述及线程&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区概述及线程&quot;&gt;&lt;/a&gt;运行时数据区概述及线程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>4.JVM —— 类加载子系统</title>
    <link href="https://leslieaibin.github.io/2021/05/10/JVM/4.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://leslieaibin.github.io/2021/05/10/JVM/4.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-05-09T16:15:42.000Z</published>
    <updated>2021-05-10T11:11:02.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705080719531.png" alt="image-20200705080719531"></p><p>完整图如下</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705080911284.png" alt="image-20200705080911284"></p><p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p><ul><li>类加载器</li><li>执行引擎</li></ul><h2 id="类加载器子系统作用"><a href="#类加载器子系统作用" class="headerlink" title="类加载器子系统作用"></a>类加载器子系统作用</h2><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p><p>ClassLoader只负责class文件的加载，至于他是否可以运行，则有Execution Engine决定。</p><p>加载的信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705081813409.png" alt="image-20200705081813409"></p><ul><li><p>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</p></li><li><p>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</p></li><li><p>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705081913538.png" alt="image-20200705081913538"></p></li></ul><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p>例如下面的一段简单的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloLoder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我已经被加载了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载的过程：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705082255746.png" alt="image-20200705082255746"></p><p>完整的流程图如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705082601441.png" alt="image-20200705082601441"></p><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><p>通过一个类的全限定名获取定义此类的二进制字节流</p><p>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</p><p>在内存生成一个代表这个类的java.lang.Class对象，作为方法区这个类的歌中数据访问入口</p><h3 id="加载class文件的方式"><a href="#加载class文件的方式" class="headerlink" title="加载class文件的方式"></a>加载class文件的方式</h3><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证 Verify"></a>验证 Verify</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p><p>主要包括四种验证，<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705084038680.png" alt="image-20200705084038680"></p><p>如果出现不合法的字节码文件，那么将会验证不通过</p><p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705090237078.png" alt="image-20200705090237078"></p><p>安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210506191727686.png" alt="image-20210506191727686"></p><h3 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备 Prepare"></a>准备 Prepare</h3><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的变量a在<strong>准备阶段</strong>会赋初始值，但不是1，而是0。</p><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p><h3 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析 Resolve"></a>解析 Resolve</h3><p>将常量池内的符号引用转换为直接引用的过程。</p><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>初始化阶段就是执行类构造器法<clinit>()的过程</p><p>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p><ul><li>也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li></ul><p>构造器方法中指令按语句在源文件中出现的顺序执行。</p><p><clinit>（）不同于类的构造器。（关联：构造器是虚拟机视角下的<init>（））若该类具有父类，JVM会保证子类的<clinit>（）执行前，父类的<clinit>（）已经执行完毕。</p><ul><li>任何一个类在声明后，都有生成一个构造器，默认是空参构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        number = <span class="number">20</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(number);  <span class="comment">//报错，非法的前向引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(ClassInitTest.number); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于涉及到父类时候的变量赋值过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们输出结果为2，也就是说首先加载ClinitTest1的时候，会先找到main方法，然后执行Son的初始化，但是Son继承了Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被赋值成2，最后返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">putstatic #2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br><span class="line">iconst_2</span><br><span class="line">putstatic #2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>虚拟机必须保证一个类<clinit>()方法在多线程下被同步加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 线程t1开始&quot;</span>);</span><br><span class="line">                <span class="keyword">new</span> DeadThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 线程t2开始&quot;</span>);</span><br><span class="line">                <span class="keyword">new</span> DeadThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 代码，输出结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 线程t1开始</span><br><span class="line">t1 初始化当前类</span><br><span class="line">t2 线程t2开始</span><br></pre></td></tr></table></figure><p>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程</p><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>JVM支持两种类型的类加载器。分别为引导类加载器（BootStrap ClassLoader) 和自定义类加载器（User-Defined ClassLoader)。</p><p>从概念上讲，自定义类加载器一般指的是程序中有开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p><p>无论类加载器的类型怎么划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705094149223.png" alt="image-20200705094149223"></p><p>这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统的类加载器</span></span><br><span class="line">        ClassLoader sysremClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;系统的类加载器：&quot;</span> + sysremClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取器上层的： 扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = sysremClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展类加载器&quot;</span> + extClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视图获取 根加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;根加载器：&quot;</span>  + bootstrapClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取自定义加载器</span></span><br><span class="line">        ClassLoader classLoader = ClassLoader.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义加载器&quot;</span> + classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取String类型的加载器</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;String类型的加载器&quot;</span> + classLoader1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果，从结果可以看出根记载器无法直接通过代码获取，同时目前永辉diamante所使用的加载器系统类的加载器。同时我们通过获取String类型的加载器，发现是null,那么说明String类型是通过根记载器进行加载的，也就是说Java的核心类库都是使用跟家在其进行加载的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">系统的类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">扩展类加载器sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="line">根加载器：null</span><br><span class="line">自定义加载器null</span><br><span class="line">String类型的加载器null</span><br></pre></td></tr></table></figure><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader)"></a><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader)</strong></h4><ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h3 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h3><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><h3 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h3><ul><li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li></ul><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。<br>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p>用户自定义类加载器实现步骤：</p><ul><li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul><h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705103516138.png" alt="image-20200705103516138"></p><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705103636003.png" alt="image-20200705103636003"></p><p>获取<code>ClassLoader</code>的途径</p><ul><li>获取当前<code>ClassLoader：clazz.getClassLoader()</code></li><li>获取当前线程上下文的<code>ClassLoader：Thread.currentThread().getContextClassLoader()</code></li><li>获取系统的<code>ClassLoader：ClassLoader.getSystemClassLoader()</code></li><li>获取调用者的<code>ClassLoader：DriverManager.getCallerClassLoader()</code></li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是 <strong>双薪委派模式</strong>，即把请求交到由父类处理，它是一种任务委派模式。</p><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><ul><li>如果一个类加载器收到了类加载请求，他不会自己先去加载，而是把这个请求委派给父类的加载器去执行</li><li>如果父类加载器还存在父类加载器，则进一步向上委托，一次递归，请求最终将叨叨顶层的启动类加载器</li><li>如果父类加载器可以完成类加载器任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这既是双亲委派任务模式。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705105151258.png" alt="image-20200705105151258"></p><h3 id="双亲委派机制举例"><a href="#双亲委派机制举例" class="headerlink" title="双亲委派机制举例"></a>双亲委派机制举例</h3><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705105810107.png" alt="image-20200705105810107"></p><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如何判断俩个class对象是否相同</p><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名</li><li>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。</li></ul><p>换句话说，在JVM中，即使这两个类对象来源同一个Class文件，被同一个虚拟机所加载，但只要加载他们的ClassLoader实例对象不同，那么这两个类对象也是相等的。</p><p>JVM必须知道一个类型是由启动加载器加载的还是有用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一步保存在<strong>方法区</strong>中，当解析一个类型到另一个类型的引用的时候JVM需要保证这两个类型的类加载器是相同的。</p><h3 id="类的制动使用和被动使用"><a href="#类的制动使用和被动使用" class="headerlink" title="类的制动使用和被动使用"></a>类的制动使用和被动使用</h3><p>Java程序对类的使用方式分为：<strong>主动使用和被动使用</strong></p><p>主动使用又分为七种情况：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被表明为启动类的类</li><li>JDK7开始提供的动态语言支持</li><li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类加载子系统&quot;&gt;&lt;a href=&quot;#类加载子系统&quot; class=&quot;headerlink&quot; title=&quot;类加载子系统&quot;&gt;&lt;/a&gt;类加载子系统&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>8.CAS &amp; ABA &amp; AQS</title>
    <link href="https://leslieaibin.github.io/2021/05/04/Thread/8.CAS%20&amp;%20ABA%20&amp;%20AQS/"/>
    <id>https://leslieaibin.github.io/2021/05/04/Thread/8.CAS%20&amp;%20ABA%20&amp;%20AQS/</id>
    <published>2021-05-04T02:15:42.000Z</published>
    <updated>2021-05-04T08:13:32.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p><code>CAS（Compare And Swap）</code>指比较并交换。CAS算法CAS(V,E, N)包含3个参数，V表示要更新的变量，E表示预期的值，N表示新值。在且仅在V值等于 E值时，才会将V值设为 N，如果 V值和 E值不同，则说明已经有其他线程做了更新，当前线程什么都不做。最后，CAS返回当前V的真实值。</p><h2 id="CAS的特性：乐观锁"><a href="#CAS的特性：乐观锁" class="headerlink" title="CAS的特性：乐观锁"></a>CAS的特性：乐观锁</h2><p>CAS操作采用了乐观锁的思想，总是认为自己可以成功完成操作。在有多个线程同时使用CAS操作一个变量时，只有一个会胜出并成功更新，其余均会失败。失败的线程不会被挂起，仅被告知失败，并且允许再次尝试，当然，也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p><h2 id="CAS自旋等待"><a href="#CAS自旋等待" class="headerlink" title="CAS自旋等待"></a>CAS自旋等待</h2><p>在JDK的原子包<code>java.util.concurrent.atomic</code>里面提供了一组原子类，这些原子类的基本特性就是在多线程环境下，在有多个线程同时执行这些类的实例包含的方法时，会有排他性。其内部便是基于CAS算法实现的，即在某个线程进入方法中执行其中的指令时，不会被其他线程打断；而别的线程就像自旋锁一样，一直等到该方法执行完成才由JVM从等待的队列中选择另一个线程进入。</p><p>相对于synchronized阻塞算法，CAS是非阻塞算法的一种常见实现。由于CPU的切换比CPU指令集的操作更加耗时，所以CAS的自旋操作在性能上有了很大的提升。</p><h1 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h1><p>对CAS算法的实现有一个重要的前提：需要取出内存中某时刻的数据，然后在下一时刻进行比较、替换，在这个时间差内可能数据已经发生了变化，导致产生ABA问题。</p><p>ABA问题指第1个线程从内存的V位置取出A，这时第2个线程也从内存中取出A，并将V位置的数据首先修改为B，接着又将V位置的数据修改为A，这时第1个线程在进行CAS操作时会发现在内存中仍然是A，然后第1个线程操作成功。尽管从第1个线程的角度来说，CAS操作是成功的，但在该过程中其实V位置的数据发生了变化，只是第1个线程没有感知到罢了，这在某些应用场景下可能出现过程数据不一致的问题。</p><p>部分乐观锁是通过<code>版本号（version）</code>来解决ABA问题的，具体的操作是乐观锁每次在执行数据的修改操作时都会带上一个版本号，在预期的版本号和数据的版本号一致时就可以执行修改操作，并对版本号执行加1操作，否则执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为<strong>版本号只会增加，不会减少</strong>。</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p><code>AQS(Abstract Aueued Synchronizer)</code>是一个抽象的队列同步器，通过维护一个共享资源状态（Volatile Int State) 和一个先进先出（FIFO）的线程等待队列来实现一个多线程访问共享资源的同步框架。</p><h2 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h2><p>AQS为每个共享资源都设置一个共享资源锁，线程在需要访问共享资源时首先需要获取共享资源锁，如果获取到了共享资源锁，便可以在当前线程中使用该共享资源，如果获取不到，则将该线程放入线程等待队列，等待下一次资源调度。许多同步类的实现都依赖于AQS，例如常用的ReentrantLock、Semaphore和CountDownLatch。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210504160648860.png" alt="image-20210504160648860"></p><h2 id="state：状态"><a href="#state：状态" class="headerlink" title="state：状态"></a>state：状态</h2><p>Abstract Queued Synchronizer维护了一个volatile int类型的变量，用于表示当前的同步状态。Volatile虽然不能保证操作的原子性，但是能保证当前变量state的可见性。state的访问方式有三种：<code>getState()、setState()和compareAndSetState()</code>，均是原子操作，其中，compareAndSetState的实现依赖于Unsafe的compareAndSwapInt()。</p><h2 id="AQS共享资源的方式：独占式和共享式"><a href="#AQS共享资源的方式：独占式和共享式" class="headerlink" title="AQS共享资源的方式：独占式和共享式"></a>AQS共享资源的方式：独占式和共享式</h2><p>AQS定义了两种资源共享方式：<code>独占式（Exclusive）和共享式（Share）</code>。</p><ul><li>独占式：只有一个线程能执行，具体的Java实现有ReentrantLock。</li><li>共享式：多个线程可同时执行，具体的Java实现有Semaphore和CountDownLatch。</li></ul><p>AQS只是一个框架，只定义了一个接口，具体资源的获取、释放都交由自定义同步器去实现。不同的自定义同步器争用共享资源的方式也不同，自定义同步器在实现时只需实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护，如获取资源失败入队、唤醒出队等，AQS已经在顶层实现好，不需要具体的同步器再做处理。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210504161124244.png" alt="image-20210504161124244"></p><p>同步器的实现是AQS的核心内存。ReentrantLock对AQS的独占方式实现为：ReentrantLock中的state初始值为0时表示无锁状态。在线程执行tryAcquire()获取该锁后ReentrantLock中的state+1，这时该线程独占ReentrantLock锁，其他线程在通过tryAcquire()获取锁时均会失败，直到该线程释放锁后state再次为0，其他线程才有机会获取该锁。该线程在释放锁之前可以重复获取此锁，每获取一次便会执行一次state+1，因此ReentrantLock也属于可重入锁。但获取多少次锁就要释放多少次锁，这样才能保证state最终为0。如果获取锁的次数多于释放锁的次数，则会出现该线程一直持有该锁的情况；如果获取锁的次数少于释放锁的次数，则运行中的程序会报锁异常。</p><p>CountDownLatch对AQS的共享方式实现为：CountDownLatch将任务分为N个子线程去执行，将state也初始化为N, N与线程的个数一致，N个子线程是并行执行的，每个子线程都在执行完成后countDown()一次，state会执行CAS操作并减1。在所有子线程都执行完成（state=0）时会unpark()主线程，然后主线程会从await()返回，继续执行后续的动作。</p><p>一般来说，自定义同步器要么采用独占方式，要么采用共享方式，实现类只需实现tryAcquire、tryRelease或tryAcquireShared、tryReleaseShared中的一组即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，例如ReentrantReadWriteLock在读取时采用了共享方式，在写入时采用了独占方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAS&quot;&gt;&lt;a href=&quot;#CAS&quot; class=&quot;headerlink&quot; title=&quot;CAS&quot;&gt;&lt;/a&gt;CAS&lt;/h1&gt;&lt;h2 id=&quot;什么是CAS&quot;&gt;&lt;a href=&quot;#什么是CAS&quot; class=&quot;headerlink&quot; title=&quot;什么是CAS&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>7.线程上下文切换与阻塞队列</title>
    <link href="https://leslieaibin.github.io/2021/05/04/Thread/7.%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://leslieaibin.github.io/2021/05/04/Thread/7.%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2021-05-03T16:15:42.000Z</published>
    <updated>2021-05-04T08:15:01.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h1><p>CPU利用时间片轮询来为每个任务都服务一定的时间，然后把当前任务的状态保存下来，继续服务下一个任务。任务的状态保存及再加载交做线程的上下文切换。</p><ul><li><strong>进程：</strong>指一个运行中的程序的示例。在一个进程内部可以有多个线程在同时运行，并与创建它的进程共享同一个地址空间（一段内存区域）和其他资源。</li><li><strong>上下文：</strong>指线程切换时CPU寄存器和程序计数器所保存的当前线程信息。</li><li><strong>寄存器：</strong>指CPU内部容量较小但速度很快的内存区域（与之对应的是CPU外部相对较慢的RAM主内存）。寄存器通过对常用值（同创是运算的中间值）快速访问来加快计算机程序运行的速度。</li><li><strong>程序计数器：</strong> 是一个专用的寄存器，用于表明指令序列中CPU正在执行的位置，存储的值为正在执行的指令的位置或者下一个将被执行的指令的位置，这依赖于特定的系统。</li></ul><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换。上下文切换过程中的信息被保存在进程控制块<code>（PCB-Process Control Block）</code>中。PCB又被称作切换桢<code>（SwitchFrame）</code>。上下文切换的信息会一直被保存在CPU的内存中，直到被再次使用。上下文的切换流程如下。</p><ul><li>挂起一个进程，将这个进程在CPU中的状态（上下文信息）存储于内存的PCB中。</li><li>在PCB中检索下一个进程的上下文并将其在CPU的寄存器中恢复。</li><li>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行）并恢复该进程。时间片轮转方式使多个任务在同一CPU上的执行有了可能。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210503143118716.png" alt="image-20210503143118716"></p><h2 id="上下文切换的原因"><a href="#上下文切换的原因" class="headerlink" title="上下文切换的原因"></a>上下文切换的原因</h2><p>上下文切换的原因如下：</p><ul><li>当前正在执行的任务完成，系统的CPU正常调度下一个任务。</li><li>当前正在执行的任务遇到I/O等阻塞操作，调度器挂起此任务，继续调度下一个任务。</li><li>多个任务并发抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续调度下一个任务。</li><li>用户的代码挂起当前任务，比如线程执行sleep方法，让出CPU。</li><li>硬件中断</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上下文切换就是一个工作的线程被另外一个线程暂停，另外一个线程占用了处理器开始执行任务的过程。系统和 Java 程序自发性以及非自发性的调用操作，就会导致上下文切换，从而带来系统开销。</p><p>线程越多，系统的运行速度不一定越快。那么我们平时在并发量比较大的情况下，什么时候用单线程，什么时候用多线程呢？</p><p>一般在单个逻辑比较简单，而且速度相对来非常快的情况下，我们可以使用单线程。例如，我们前面讲到的 Redis，从内存中快速读取值，不用考虑 I/O 瓶颈带来的阻塞问题。而在逻辑相对来说很复杂的场景，等待时间相对较长又或者是需要大量计算的场景，我建议使用多线程来提高系统的整体性能。例如，NIO 时期的文件读写操作、图像处理以及大数据分析等。</p><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>队列是一种只允许在表的前端进行删除操作，而在表的后端进行插入操作的线性表。阻塞队列和一般队列的不同之处在于阻塞队列是”阻塞”的，这里的阻塞指的是操作队列的线程的一种状态。在阻塞队列中，线程阻塞有两种情况：</p><ul><li><strong>消费者阻塞：</strong>在队列为空时，消费者端的线程都会被自动阻塞（挂起），直到有数据放入队列，消费者线程会被自动唤醒并消费数据，如图</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210503153612863.png" alt="image-20210503153612863"></p><ul><li><p><strong>生产者阻塞：</strong> 在队列已满且没有可用空间时，生产者端的线程都会被自动阻塞（挂起），直到队列中有空的位置腾出来，线程会被自动唤醒并生产数据。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210503153741909.png" alt="image-20210503153741909"></p></li></ul><h2 id="阻塞队列的主要操作"><a href="#阻塞队列的主要操作" class="headerlink" title="阻塞队列的主要操作"></a>阻塞队列的主要操作</h2><p>阻塞队列的主要操作有插入操作和移除操作。插入操作有add(e)、offer(e)、put(e)、offer(e，time，unit)，移除操作有remove()，poll()，take()，poll(time，unit)。</p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>1、<code>public abstract boolean add(E paramE):</code>将指定的元素插入队列中，在成功时返回true，如果当前没有可用的空间，则抛出IllegalStateException。如果该元素是null，则抛出NullPointerException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个数据，如果添加成功，则返回true</span></span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果添加失败，则返回异常</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 、<code>public abstract boolean offer(E paramE)：</code>将指定的元素插入队列中，在成功时返回true，如果当前没有可用的空间，则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 如果队列满了， 则返回false</span></span><br><span class="line">        <span class="keyword">if</span>(count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="comment">// 如果队列有空间，则将元素加入队列中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<code>offer(E o, long timeout, TimeUnit unit)：</code>将指定的元素插入队列中，可以设定等待的时间，如果在设定的等待时间内仍不能向队列中加入元素，则返回false。</p><p>4、<code>public abstract void put(E paramE) throwsInterruptedException：</code>将指定的元素插入队列中，如果队列已经满了，则阻塞、等待可用的队列空间的释放，直到有可用的队列空间释放且插入成功为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrabtLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 获取独占锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) <span class="comment">//阻塞等待可用空间的释放</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e); <span class="comment">// 将元素加入队列中</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取数据操作"><a href="#获取数据操作" class="headerlink" title="获取数据操作"></a>获取数据操作</h3><p>1、<code>poll()：</code>取走队列队首的对象，如果取不到数据，则返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock =  <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁操作</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//如果获取不到 （count == 0） 则返回null</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; fianlly &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<code>poll(long timeout，TimeUnit unit)</code> 取出队列队首的对象，如果在指定的时间内队列有数据可取，则返回队列中的数据，否则等待一定时间，在等待超时并且没有数据可取时，返回null。</p><p>3、<code>take()：</code>取走队列队首的对象，如果队列为空，则进入阻塞状态等待，直到队列有新的数据被加入，再及时取出新加入的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 获取独占锁</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//如果队列为空，则进入阻塞状态，知道取到数据为止</span></span><br><span class="line">        <span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue(); <span class="comment">// 取出元素</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、<code>drainTo(Collection collection)：</code>一次性从队列中批量获取所有可用的数据对象，同时可以指定获取数据的个数，通过该方法可以提升获取数据的效率，避免多次频繁操作引起的队列锁定。</p><h2 id="JDK7-提供了-7-个阻塞队列"><a href="#JDK7-提供了-7-个阻塞队列" class="headerlink" title="JDK7 提供了 7 个阻塞队列"></a>JDK7 提供了 7 个阻塞队列</h2><ul><li>ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue: 一个链表结构组成的有界阻塞队列</li><li>PriorityBlockingQueue: 一个支持优先级排序的无界阻塞队列</li><li>DelayQueue: 一个使用优先级队列实现的无届阻塞队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li></ul><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p><strong>ArrayBlockingQueue</strong> 是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>访问者的公平性是使用可重入锁实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是一个支持优先级的无界队列。默认情况下元素采取自然顺序排列，也可以通过比较器 comparator 来指定元素的排序规则。元素按照升序排列。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue 是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景：</p><ul><li>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。</li><li>定时任务调度。使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从 DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。</li></ul><p>队列中的 Delayed 必须实现 compareTo 来指定元素的顺序。比如让延时时间最长的放在队列的末尾。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero ONLY if same object</span></span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">               ScheduledFutureTask x = (ScheduledFutureTask)other;</span><br><span class="line">               <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">               <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">                   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) -</span><br><span class="line">                     other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">           <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ((d &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>如何实现 Delayed 接口</strong></p><p>我们可以参考 ScheduledThreadPoolExecutor 里 ScheduledFutureTask 类。这个类实现了 Delayed 接口。首先：在对象创建的时候，使用 time 记录前对象什么时候可以使用，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">           <span class="keyword">super</span>(r, result);</span><br><span class="line">           <span class="keyword">this</span>.time = ns;</span><br><span class="line">           <span class="keyword">this</span>.period = period;</span><br><span class="line">           <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后使用 getDelay 可以查询当前元素还需要延时多久，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>通过构造函数可以看出延迟时间参数 ns 的单位是纳秒，自己设计的时候最好使用纳秒，因为 getDelay 时可以指定任意单位，一旦以纳秒作为单位，而延时的时间又精确不到纳秒就麻烦了。使用时请注意当 time 小于当前时间时，getDelay 会返回负数。</p><p><strong>如何实现延时队列</strong></p><p>延时队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                   <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">return</span> q.poll();</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                       available.await();</span><br></pre></td></tr></table></figure><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue 是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景, 比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。</p><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>LinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。</p><p>transfer 方法。如果当前有消费者正在等待接收元素（消费者使用 take() 方法或带时间限制的 poll() 方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。transfer 方法的关键代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">Node pred &#x3D; tryAppend(s, haveData);</span><br><span class="line">return awaitMatch(s, pred, e, (how &#x3D;&#x3D; TIMED), nanos);</span><br></pre></td></tr></table></figure><p>第一行代码是试图把存放当前元素的 s 节点作为 tail 节点。第二行代码是让 CPU 自旋等待消费者消费元素。因为自旋会消耗 CPU，所以自旋一定的次数后使用 Thread.yield() 方法来暂停当前正在执行的线程，并执行其他线程。</p><p>tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。</p><p>对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit) 方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。</p><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。</p><p>在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程上下文切换&quot;&gt;&lt;a href=&quot;#线程上下文切换&quot; class=&quot;headerlink&quot; title=&quot;线程上下文切换&quot;&gt;&lt;/a&gt;线程上下文切换&lt;/h1&gt;&lt;p&gt;CPU利用时间片轮询来为每个任务都服务一定的时间，然后把当前任务的状态保存下来，继续服务下一个任务。</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>6.java中的锁</title>
    <link href="https://leslieaibin.github.io/2021/05/03/Thread/6.java%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>https://leslieaibin.github.io/2021/05/03/Thread/6.java%E4%B8%AD%E7%9A%84%E9%94%81/</id>
    <published>2021-05-03T02:15:42.000Z</published>
    <updated>2021-05-25T09:08:09.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h1><p>java中的锁主要用于保障多并发线程情况下数据的一致性，在多线程编程中为了保障数据的一致性，我们通常需要在使用对象或者方法之前加锁，这是如果有其他线程也需要使用该对象或者该方法，则首先要获得锁，如果某个线程发现锁正在被其他线程使用就会进入阻塞队列，等待锁的释放，知道其他线程执行完成并释放锁，该线程才有机会再次获取锁进行操作。这样就保障了在同一时刻只有一个线程持有该对象的锁并修改对象，从而保障数据的安全。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/7f749fc8.png" alt="img"></p><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁采用乐观的思想处理数据，在每次读取数据时都认为别热不会修改该数据，所以不会上锁，但更新时会判断此期间别人有没有更新该数据，通常在写时先对出当前版本号然后加锁的方法。具体过程为：比较当前版本号与上一次的版本号，如果版本号一致，则更新，如果版本号不一致，则重复进行读、比较、写操作。</p><p>java中的乐观锁大部分是通过<code>CAS（Compar And Swap, 比较和交换）</code>操作实现的，CAS是一种原子更新操作，在对数据操作之前首先会比较当前值传入的值是否一样，如果一样则更新，否则不执行更新操作，直接返回失败状态。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁采用悲观思想处理数据，在每次读取数据时都认为别人会修改数据，所以每次在读写数据时都会上锁，这样别人想读写这个数据时就会阻塞，等待直拿到锁。</p><p>Java中的悲观锁大部分基于<code>AQS（Abstract Queued Synchronized, 抽象的队列同步器）</code>架构实现。AQS定义了一套多线程访问共享资源的同步框架，许多同步类的实现都依赖于它，例如常用的<code>Synchronized、ReentrantLock、Semaphore、CountDownLatch</code>等。该框架下的锁会现场时CAS乐观锁去获取锁，如果获取不到，则会转为悲观锁（如ReentrantLock）。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/c8703cd9.png" alt="img"></p><p>根据从上面的概念描述可以发现：</p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅度提升</li></ul><p>调用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------------------------- 乐观锁的调用方式 -------------------</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(); <span class="comment">// 需要保证多个线程使用的是同一个AtomicIntger</span></span><br><span class="line">atomicInteger.incrementAndGet;   <span class="comment">// 执行自增1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 --------------------</span></span><br><span class="line"><span class="comment">// synochronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> Reentrantlock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">// 操作同步资源</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p><p>CAS全称 <strong>Compare And Swap</strong>（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/feda866e.png" alt="img"></p><p>根据定义我们可以看出各属性的作用：</p><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储value在AtomicInteger中的偏移量。</li><li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li></ul><p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- JDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// AtomicInteger 自增方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- OpenJDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> v;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       v = getIntVolatile(o, offset);</span><br><span class="line">   &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据OpenJDK 8的源码我们可以看出，<code>getAndAddInt()</code>循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在<code>compareAndSwapInt()</code>中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p><p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p><p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p><ul><li><p>ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p><ul><li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li></ul></li><li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p></li><li><p><strong>只能保证一个共享变量的原子操作。</strong>对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p><ul><li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li></ul></li></ul><h2 id="自旋锁与适应性自旋锁"><a href="#自旋锁与适应性自旋锁" class="headerlink" title="自旋锁与适应性自旋锁"></a>自旋锁与适应性自旋锁</h2><h3 id="自旋锁："><a href="#自旋锁：" class="headerlink" title="自旋锁："></a>自旋锁：</h3><p>如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞，挂起状态，只需等一等（也叫作自旋），在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核状态上导致的锁时间消耗。</p><p>线程在自旋时会占用CPU，在线程长时间自旋获取不到锁时，将会产生CPU的浪费，甚至有时线程永远无法获取锁而导致CPU资源被永久占用，五哦一需要设定一个自旋等待的最大时间。在线程执行的时间超过自旋等待的最大时间后，线程会退出自旋模式并释放其持有的锁。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/452a3363.png" alt="img"></p><p><strong>自旋锁的优缺点</strong></p><ul><li><strong>优点：</strong>自旋锁可以减少CPU上下文的切换，对于占用锁的时间非常短或锁竞争不激烈的代码块来说性能大幅度提升，因为自旋的CPU耗时明显少于线程阻塞、挂起、再唤醒时两次CPU上下文切换所用的时间。◎</li><li><strong>缺点：</strong>在持有锁的线程占用锁时间过长或锁的竞争过于激烈时，线程在自旋过程中会长时间获取不到锁资源，将引起CPU的浪费。所以在系统中有复杂锁依赖的情况下不适合采用自旋锁。</li></ul><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/83b3f85e.png" alt="img"></p><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><h2 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p><p>首先为什么Synchronized能实现线程同步？</p><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p><p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p><strong>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</strong></p><p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p><table><thead><tr><th align="left">锁状态</th><th align="left">存储内容</th><th align="left">存储内容</th></tr></thead><tbody><tr><td align="left">无锁</td><td align="left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td align="left">01</td></tr><tr><td align="left">偏向锁</td><td align="left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td align="left">01</td></tr><tr><td align="left">轻量级锁</td><td align="left">指向栈中锁记录的指针</td><td align="left">00</td></tr><tr><td align="left">重量级锁</td><td align="left">指向互斥量（重量级锁）的指针</td><td align="left">10</td></tr></tbody></table><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a><strong>无锁</strong></h3><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h3><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h3><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a><strong>重量级锁</strong></h3><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p>整体的锁状态升级流程如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/8afdf6f2.png" alt="img"></p><p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><h2 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/a23d746a.png" alt="img"></p><p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4499559e.png" alt="img"></p><p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/6edea205.png" alt="img"></p><p>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/bc6fe583.png" alt="img"></p><p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/bd0036bb.png" alt="img"></p><p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p><p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><h2 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p><p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p><p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/58fc5bc9.png" alt="img"></p><p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/ea597a0c.png" alt="img"></p><p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p><p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/32536e7a.png" alt="img"></p><h2 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h2><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>下图为ReentrantReadWriteLock的部分源码：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/762a042b.png" alt="img"></p><p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p><p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/8793e00a.png" alt="img"></p><p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line"><span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line"><span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"><span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li><li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li><li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li><li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li><li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li></ul><p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p><p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p><p>接着是读锁的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p><p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/8b7878ec.png" alt="img"></p><p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。</p><p>其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java”锁”事</a></p><p><a href="https://weread.qq.com/web/reader/d0c3212071a74c21d0c04fd">Java中的锁</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java中的锁&quot;&gt;&lt;a href=&quot;#Java中的锁&quot; class=&quot;headerlink&quot; title=&quot;Java中的锁&quot;&gt;&lt;/a&gt;Java中的锁&lt;/h1&gt;&lt;p&gt;java中的锁主要用于保障多并发线程情况下数据的一致性，在多线程编程中为了保障数据的一致性，我们通常</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
